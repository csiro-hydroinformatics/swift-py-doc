{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python swift2 documentation","text":"<p>Documentation for the Python package swift2, a package for ensemble hydrologic modelling.</p>"},{"location":"#installation","title":"Installation","text":"<p>See Onboarding guide for streamflow forecasting software tools</p>"},{"location":"#license","title":"License","text":"<p>The swift2 python package itself is licensed with the BSD 3-Clause Licence</p>"},{"location":"#source-code","title":"Source code","text":"<p>The package source code \"point of truth\" is at this private repository, however a copy is also in the repository csiro-hydroinformatics/swift-py-doc.</p>"},{"location":"#llm-context-files","title":"LLM context files","text":"<p>Using LLMs for development is a best practice way to get started and explore. While LLMs cannot code for you, they can be helpful assistants. You must check, refactor, test, and vet any code any LLM generates for you - but they are helpful productivity tools. The following files will be useful as context for LLMs to build modelling workflows with the swift2 package.</p> <ul> <li>llms.txt: Links to what is included</li> <li>llms-ctx.txt: Programming API pages</li> </ul> <p>These files follow the proposed /llms.txt standard, and are produced with mkdocs-llmstxt.</p>"},{"location":"classes/","title":"Module classes","text":""},{"location":"classes/#swift2.classes.CompositeParameteriser","title":"<code>CompositeParameteriser</code>","text":"<p>               Bases: <code>HypercubeParameteriser</code></p> <p>A parameteriser defined as the concatenation of several parameterisers</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>class CompositeParameteriser(HypercubeParameteriser):\n    \"\"\"A parameteriser defined as the concatenation of several parameterisers\"\"\"\n    def __init__(\n        self,\n        handle: CffiData,\n        release_native: Callable[[CffiData], None],\n        type_id: Optional[str] = None,\n        prior_ref_count: int = 0,\n    ):\n        super(CompositeParameteriser, self).__init__(\n            handle, release_native, type_id, prior_ref_count\n        )\n\n    @staticmethod\n    def empty_composite() -&gt; \"CompositeParameteriser\":\n        \"\"\"Creates an empty parameteriser to be populated with other parameterisers\n\n        Returns:\n            CompositeParameteriser: composite parameteriser\n        \"\"\"        \n        return swg.CreateCompositeParameterizer_py()\n\n    @staticmethod\n    def concatenate(\n        *args: Sequence[\"HypercubeParameteriser\"], strategy: str = \"\"\n    ) -&gt; \"CompositeParameteriser\":\n        \"\"\"Concatenates some hypercubes to a single parameteriser\n\n        Args:\n            strategy (str, optional): The strategy to contatenate. Defaults to \"\", equivalent to \"composite\", the only available. May have other options in the future.\n\n        Returns:\n            CompositeParameteriser: A concatenated parameteriser\n        \"\"\"\n        return sp.concatenate_parameterisers(*args, strategy=strategy)\n\n    def append(self, p: \"HypercubeParameteriser\"):\n        \"\"\"Append a parameteriser to this composite parameteriser\n\n        Args:\n            p (HypercubeParameteriser): hypercube to append to this\n        \"\"\"        \n        swg.AddToCompositeParameterizer_py(self, p)\n</code></pre>"},{"location":"classes/#swift2.classes.CompositeParameteriser.append","title":"<code>append(p)</code>","text":"<p>Append a parameteriser to this composite parameteriser</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>HypercubeParameteriser</code> <p>hypercube to append to this</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def append(self, p: \"HypercubeParameteriser\"):\n    \"\"\"Append a parameteriser to this composite parameteriser\n\n    Args:\n        p (HypercubeParameteriser): hypercube to append to this\n    \"\"\"        \n    swg.AddToCompositeParameterizer_py(self, p)\n</code></pre>"},{"location":"classes/#swift2.classes.CompositeParameteriser.concatenate","title":"<code>concatenate(*args, strategy='')</code>  <code>staticmethod</code>","text":"<p>Concatenates some hypercubes to a single parameteriser</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>str</code> <p>The strategy to contatenate. Defaults to \"\", equivalent to \"composite\", the only available. May have other options in the future.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>CompositeParameteriser</code> <code>CompositeParameteriser</code> <p>A concatenated parameteriser</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>@staticmethod\ndef concatenate(\n    *args: Sequence[\"HypercubeParameteriser\"], strategy: str = \"\"\n) -&gt; \"CompositeParameteriser\":\n    \"\"\"Concatenates some hypercubes to a single parameteriser\n\n    Args:\n        strategy (str, optional): The strategy to contatenate. Defaults to \"\", equivalent to \"composite\", the only available. May have other options in the future.\n\n    Returns:\n        CompositeParameteriser: A concatenated parameteriser\n    \"\"\"\n    return sp.concatenate_parameterisers(*args, strategy=strategy)\n</code></pre>"},{"location":"classes/#swift2.classes.CompositeParameteriser.empty_composite","title":"<code>empty_composite()</code>  <code>staticmethod</code>","text":"<p>Creates an empty parameteriser to be populated with other parameterisers</p> <p>Returns:</p> Name Type Description <code>CompositeParameteriser</code> <code>CompositeParameteriser</code> <p>composite parameteriser</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>@staticmethod\ndef empty_composite() -&gt; \"CompositeParameteriser\":\n    \"\"\"Creates an empty parameteriser to be populated with other parameterisers\n\n    Returns:\n        CompositeParameteriser: composite parameteriser\n    \"\"\"        \n    return swg.CreateCompositeParameterizer_py()\n</code></pre>"},{"location":"classes/#swift2.classes.EnsembleSimulation","title":"<code>EnsembleSimulation</code>","text":"<p>               Bases: <code>DeletableCffiNativeHandle</code></p> <p>A simulation designed to facilitate model runs over ensemble of inputs</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>class EnsembleSimulation(DeletableCffiNativeHandle):\n    \"\"\"A simulation designed to facilitate model runs over ensemble of inputs\"\"\"\n    def __init__(\n        self,\n        handle: CffiData,\n        release_native: Callable[[CffiData], None],\n        type_id: Optional[str] = None,\n        prior_ref_count: int = 0,\n    ):\n        super(EnsembleSimulation, self).__init__(\n            handle, release_native, type_id, prior_ref_count\n        )\n\n    def setup(self, forecast_start: datetime, ensemble_size: int, forecast_horizon_length: int) -&gt; None:\n        \"\"\"Sets up this ensemble simulation\n\n        Args:\n            forecast_start (datetime): Start date for the simulation\n            ensemble_size (int): size of the ensemble\n            forecast_horizon_length (int): length of the simulation in numbers of time steps.\n        \"\"\"        \n        swg.SetupEnsembleModelRunner_py(\n            self, forecast_start, ensemble_size, forecast_horizon_length\n        )\n\n    def record(self, variable_id:str) -&gt; None:\n        \"\"\"Records a state variable of the simualtion\n\n        Args:\n            variable_id (str): state variable identifier\n        \"\"\"        \n        swg.RecordEnsembleModelRunner_py(self, variable_id)\n\n    def get_simulation_span(self) -&gt; Dict[str, Any]:\n        \"\"\"Gets the span of the simulation: start, end, time step\n\n        Returns:\n            Dict[str, Any]: simulation span\n        \"\"\"        \n        return swc.get_simulation_span_pkg(self)\n\n    def record_ensemble_state(\n        self,\n        var_ids: \"VecStr\" = CATCHMENT_FLOWRATE_VARID,\n        recording_provider: Optional[\"TimeSeriesLibrary\"] = None,\n        data_ids: Optional[\"VecStr\"] = None,\n    ) -&gt; None:\n        \"\"\"Records one or more state values from an ensemble simulation\n\n        Args:\n            var_ids (VecStr, optional): Model variable identierfier(s). Defaults to CATCHMENT_FLOWRATE_VARID.\n            recording_provider (Optional[TimeSeriesLibrary], optional): An optional time series library to record to. Defaults to None.\n            data_ids (Optional[VecStr], optional): Data identifier(s). Defaults to None.\n        \"\"\"    \n        spr.record_ensemble_state(self, var_ids, recording_provider, data_ids)\n</code></pre>"},{"location":"classes/#swift2.classes.EnsembleSimulation.get_simulation_span","title":"<code>get_simulation_span()</code>","text":"<p>Gets the span of the simulation: start, end, time step</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: simulation span</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_simulation_span(self) -&gt; Dict[str, Any]:\n    \"\"\"Gets the span of the simulation: start, end, time step\n\n    Returns:\n        Dict[str, Any]: simulation span\n    \"\"\"        \n    return swc.get_simulation_span_pkg(self)\n</code></pre>"},{"location":"classes/#swift2.classes.EnsembleSimulation.record","title":"<code>record(variable_id)</code>","text":"<p>Records a state variable of the simualtion</p> <p>Parameters:</p> Name Type Description Default <code>variable_id</code> <code>str</code> <p>state variable identifier</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def record(self, variable_id:str) -&gt; None:\n    \"\"\"Records a state variable of the simualtion\n\n    Args:\n        variable_id (str): state variable identifier\n    \"\"\"        \n    swg.RecordEnsembleModelRunner_py(self, variable_id)\n</code></pre>"},{"location":"classes/#swift2.classes.EnsembleSimulation.record_ensemble_state","title":"<code>record_ensemble_state(var_ids=CATCHMENT_FLOWRATE_VARID, recording_provider=None, data_ids=None)</code>","text":"<p>Records one or more state values from an ensemble simulation</p> <p>Parameters:</p> Name Type Description Default <code>var_ids</code> <code>VecStr</code> <p>Model variable identierfier(s). Defaults to CATCHMENT_FLOWRATE_VARID.</p> <code>CATCHMENT_FLOWRATE_VARID</code> <code>recording_provider</code> <code>Optional[TimeSeriesLibrary]</code> <p>An optional time series library to record to. Defaults to None.</p> <code>None</code> <code>data_ids</code> <code>Optional[VecStr]</code> <p>Data identifier(s). Defaults to None.</p> <code>None</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def record_ensemble_state(\n    self,\n    var_ids: \"VecStr\" = CATCHMENT_FLOWRATE_VARID,\n    recording_provider: Optional[\"TimeSeriesLibrary\"] = None,\n    data_ids: Optional[\"VecStr\"] = None,\n) -&gt; None:\n    \"\"\"Records one or more state values from an ensemble simulation\n\n    Args:\n        var_ids (VecStr, optional): Model variable identierfier(s). Defaults to CATCHMENT_FLOWRATE_VARID.\n        recording_provider (Optional[TimeSeriesLibrary], optional): An optional time series library to record to. Defaults to None.\n        data_ids (Optional[VecStr], optional): Data identifier(s). Defaults to None.\n    \"\"\"    \n    spr.record_ensemble_state(self, var_ids, recording_provider, data_ids)\n</code></pre>"},{"location":"classes/#swift2.classes.EnsembleSimulation.setup","title":"<code>setup(forecast_start, ensemble_size, forecast_horizon_length)</code>","text":"<p>Sets up this ensemble simulation</p> <p>Parameters:</p> Name Type Description Default <code>forecast_start</code> <code>datetime</code> <p>Start date for the simulation</p> required <code>ensemble_size</code> <code>int</code> <p>size of the ensemble</p> required <code>forecast_horizon_length</code> <code>int</code> <p>length of the simulation in numbers of time steps.</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def setup(self, forecast_start: datetime, ensemble_size: int, forecast_horizon_length: int) -&gt; None:\n    \"\"\"Sets up this ensemble simulation\n\n    Args:\n        forecast_start (datetime): Start date for the simulation\n        ensemble_size (int): size of the ensemble\n        forecast_horizon_length (int): length of the simulation in numbers of time steps.\n    \"\"\"        \n    swg.SetupEnsembleModelRunner_py(\n        self, forecast_start, ensemble_size, forecast_horizon_length\n    )\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser","title":"<code>HypercubeParameteriser</code>","text":"<p>               Bases: <code>Parameteriser</code></p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>class HypercubeParameteriser(Parameteriser):\n    def __init__(\n        self,\n        handle: CffiData,\n        release_native: Callable[[CffiData], None],\n        type_id: Optional[str] = None,\n        prior_ref_count: int = 0,\n    ):\n        super(HypercubeParameteriser, self).__init__(\n            handle, release_native, type_id, prior_ref_count\n        )\n\n    def __str__(self):\n        \"\"\"string representation\"\"\"\n        return str(self.as_dataframe())\n\n    def __repr__(self):\n        \"\"\"representation\"\"\"\n        return repr(self.as_dataframe())\n\n    def as_dataframe(self) -&gt; pd.DataFrame:\n        \"\"\"Convert this hypercube parameteriser to a pandas data frame representation\n\n        Returns:\n            pd.DataFrame: pandas data frame\n        \"\"\"\n        return sp.parameteriser_as_dataframe(self)\n\n    def num_free_parameters(self) -&gt; int:\n        \"\"\"Number of free parameters in this hypercube parameteriser\n\n        Returns:\n            int: Number of free parameters\n        \"\"\"\n        return sp.num_free_parameters(self)\n\n    def set_parameter_value(self, variable_name: \"VecStr\", value: \"VecScalars\"):\n        \"\"\"Sets the value(s) of one or more parameter(s)\n\n        Args:\n            variable_name (VecStr): one or more parameter name(s)\n            value (VecScalars): one or more parameter value(s)\n        \"\"\"\n        sp.set_parameter_value(self, variable_name, value)\n\n    def set_max_parameter_value(self, variable_name: \"VecStr\", value: \"VecScalars\"):\n        \"\"\"Sets the value(s) of the upper bound of one or more parameter(s)\n\n        Args:\n            variable_name (VecStr): one or more parameter name(s)\n            value (VecScalars): one or more parameter value(s)\n        \"\"\"\n        sp.set_max_parameter_value(self, variable_name, value)\n\n    def set_min_parameter_value(self, variable_name: \"VecStr\", value: \"VecScalars\"):\n        \"\"\"Sets the value(s) of the lower bound of one or more parameter(s)\n\n        Args:\n            variable_name (VecStr): one or more parameter name(s)\n            value (VecScalars): one or more parameter value(s)\n        \"\"\"\n        sp.set_min_parameter_value(self, variable_name, value)\n\n    def set_parameter_definition(\n        self, variable_name: str, min: float, max: float, value: float\n    ):\n        \"\"\"Sets the feasible range and value for a parameter\n\n        Args:\n            variable_name (str): parameter name\n            min (float): min\n            max (float): max\n            value (float): value\n        \"\"\"    \n        swg.SetParameterDefinition_py(self, variable_name, min, max, value)\n\n    def create_parameter_sampler(self, seed: int = 0, type: str = \"urs\") -&gt; \"CandidateFactorySeed\":\n        \"\"\"Creates a sampler for this parameteriser\n\n        Args:\n            seed (int, optional): a seed for the sampler. Defaults to 0.\n            type (str, optional): the type of sampler. Defaults to \"urs\". Only option supported as of 2023-01.\n\n        Returns:\n            CandidateFactorySeed: a sampler, aka candidate factory\n        \"\"\"        \n        return sp.create_parameter_sampler(seed, self, type)\n\n    def make_state_init_parameteriser(self) -&gt; \"StateInitParameteriser\":\n        \"\"\"Create a parameteriser used for model state initialisation\n\n        This allows to define tied parameters where, for instance, pval = a * modelStateVal. \n        A more concrete use case is to define an initial soil moisture store 'S0',\n        as a fraction of the model store capacity 'Smax'. \n        The model state to initialise is 'S'\n\n        Note:\n            See also [swift2.classes.ScalingParameteriser][] for typical joint usage.\n\n        Returns:\n            StateInitParameteriser: state initialisation parameteriser\n\n        Examples:\n            &gt;&gt;&gt; todo()\n        \"\"\"\n        return sp.make_state_init_parameteriser(self)\n\n    def filtered_parameters(self) -&gt; \"FilteringParameteriser\":\n        \"\"\"Wrap a parameteriser in a filter that can hide some parameters\"\"\"\n        return sp.filtered_parameters(self)\n\n    def hide_parameters(self, patterns, regex=False, starts_with=False, strict=False):\n        \"\"\"Hide some parameters (from the outside e.g. optimisers) in a filter parameteriser\n\n        Args:\n            patterns ([type]):  character, one or more pattern to match and hide matching parameters. Match according to other parameters.\n            regex (bool, optional): logical, defaults False, should the patterns be used as regular expressions.. Defaults to False.\n            starts_with (bool, optional): logical, defaults False. Ignored if regex is True. Should the patterns be used as starting strings in the parameter names.. Defaults to False.\n            strict (bool, optional): logical, default False. Used only if regex and starts_with are False. If True, raises an error if one of the \"patterns\" has no exact match in the parameters.. Defaults to False.\n        \"\"\"\n        sp.hide_parameters(self, patterns, regex, starts_with, strict)\n\n    def show_parameters(self, patterns, regex=False, starts_with=False):\n        \"\"\"Show some parameters (from the outside e.g. optimisers) in a filter parameteriser\n\n        Args:\n            patterns ([type]):  character, one or more pattern to match and show matching parameters. Match according to other parameters\n            regex (bool, optional): should the patterns be used as regular expressions. Defaults to False.\n            starts_with (bool, optional): should the patterns be used as starting strings in the parameter names. Defaults to False.\n        \"\"\"\n        sp.show_parameters(self, patterns, regex, starts_with)\n\n    def wrap_transform(self) -&gt; \"TransformParameteriser\":\n        \"\"\"Create a parameteriser for which parameter transformations can be defined.\n\n        This allows to define e.g. a virtual parameter log_X instead of calibrating on the parameter X.\n\n        Returns:\n            TransformParameteriser: A new parameteriser (TransformParameteriser) which has methods to define parameter transforms\n        \"\"\"\n        return sp.wrap_transform(self)\n\n    def backtransform(self) -&gt; \"HypercubeParameteriser\":\n        \"\"\"Get the parameteriser values in the untransformed space\n\n        Get the parameteriser values in the untransformed space, i.e. remove any \n        transform added via [`HypercubeParameteriser.wrap_transform`][HypercubeParameteriser.wrap_transform].\n        This allows to transform back e.g. from a virtual parameter log_X\n        to the underlying model (or even virtual/meta) parameter X.\n\n        Returns:\n            HypercubeParameteriser: The parameters definitions without the transforms (if there are any)\n\n        Examples:\n            &gt;&gt;&gt; ref_area = 250\n            &gt;&gt;&gt; time_span = 3600\n            &gt;&gt;&gt; ptrans = sdh.define_gr4j_scaled_parameter(ref_area, time_span)\n            &gt;&gt;&gt; ptrans\n                Name     Value       Min       Max\n            0    log_x4  0.305422  0.000000  2.380211\n            1    log_x1  0.506690  0.000000  3.778151\n            2    log_x3  0.315425  0.000000  3.000000\n            3  asinh_x2  2.637752 -3.989327  3.989327\n            &gt;&gt;&gt; ptrans.backtransform()\n            Name    Value   Min     Max\n            0   x2  6.95511 -27.0    27.0\n            1   x3  2.06740   1.0  1000.0\n            2   x4  2.02033   1.0   240.0\n            3   x1  3.21137   1.0  6000.0\n            &gt;&gt;&gt; \n        \"\"\"\n        return sp.backtransform(self)\n\n    @staticmethod\n    def from_dataframe(\n        type=\"Generic subareas\", definition: Optional[pd.DataFrame] = None\n    ) -&gt; \"HypercubeParameteriser\":\n        \"\"\"Create a parameteriser\n\n        Args:\n            type (str, optional): A string identifying the type of parameteriser to use. Recognised types are (case insensitive) 'log-likelihood', 'generic', 'subareas', 'links', 'nodes' and 'muskingum'. Defaults to \"Generic subareas\".\n            specs (pd.DataFrame, optional): An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value. Defaults to None.\n\n        Returns:\n            HypercubeParameteriser: new parameteriser\n\n        Examples:\n            &gt;&gt;&gt; d = pd.DataFrame(\n            ...     dict(\n            ...         Name=c(\"alpha\", \"inverse_velocity\"),\n            ...         Value=c(1, 1),\n            ...         Min=c(1e-3, 1e-3),\n            ...         Max=c(1e2, 1e2),\n            ...     )\n            ... )\n            &gt;&gt;&gt; p = HypercubeParameteriser.from_dataframe(\"Generic links\", d)\n            &gt;&gt;&gt; p\n        \"\"\"\n        return sp.create_parameteriser(type, specs=definition)\n\n    def add_to_hypercube(self, specs: pd.DataFrame):\n        \"\"\"Add entries to a hypercube. Must be a type of object that is expandable, otherwise may raise an exception.\n\n        Args:\n            specs (pd.DataFrame): An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value.\n        \"\"\"\n        sp.add_to_hypercube(self, specs)\n\n    def add_parameter_to_hypercube(\n        self, name: str, value: float, min: float, max: float\n    ):\n        \"\"\"Add a parameter to a hypercube. Must be a type of object that is expandable, otherwise may raise an exception\"\"\"\n        specs = parameter_df(name, value, min, max)\n        sp.add_to_hypercube(self, specs)\n\n    def set_hypercube(self, specs: pd.DataFrame):\n        \"\"\"Set the properties of a hypercube parameteriser\n\n        Args:\n            specs (pd.DataFrame): An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value.\n        \"\"\"\n        sp.set_hypercube(self, specs)\n\n    def clone(self) -&gt; \"HypercubeParameteriser\":\n        return swg.CloneHypercubeParameterizer_py(self)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.__repr__","title":"<code>__repr__()</code>","text":"<p>representation</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def __repr__(self):\n    \"\"\"representation\"\"\"\n    return repr(self.as_dataframe())\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.__str__","title":"<code>__str__()</code>","text":"<p>string representation</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def __str__(self):\n    \"\"\"string representation\"\"\"\n    return str(self.as_dataframe())\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.add_parameter_to_hypercube","title":"<code>add_parameter_to_hypercube(name, value, min, max)</code>","text":"<p>Add a parameter to a hypercube. Must be a type of object that is expandable, otherwise may raise an exception</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def add_parameter_to_hypercube(\n    self, name: str, value: float, min: float, max: float\n):\n    \"\"\"Add a parameter to a hypercube. Must be a type of object that is expandable, otherwise may raise an exception\"\"\"\n    specs = parameter_df(name, value, min, max)\n    sp.add_to_hypercube(self, specs)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.add_to_hypercube","title":"<code>add_to_hypercube(specs)</code>","text":"<p>Add entries to a hypercube. Must be a type of object that is expandable, otherwise may raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>specs</code> <code>DataFrame</code> <p>An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value.</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def add_to_hypercube(self, specs: pd.DataFrame):\n    \"\"\"Add entries to a hypercube. Must be a type of object that is expandable, otherwise may raise an exception.\n\n    Args:\n        specs (pd.DataFrame): An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value.\n    \"\"\"\n    sp.add_to_hypercube(self, specs)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.as_dataframe","title":"<code>as_dataframe()</code>","text":"<p>Convert this hypercube parameteriser to a pandas data frame representation</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: pandas data frame</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def as_dataframe(self) -&gt; pd.DataFrame:\n    \"\"\"Convert this hypercube parameteriser to a pandas data frame representation\n\n    Returns:\n        pd.DataFrame: pandas data frame\n    \"\"\"\n    return sp.parameteriser_as_dataframe(self)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.backtransform","title":"<code>backtransform()</code>","text":"<p>Get the parameteriser values in the untransformed space</p> <p>Get the parameteriser values in the untransformed space, i.e. remove any  transform added via [<code>HypercubeParameteriser.wrap_transform</code>][]. This allows to transform back e.g. from a virtual parameter log_X to the underlying model (or even virtual/meta) parameter X.</p> <p>Returns:</p> Name Type Description <code>HypercubeParameteriser</code> <code>HypercubeParameteriser</code> <p>The parameters definitions without the transforms (if there are any)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ref_area = 250\n&gt;&gt;&gt; time_span = 3600\n&gt;&gt;&gt; ptrans = sdh.define_gr4j_scaled_parameter(ref_area, time_span)\n&gt;&gt;&gt; ptrans\n    Name     Value       Min       Max\n0    log_x4  0.305422  0.000000  2.380211\n1    log_x1  0.506690  0.000000  3.778151\n2    log_x3  0.315425  0.000000  3.000000\n3  asinh_x2  2.637752 -3.989327  3.989327\n&gt;&gt;&gt; ptrans.backtransform()\nName    Value   Min     Max\n0   x2  6.95511 -27.0    27.0\n1   x3  2.06740   1.0  1000.0\n2   x4  2.02033   1.0   240.0\n3   x1  3.21137   1.0  6000.0\n&gt;&gt;&gt;\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def backtransform(self) -&gt; \"HypercubeParameteriser\":\n    \"\"\"Get the parameteriser values in the untransformed space\n\n    Get the parameteriser values in the untransformed space, i.e. remove any \n    transform added via [`HypercubeParameteriser.wrap_transform`][HypercubeParameteriser.wrap_transform].\n    This allows to transform back e.g. from a virtual parameter log_X\n    to the underlying model (or even virtual/meta) parameter X.\n\n    Returns:\n        HypercubeParameteriser: The parameters definitions without the transforms (if there are any)\n\n    Examples:\n        &gt;&gt;&gt; ref_area = 250\n        &gt;&gt;&gt; time_span = 3600\n        &gt;&gt;&gt; ptrans = sdh.define_gr4j_scaled_parameter(ref_area, time_span)\n        &gt;&gt;&gt; ptrans\n            Name     Value       Min       Max\n        0    log_x4  0.305422  0.000000  2.380211\n        1    log_x1  0.506690  0.000000  3.778151\n        2    log_x3  0.315425  0.000000  3.000000\n        3  asinh_x2  2.637752 -3.989327  3.989327\n        &gt;&gt;&gt; ptrans.backtransform()\n        Name    Value   Min     Max\n        0   x2  6.95511 -27.0    27.0\n        1   x3  2.06740   1.0  1000.0\n        2   x4  2.02033   1.0   240.0\n        3   x1  3.21137   1.0  6000.0\n        &gt;&gt;&gt; \n    \"\"\"\n    return sp.backtransform(self)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.create_parameter_sampler","title":"<code>create_parameter_sampler(seed=0, type='urs')</code>","text":"<p>Creates a sampler for this parameteriser</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>a seed for the sampler. Defaults to 0.</p> <code>0</code> <code>type</code> <code>str</code> <p>the type of sampler. Defaults to \"urs\". Only option supported as of 2023-01.</p> <code>'urs'</code> <p>Returns:</p> Name Type Description <code>CandidateFactorySeed</code> <code>CandidateFactorySeed</code> <p>a sampler, aka candidate factory</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def create_parameter_sampler(self, seed: int = 0, type: str = \"urs\") -&gt; \"CandidateFactorySeed\":\n    \"\"\"Creates a sampler for this parameteriser\n\n    Args:\n        seed (int, optional): a seed for the sampler. Defaults to 0.\n        type (str, optional): the type of sampler. Defaults to \"urs\". Only option supported as of 2023-01.\n\n    Returns:\n        CandidateFactorySeed: a sampler, aka candidate factory\n    \"\"\"        \n    return sp.create_parameter_sampler(seed, self, type)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.filtered_parameters","title":"<code>filtered_parameters()</code>","text":"<p>Wrap a parameteriser in a filter that can hide some parameters</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def filtered_parameters(self) -&gt; \"FilteringParameteriser\":\n    \"\"\"Wrap a parameteriser in a filter that can hide some parameters\"\"\"\n    return sp.filtered_parameters(self)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.from_dataframe","title":"<code>from_dataframe(type='Generic subareas', definition=None)</code>  <code>staticmethod</code>","text":"<p>Create a parameteriser</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>A string identifying the type of parameteriser to use. Recognised types are (case insensitive) 'log-likelihood', 'generic', 'subareas', 'links', 'nodes' and 'muskingum'. Defaults to \"Generic subareas\".</p> <code>'Generic subareas'</code> <code>specs</code> <code>DataFrame</code> <p>An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value. Defaults to None.</p> required <p>Returns:</p> Name Type Description <code>HypercubeParameteriser</code> <code>HypercubeParameteriser</code> <p>new parameteriser</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = pd.DataFrame(\n...     dict(\n...         Name=c(\"alpha\", \"inverse_velocity\"),\n...         Value=c(1, 1),\n...         Min=c(1e-3, 1e-3),\n...         Max=c(1e2, 1e2),\n...     )\n... )\n&gt;&gt;&gt; p = HypercubeParameteriser.from_dataframe(\"Generic links\", d)\n&gt;&gt;&gt; p\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>@staticmethod\ndef from_dataframe(\n    type=\"Generic subareas\", definition: Optional[pd.DataFrame] = None\n) -&gt; \"HypercubeParameteriser\":\n    \"\"\"Create a parameteriser\n\n    Args:\n        type (str, optional): A string identifying the type of parameteriser to use. Recognised types are (case insensitive) 'log-likelihood', 'generic', 'subareas', 'links', 'nodes' and 'muskingum'. Defaults to \"Generic subareas\".\n        specs (pd.DataFrame, optional): An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value. Defaults to None.\n\n    Returns:\n        HypercubeParameteriser: new parameteriser\n\n    Examples:\n        &gt;&gt;&gt; d = pd.DataFrame(\n        ...     dict(\n        ...         Name=c(\"alpha\", \"inverse_velocity\"),\n        ...         Value=c(1, 1),\n        ...         Min=c(1e-3, 1e-3),\n        ...         Max=c(1e2, 1e2),\n        ...     )\n        ... )\n        &gt;&gt;&gt; p = HypercubeParameteriser.from_dataframe(\"Generic links\", d)\n        &gt;&gt;&gt; p\n    \"\"\"\n    return sp.create_parameteriser(type, specs=definition)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.hide_parameters","title":"<code>hide_parameters(patterns, regex=False, starts_with=False, strict=False)</code>","text":"<p>Hide some parameters (from the outside e.g. optimisers) in a filter parameteriser</p> <p>Parameters:</p> Name Type Description Default <code>patterns</code> <code>[type]</code> <p>character, one or more pattern to match and hide matching parameters. Match according to other parameters.</p> required <code>regex</code> <code>bool</code> <p>logical, defaults False, should the patterns be used as regular expressions.. Defaults to False.</p> <code>False</code> <code>starts_with</code> <code>bool</code> <p>logical, defaults False. Ignored if regex is True. Should the patterns be used as starting strings in the parameter names.. Defaults to False.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>logical, default False. Used only if regex and starts_with are False. If True, raises an error if one of the \"patterns\" has no exact match in the parameters.. Defaults to False.</p> <code>False</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def hide_parameters(self, patterns, regex=False, starts_with=False, strict=False):\n    \"\"\"Hide some parameters (from the outside e.g. optimisers) in a filter parameteriser\n\n    Args:\n        patterns ([type]):  character, one or more pattern to match and hide matching parameters. Match according to other parameters.\n        regex (bool, optional): logical, defaults False, should the patterns be used as regular expressions.. Defaults to False.\n        starts_with (bool, optional): logical, defaults False. Ignored if regex is True. Should the patterns be used as starting strings in the parameter names.. Defaults to False.\n        strict (bool, optional): logical, default False. Used only if regex and starts_with are False. If True, raises an error if one of the \"patterns\" has no exact match in the parameters.. Defaults to False.\n    \"\"\"\n    sp.hide_parameters(self, patterns, regex, starts_with, strict)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.make_state_init_parameteriser","title":"<code>make_state_init_parameteriser()</code>","text":"<p>Create a parameteriser used for model state initialisation</p> <p>This allows to define tied parameters where, for instance, pval = a * modelStateVal.  A more concrete use case is to define an initial soil moisture store 'S0', as a fraction of the model store capacity 'Smax'.  The model state to initialise is 'S'</p> Note <p>See also swift2.classes.ScalingParameteriser for typical joint usage.</p> <p>Returns:</p> Name Type Description <code>StateInitParameteriser</code> <code>StateInitParameteriser</code> <p>state initialisation parameteriser</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; todo()\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def make_state_init_parameteriser(self) -&gt; \"StateInitParameteriser\":\n    \"\"\"Create a parameteriser used for model state initialisation\n\n    This allows to define tied parameters where, for instance, pval = a * modelStateVal. \n    A more concrete use case is to define an initial soil moisture store 'S0',\n    as a fraction of the model store capacity 'Smax'. \n    The model state to initialise is 'S'\n\n    Note:\n        See also [swift2.classes.ScalingParameteriser][] for typical joint usage.\n\n    Returns:\n        StateInitParameteriser: state initialisation parameteriser\n\n    Examples:\n        &gt;&gt;&gt; todo()\n    \"\"\"\n    return sp.make_state_init_parameteriser(self)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.num_free_parameters","title":"<code>num_free_parameters()</code>","text":"<p>Number of free parameters in this hypercube parameteriser</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of free parameters</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def num_free_parameters(self) -&gt; int:\n    \"\"\"Number of free parameters in this hypercube parameteriser\n\n    Returns:\n        int: Number of free parameters\n    \"\"\"\n    return sp.num_free_parameters(self)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.set_hypercube","title":"<code>set_hypercube(specs)</code>","text":"<p>Set the properties of a hypercube parameteriser</p> <p>Parameters:</p> Name Type Description Default <code>specs</code> <code>DataFrame</code> <p>An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value.</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_hypercube(self, specs: pd.DataFrame):\n    \"\"\"Set the properties of a hypercube parameteriser\n\n    Args:\n        specs (pd.DataFrame): An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value.\n    \"\"\"\n    sp.set_hypercube(self, specs)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.set_max_parameter_value","title":"<code>set_max_parameter_value(variable_name, value)</code>","text":"<p>Sets the value(s) of the upper bound of one or more parameter(s)</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>VecStr</code> <p>one or more parameter name(s)</p> required <code>value</code> <code>VecScalars</code> <p>one or more parameter value(s)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_max_parameter_value(self, variable_name: \"VecStr\", value: \"VecScalars\"):\n    \"\"\"Sets the value(s) of the upper bound of one or more parameter(s)\n\n    Args:\n        variable_name (VecStr): one or more parameter name(s)\n        value (VecScalars): one or more parameter value(s)\n    \"\"\"\n    sp.set_max_parameter_value(self, variable_name, value)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.set_min_parameter_value","title":"<code>set_min_parameter_value(variable_name, value)</code>","text":"<p>Sets the value(s) of the lower bound of one or more parameter(s)</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>VecStr</code> <p>one or more parameter name(s)</p> required <code>value</code> <code>VecScalars</code> <p>one or more parameter value(s)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_min_parameter_value(self, variable_name: \"VecStr\", value: \"VecScalars\"):\n    \"\"\"Sets the value(s) of the lower bound of one or more parameter(s)\n\n    Args:\n        variable_name (VecStr): one or more parameter name(s)\n        value (VecScalars): one or more parameter value(s)\n    \"\"\"\n    sp.set_min_parameter_value(self, variable_name, value)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.set_parameter_definition","title":"<code>set_parameter_definition(variable_name, min, max, value)</code>","text":"<p>Sets the feasible range and value for a parameter</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>parameter name</p> required <code>min</code> <code>float</code> <p>min</p> required <code>max</code> <code>float</code> <p>max</p> required <code>value</code> <code>float</code> <p>value</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_parameter_definition(\n    self, variable_name: str, min: float, max: float, value: float\n):\n    \"\"\"Sets the feasible range and value for a parameter\n\n    Args:\n        variable_name (str): parameter name\n        min (float): min\n        max (float): max\n        value (float): value\n    \"\"\"    \n    swg.SetParameterDefinition_py(self, variable_name, min, max, value)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.set_parameter_value","title":"<code>set_parameter_value(variable_name, value)</code>","text":"<p>Sets the value(s) of one or more parameter(s)</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>VecStr</code> <p>one or more parameter name(s)</p> required <code>value</code> <code>VecScalars</code> <p>one or more parameter value(s)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_parameter_value(self, variable_name: \"VecStr\", value: \"VecScalars\"):\n    \"\"\"Sets the value(s) of one or more parameter(s)\n\n    Args:\n        variable_name (VecStr): one or more parameter name(s)\n        value (VecScalars): one or more parameter value(s)\n    \"\"\"\n    sp.set_parameter_value(self, variable_name, value)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.show_parameters","title":"<code>show_parameters(patterns, regex=False, starts_with=False)</code>","text":"<p>Show some parameters (from the outside e.g. optimisers) in a filter parameteriser</p> <p>Parameters:</p> Name Type Description Default <code>patterns</code> <code>[type]</code> <p>character, one or more pattern to match and show matching parameters. Match according to other parameters</p> required <code>regex</code> <code>bool</code> <p>should the patterns be used as regular expressions. Defaults to False.</p> <code>False</code> <code>starts_with</code> <code>bool</code> <p>should the patterns be used as starting strings in the parameter names. Defaults to False.</p> <code>False</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def show_parameters(self, patterns, regex=False, starts_with=False):\n    \"\"\"Show some parameters (from the outside e.g. optimisers) in a filter parameteriser\n\n    Args:\n        patterns ([type]):  character, one or more pattern to match and show matching parameters. Match according to other parameters\n        regex (bool, optional): should the patterns be used as regular expressions. Defaults to False.\n        starts_with (bool, optional): should the patterns be used as starting strings in the parameter names. Defaults to False.\n    \"\"\"\n    sp.show_parameters(self, patterns, regex, starts_with)\n</code></pre>"},{"location":"classes/#swift2.classes.HypercubeParameteriser.wrap_transform","title":"<code>wrap_transform()</code>","text":"<p>Create a parameteriser for which parameter transformations can be defined.</p> <p>This allows to define e.g. a virtual parameter log_X instead of calibrating on the parameter X.</p> <p>Returns:</p> Name Type Description <code>TransformParameteriser</code> <code>TransformParameteriser</code> <p>A new parameteriser (TransformParameteriser) which has methods to define parameter transforms</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def wrap_transform(self) -&gt; \"TransformParameteriser\":\n    \"\"\"Create a parameteriser for which parameter transformations can be defined.\n\n    This allows to define e.g. a virtual parameter log_X instead of calibrating on the parameter X.\n\n    Returns:\n        TransformParameteriser: A new parameteriser (TransformParameteriser) which has methods to define parameter transforms\n    \"\"\"\n    return sp.wrap_transform(self)\n</code></pre>"},{"location":"classes/#swift2.classes.ObjectiveEvaluator","title":"<code>ObjectiveEvaluator</code>","text":"<p>               Bases: <code>DeletableCffiNativeHandle</code></p> <p>Objective Evaluator</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>class ObjectiveEvaluator(DeletableCffiNativeHandle):\n    \"\"\"Objective Evaluator\"\"\"\n    def __init__(\n        self,\n        handle: CffiData,\n        release_native: Callable[[CffiData], None],\n        type_id: Optional[str] = None,\n        prior_ref_count: int = 0,\n    ):\n        super(ObjectiveEvaluator, self).__init__(\n            handle, release_native, type_id, prior_ref_count\n        )\n\n    def create_sce_optim_swift(\n        self,\n        termination_criterion: Optional[\"SceTerminationCondition\"] = None,\n        sce_params: Optional[Dict[str, float]] = None,\n        population_initialiser: Optional[Union[\"CandidateFactorySeed\", \"HypercubeParameteriser\"]] = None,\n    ) -&gt; \"Optimiser\":\n        \"\"\"Creates a shuffled complex optimiser for this objective\n\n        Args:\n            termination_criterion (Optional[&amp;quot;SceTerminationCondition&amp;quot;], optional): A termination criterion for the optimiser. Defaults to None, in which case an arbitrary \"relative standard deviation\" is set up.\n            sce_params (Optional[Dict[str, float]], optional): hyperparameters controlling SCE. Defaults to None, in which case [`swift2.parameteriser.get_default_sce_parameters`][swift2.parameteriser.get_default_sce_parameters] is used.\n            population_initialiser (Optional[&amp;quot;CandidateFactorySeed&amp;quot;], optional): A candidate factory to initialise the population of parameters the optimiser starts from, or a hypercube. In the latter case, uniform random sampling is used. Defaults to None, which leads to an error (for legacy reasons). \n\n        Returns:\n            Optimiser: SCE optimiser\n        \"\"\"    \n        return sp.create_sce_optim_swift(\n            self, termination_criterion, sce_params, population_initialiser\n        )\n\n    # CreateOptimizerWila?\n\n    def get_score(self, p_set: \"HypercubeParameteriser\") -&gt; Dict[str,Any]:\n        \"\"\"Evaluate this objective for a given parameterisation\n\n        Args:\n            p_set (HypercubeParameteriser): parameteriser\n\n        Returns:\n            Dict[str,Any]: score(s), and a data frame representation of the input parameters.\n        \"\"\"\n        return ssf.get_score(self, p_set)\n\n    def get_scores(self, p_set: \"HypercubeParameteriser\") -&gt; Dict[str,float]:\n        \"\"\"Evaluate this objective for a given parameterisation\n\n        Args:\n            p_set (HypercubeParameteriser): parameteriser\n\n        Returns:\n            Dict[str,float]: score(s)\n        \"\"\"\n        return swg.EvaluateScoresForParametersWila_py(self, p_set)\n\n    # EvaluateScoreForParametersWilaInitState?\n\n    @staticmethod\n    def create_composite_objective(\n        objectives: Sequence[\"ObjectiveEvaluator\"],\n        weights: Sequence[float],\n        names: Sequence[str],\n    ) -&gt; \"ObjectiveEvaluator\":\n        \"\"\"Creates a composite objective, weighted average of several objectives\n\n        Args:\n            objectives (Sequence[&amp;quot;ObjectiveEvaluator&amp;quot;]): objective evaluators, for instance measures at several points in the catchment\n            weights (Sequence[float]): Weights to use to average the objectives. This may not add to one, but must not sum to zero\n            names (Sequence[str]): Names of individual objectives\n\n        Returns:\n            ObjectiveEvaluator: An objective evaluator that can be use by an optimiser\n        \"\"\"    \n        return ssf.create_composite_objective(objectives, weights, names)\n</code></pre>"},{"location":"classes/#swift2.classes.ObjectiveEvaluator.create_composite_objective","title":"<code>create_composite_objective(objectives, weights, names)</code>  <code>staticmethod</code>","text":"<p>Creates a composite objective, weighted average of several objectives</p> <p>Parameters:</p> Name Type Description Default <code>objectives</code> <code>Sequence[&amp;quot;ObjectiveEvaluator&amp;quot;]</code> <p>objective evaluators, for instance measures at several points in the catchment</p> required <code>weights</code> <code>Sequence[float]</code> <p>Weights to use to average the objectives. This may not add to one, but must not sum to zero</p> required <code>names</code> <code>Sequence[str]</code> <p>Names of individual objectives</p> required <p>Returns:</p> Name Type Description <code>ObjectiveEvaluator</code> <code>ObjectiveEvaluator</code> <p>An objective evaluator that can be use by an optimiser</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>@staticmethod\ndef create_composite_objective(\n    objectives: Sequence[\"ObjectiveEvaluator\"],\n    weights: Sequence[float],\n    names: Sequence[str],\n) -&gt; \"ObjectiveEvaluator\":\n    \"\"\"Creates a composite objective, weighted average of several objectives\n\n    Args:\n        objectives (Sequence[&amp;quot;ObjectiveEvaluator&amp;quot;]): objective evaluators, for instance measures at several points in the catchment\n        weights (Sequence[float]): Weights to use to average the objectives. This may not add to one, but must not sum to zero\n        names (Sequence[str]): Names of individual objectives\n\n    Returns:\n        ObjectiveEvaluator: An objective evaluator that can be use by an optimiser\n    \"\"\"    \n    return ssf.create_composite_objective(objectives, weights, names)\n</code></pre>"},{"location":"classes/#swift2.classes.ObjectiveEvaluator.create_sce_optim_swift","title":"<code>create_sce_optim_swift(termination_criterion=None, sce_params=None, population_initialiser=None)</code>","text":"<p>Creates a shuffled complex optimiser for this objective</p> <p>Parameters:</p> Name Type Description Default <code>termination_criterion</code> <code>Optional[&amp;quot;SceTerminationCondition&amp;quot;]</code> <p>A termination criterion for the optimiser. Defaults to None, in which case an arbitrary \"relative standard deviation\" is set up.</p> <code>None</code> <code>sce_params</code> <code>Optional[Dict[str, float]]</code> <p>hyperparameters controlling SCE. Defaults to None, in which case <code>swift2.parameteriser.get_default_sce_parameters</code> is used.</p> <code>None</code> <code>population_initialiser</code> <code>Optional[&amp;quot;CandidateFactorySeed&amp;quot;]</code> <p>A candidate factory to initialise the population of parameters the optimiser starts from, or a hypercube. In the latter case, uniform random sampling is used. Defaults to None, which leads to an error (for legacy reasons). </p> <code>None</code> <p>Returns:</p> Name Type Description <code>Optimiser</code> <code>Optimiser</code> <p>SCE optimiser</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def create_sce_optim_swift(\n    self,\n    termination_criterion: Optional[\"SceTerminationCondition\"] = None,\n    sce_params: Optional[Dict[str, float]] = None,\n    population_initialiser: Optional[Union[\"CandidateFactorySeed\", \"HypercubeParameteriser\"]] = None,\n) -&gt; \"Optimiser\":\n    \"\"\"Creates a shuffled complex optimiser for this objective\n\n    Args:\n        termination_criterion (Optional[&amp;quot;SceTerminationCondition&amp;quot;], optional): A termination criterion for the optimiser. Defaults to None, in which case an arbitrary \"relative standard deviation\" is set up.\n        sce_params (Optional[Dict[str, float]], optional): hyperparameters controlling SCE. Defaults to None, in which case [`swift2.parameteriser.get_default_sce_parameters`][swift2.parameteriser.get_default_sce_parameters] is used.\n        population_initialiser (Optional[&amp;quot;CandidateFactorySeed&amp;quot;], optional): A candidate factory to initialise the population of parameters the optimiser starts from, or a hypercube. In the latter case, uniform random sampling is used. Defaults to None, which leads to an error (for legacy reasons). \n\n    Returns:\n        Optimiser: SCE optimiser\n    \"\"\"    \n    return sp.create_sce_optim_swift(\n        self, termination_criterion, sce_params, population_initialiser\n    )\n</code></pre>"},{"location":"classes/#swift2.classes.ObjectiveEvaluator.get_score","title":"<code>get_score(p_set)</code>","text":"<p>Evaluate this objective for a given parameterisation</p> <p>Parameters:</p> Name Type Description Default <code>p_set</code> <code>HypercubeParameteriser</code> <p>parameteriser</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str,Any]: score(s), and a data frame representation of the input parameters.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_score(self, p_set: \"HypercubeParameteriser\") -&gt; Dict[str,Any]:\n    \"\"\"Evaluate this objective for a given parameterisation\n\n    Args:\n        p_set (HypercubeParameteriser): parameteriser\n\n    Returns:\n        Dict[str,Any]: score(s), and a data frame representation of the input parameters.\n    \"\"\"\n    return ssf.get_score(self, p_set)\n</code></pre>"},{"location":"classes/#swift2.classes.ObjectiveEvaluator.get_scores","title":"<code>get_scores(p_set)</code>","text":"<p>Evaluate this objective for a given parameterisation</p> <p>Parameters:</p> Name Type Description Default <code>p_set</code> <code>HypercubeParameteriser</code> <p>parameteriser</p> required <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dict[str,float]: score(s)</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_scores(self, p_set: \"HypercubeParameteriser\") -&gt; Dict[str,float]:\n    \"\"\"Evaluate this objective for a given parameterisation\n\n    Args:\n        p_set (HypercubeParameteriser): parameteriser\n\n    Returns:\n        Dict[str,float]: score(s)\n    \"\"\"\n    return swg.EvaluateScoresForParametersWila_py(self, p_set)\n</code></pre>"},{"location":"classes/#swift2.classes.ObjectiveScores","title":"<code>ObjectiveScores</code>","text":"<p>               Bases: <code>DeletableCffiNativeHandle</code></p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>class ObjectiveScores(DeletableCffiNativeHandle):\n    def __init__(\n        self,\n        handle: CffiData,\n        release_native: Callable[[CffiData], None],\n        type_id: Optional[str] = None,\n        prior_ref_count: int = 0,\n    ):\n        super(ObjectiveScores, self).__init__(\n            handle, release_native, type_id, prior_ref_count\n        )\n\n    def as_py_structure(self):\n        return sp.as_py_structure(self)\n\n    def apply_sys_config(self, simulation: 'Simulation') -&gt; None:\n        \"\"\"Apply the model configuration (parameteriser) associated with this object to a simulation\n\n        Args:\n            simulation (Simulation): simulation\n        \"\"\"\n        sp.apply_sys_config(self, simulation)\n\n    @property\n    def parameteriser(self) -&gt; \"HypercubeParameteriser\":\n        \"\"\"The parameteriser associated with this object\"\"\"\n        return sp.parameteriser_for_score(self)\n\n    @property\n    def scores(self) -&gt; Dict[str, float]:\n        return swc.fitnesses_as_rpy_dict(self)\n\n    @property\n    def num_scores(self) -&gt; int:\n        return swg.GetNumScoresWila_py(self)\n\n    def __str__(self):\n        \"\"\"string representation\"\"\"\n        return f\"{super().__str__()}\\n\\nScores:\\n\\n{str(self.scores)}\\n\\nParameters:\\n\\n{str(self.parameteriser)}\"\n</code></pre>"},{"location":"classes/#swift2.classes.ObjectiveScores.parameteriser","title":"<code>parameteriser</code>  <code>property</code>","text":"<p>The parameteriser associated with this object</p>"},{"location":"classes/#swift2.classes.ObjectiveScores.__str__","title":"<code>__str__()</code>","text":"<p>string representation</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def __str__(self):\n    \"\"\"string representation\"\"\"\n    return f\"{super().__str__()}\\n\\nScores:\\n\\n{str(self.scores)}\\n\\nParameters:\\n\\n{str(self.parameteriser)}\"\n</code></pre>"},{"location":"classes/#swift2.classes.ObjectiveScores.apply_sys_config","title":"<code>apply_sys_config(simulation)</code>","text":"<p>Apply the model configuration (parameteriser) associated with this object to a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>simulation</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def apply_sys_config(self, simulation: 'Simulation') -&gt; None:\n    \"\"\"Apply the model configuration (parameteriser) associated with this object to a simulation\n\n    Args:\n        simulation (Simulation): simulation\n    \"\"\"\n    sp.apply_sys_config(self, simulation)\n</code></pre>"},{"location":"classes/#swift2.classes.Optimiser","title":"<code>Optimiser</code>","text":"<p>               Bases: <code>DeletableCffiNativeHandle</code></p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>class Optimiser(DeletableCffiNativeHandle):\n    def __init__(\n        self,\n        handle: CffiData,\n        release_native: Callable[[CffiData], None],\n        type_id: Optional[str] = None,\n        prior_ref_count: int = 0,\n    ):\n        super(Optimiser, self).__init__(\n            handle, release_native, type_id, prior_ref_count\n        )\n\n    def set_calibration_logger(self, type:str=\"\") -&gt; None:\n        \"\"\"Set the type of calibration logger to use\n\n        Args:\n            type (str, optional): The type of logger. Unused for now, future option e.g. 'text', 'database'. Defaults to \"\".\n        \"\"\"\n        return sp.set_calibration_logger(self, type)\n\n    def execute_optimisation(self):\n        return sp.execute_optimisation(self)\n\n    def extract_optimisation_log(self, fitness_name:str=\"log.likelihood\") -&gt; 'sp.MhData':\n        \"\"\"Extract the logger from a parameter extimator (optimiser or related)\n\n        Args:\n            fitness_name (str, optional): name of the fitness function to extract. Defaults to \"log.likelihood\".\n\n        Returns:\n            MhData: an object with methods to analyse the optimisation log\n        \"\"\"\n        return sp.extract_optimisation_log(self, fitness_name)\n\n    def set_maximum_threads(self, n_threads: int = -1):\n        \"\"\"Set the maximum number of threads (compute cores) to use in the optimisation, if possible. -1 means \"as many as available\". \"\"\"\n        swg.SetMaxThreadsOptimizerWila_py(self, n_threads)\n\n    def set_maximum_threads_free_cores(self, n_free_cores: int = 1):\n        \"\"\"Set the maximum number of threads (compute cores) to use in the optimisation, such that at least `n_free_cores` are left for other tasks, if feasible given hardware constraints.\n        \"\"\"\n        swg.SetMaxDegreeOfParallelismHardwareMinusWila_py(self, n_free_cores)\n\n    @staticmethod\n    def set_default_maximum_threads(n_threads: int):\n        swg.SetDefaultMaxThreadsWila_py(n_threads)\n\n    @staticmethod\n    def get_default_maximum_threads() -&gt; int:\n        return swg.GetDefaultMaxThreadsWila_py()\n</code></pre>"},{"location":"classes/#swift2.classes.Optimiser.extract_optimisation_log","title":"<code>extract_optimisation_log(fitness_name='log.likelihood')</code>","text":"<p>Extract the logger from a parameter extimator (optimiser or related)</p> <p>Parameters:</p> Name Type Description Default <code>fitness_name</code> <code>str</code> <p>name of the fitness function to extract. Defaults to \"log.likelihood\".</p> <code>'log.likelihood'</code> <p>Returns:</p> Name Type Description <code>MhData</code> <code>MhData</code> <p>an object with methods to analyse the optimisation log</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def extract_optimisation_log(self, fitness_name:str=\"log.likelihood\") -&gt; 'sp.MhData':\n    \"\"\"Extract the logger from a parameter extimator (optimiser or related)\n\n    Args:\n        fitness_name (str, optional): name of the fitness function to extract. Defaults to \"log.likelihood\".\n\n    Returns:\n        MhData: an object with methods to analyse the optimisation log\n    \"\"\"\n    return sp.extract_optimisation_log(self, fitness_name)\n</code></pre>"},{"location":"classes/#swift2.classes.Optimiser.set_calibration_logger","title":"<code>set_calibration_logger(type='')</code>","text":"<p>Set the type of calibration logger to use</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>The type of logger. Unused for now, future option e.g. 'text', 'database'. Defaults to \"\".</p> <code>''</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_calibration_logger(self, type:str=\"\") -&gt; None:\n    \"\"\"Set the type of calibration logger to use\n\n    Args:\n        type (str, optional): The type of logger. Unused for now, future option e.g. 'text', 'database'. Defaults to \"\".\n    \"\"\"\n    return sp.set_calibration_logger(self, type)\n</code></pre>"},{"location":"classes/#swift2.classes.Optimiser.set_maximum_threads","title":"<code>set_maximum_threads(n_threads=-1)</code>","text":"<p>Set the maximum number of threads (compute cores) to use in the optimisation, if possible. -1 means \"as many as available\".</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_maximum_threads(self, n_threads: int = -1):\n    \"\"\"Set the maximum number of threads (compute cores) to use in the optimisation, if possible. -1 means \"as many as available\". \"\"\"\n    swg.SetMaxThreadsOptimizerWila_py(self, n_threads)\n</code></pre>"},{"location":"classes/#swift2.classes.Optimiser.set_maximum_threads_free_cores","title":"<code>set_maximum_threads_free_cores(n_free_cores=1)</code>","text":"<p>Set the maximum number of threads (compute cores) to use in the optimisation, such that at least <code>n_free_cores</code> are left for other tasks, if feasible given hardware constraints.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_maximum_threads_free_cores(self, n_free_cores: int = 1):\n    \"\"\"Set the maximum number of threads (compute cores) to use in the optimisation, such that at least `n_free_cores` are left for other tasks, if feasible given hardware constraints.\n    \"\"\"\n    swg.SetMaxDegreeOfParallelismHardwareMinusWila_py(self, n_free_cores)\n</code></pre>"},{"location":"classes/#swift2.classes.Parameteriser","title":"<code>Parameteriser</code>","text":"<p>               Bases: <code>DeletableCffiNativeHandle</code></p> <p>Wrapper around a native parameteriser.</p> Note <p>This is a parent class for more common types such as  swift2.classes.HypercubeParameteriser</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>class Parameteriser(DeletableCffiNativeHandle):\n    \"\"\"Wrapper around a native parameteriser.\n\n    Note:\n        This is a parent class for more common types such as \n        [swift2.classes.HypercubeParameteriser][]\n\n    \"\"\"\n    def __init__(\n        self,\n        handle: CffiData,\n        release_native: Callable[[CffiData], None],\n        type_id: Optional[str] = None,\n        prior_ref_count: int = 0,\n    ):\n        super(Parameteriser, self).__init__(\n            handle, release_native, type_id, prior_ref_count\n        )\n\n    def score_for_objective(self, objective: \"ObjectiveEvaluator\") -&gt; Dict[str, Any]:\n        \"\"\"Computes the value of an objective for this given set of parameters\"\"\"\n        return sp.evaluate_score_for_parameters(objective, self)\n\n    # def _sapply_parameter_set(self, variable_name, value, api_func):\n    #     sp._sapply_parameter_set(self, variable_name, value, api_func)\n\n    def subcatchment_parameteriser(self, subcatchment):\n        \"\"\"Create a parameteriser that gets applied to a subset of a whole catchment\n\n        Args:\n            subcatchment (Simulation): the subcatchment, subset of a whole catchment, identifying which elements (subareas, nodes, links) will be parameterised by the new parameteriser. Other catchment elements are untouched.\n\n        Returns:\n            HypercubeParameteriser: New parameteriser whose application is limited to the subcatchment.\n\n        Examples:\n            &gt;&gt;&gt; sub_cats = simulation.split_to_subcatchments([\"node.node_7\", \"node.node_10\"])\n            &gt;&gt;&gt; sc = sub_cats[\"node.node_7\"]\n            &gt;&gt;&gt; p = sp.create_parameteriser('generic subarea')\n            &gt;&gt;&gt; p.add_parameter_to_hypercube(\"x1\", 32, 1, 6e3)\n            &gt;&gt;&gt; sp = p.subcatchment_parameteriser(sc)\n            &gt;&gt;&gt; sp.apply_sys_config(simulation)\n\n        \"\"\"\n        return sp.subcatchment_parameteriser(self, subcatchment)\n\n    def apply_sys_config(self, simulation:\"Simulation\"):\n        \"\"\"Apply a model configuration to a simulation\n\n        Args:\n            simulation (Simulation): simulation\n        \"\"\"\n        sp.apply_sys_config(self, simulation)\n\n    def supports_thread_safe_cloning(self) -&gt; bool:\n        \"\"\"Is this parameteriser clonable as a deep copy, safe for multi-threading?\"\"\"\n        return swg.SupportsThreadSafeCloning_py(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Parameteriser.apply_sys_config","title":"<code>apply_sys_config(simulation)</code>","text":"<p>Apply a model configuration to a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>simulation</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def apply_sys_config(self, simulation:\"Simulation\"):\n    \"\"\"Apply a model configuration to a simulation\n\n    Args:\n        simulation (Simulation): simulation\n    \"\"\"\n    sp.apply_sys_config(self, simulation)\n</code></pre>"},{"location":"classes/#swift2.classes.Parameteriser.score_for_objective","title":"<code>score_for_objective(objective)</code>","text":"<p>Computes the value of an objective for this given set of parameters</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def score_for_objective(self, objective: \"ObjectiveEvaluator\") -&gt; Dict[str, Any]:\n    \"\"\"Computes the value of an objective for this given set of parameters\"\"\"\n    return sp.evaluate_score_for_parameters(objective, self)\n</code></pre>"},{"location":"classes/#swift2.classes.Parameteriser.subcatchment_parameteriser","title":"<code>subcatchment_parameteriser(subcatchment)</code>","text":"<p>Create a parameteriser that gets applied to a subset of a whole catchment</p> <p>Parameters:</p> Name Type Description Default <code>subcatchment</code> <code>Simulation</code> <p>the subcatchment, subset of a whole catchment, identifying which elements (subareas, nodes, links) will be parameterised by the new parameteriser. Other catchment elements are untouched.</p> required <p>Returns:</p> Name Type Description <code>HypercubeParameteriser</code> <p>New parameteriser whose application is limited to the subcatchment.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sub_cats = simulation.split_to_subcatchments([\"node.node_7\", \"node.node_10\"])\n&gt;&gt;&gt; sc = sub_cats[\"node.node_7\"]\n&gt;&gt;&gt; p = sp.create_parameteriser('generic subarea')\n&gt;&gt;&gt; p.add_parameter_to_hypercube(\"x1\", 32, 1, 6e3)\n&gt;&gt;&gt; sp = p.subcatchment_parameteriser(sc)\n&gt;&gt;&gt; sp.apply_sys_config(simulation)\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def subcatchment_parameteriser(self, subcatchment):\n    \"\"\"Create a parameteriser that gets applied to a subset of a whole catchment\n\n    Args:\n        subcatchment (Simulation): the subcatchment, subset of a whole catchment, identifying which elements (subareas, nodes, links) will be parameterised by the new parameteriser. Other catchment elements are untouched.\n\n    Returns:\n        HypercubeParameteriser: New parameteriser whose application is limited to the subcatchment.\n\n    Examples:\n        &gt;&gt;&gt; sub_cats = simulation.split_to_subcatchments([\"node.node_7\", \"node.node_10\"])\n        &gt;&gt;&gt; sc = sub_cats[\"node.node_7\"]\n        &gt;&gt;&gt; p = sp.create_parameteriser('generic subarea')\n        &gt;&gt;&gt; p.add_parameter_to_hypercube(\"x1\", 32, 1, 6e3)\n        &gt;&gt;&gt; sp = p.subcatchment_parameteriser(sc)\n        &gt;&gt;&gt; sp.apply_sys_config(simulation)\n\n    \"\"\"\n    return sp.subcatchment_parameteriser(self, subcatchment)\n</code></pre>"},{"location":"classes/#swift2.classes.Parameteriser.supports_thread_safe_cloning","title":"<code>supports_thread_safe_cloning()</code>","text":"<p>Is this parameteriser clonable as a deep copy, safe for multi-threading?</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def supports_thread_safe_cloning(self) -&gt; bool:\n    \"\"\"Is this parameteriser clonable as a deep copy, safe for multi-threading?\"\"\"\n    return swg.SupportsThreadSafeCloning_py(self)\n</code></pre>"},{"location":"classes/#swift2.classes.ScalingParameteriser","title":"<code>ScalingParameteriser</code>","text":"<p>               Bases: <code>TransformParameteriser</code></p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>class ScalingParameteriser(TransformParameteriser):\n    def __init__(\n        self,\n        handle: CffiData,\n        release_native: Callable[[CffiData], None],\n        type_id: Optional[str] = None,\n        prior_ref_count: int = 0,\n    ):\n        super(ScalingParameteriser, self).__init__(\n            handle, release_native, type_id, prior_ref_count\n        )\n\n    @staticmethod\n    def linear_parameteriser_from(\n        data_frame: pd.DataFrame, selector_type: str = \"subareas\"\n    ):\n        \"\"\"Create a scaled linear parameteriser, tying by a linear transformation a (resp several) model state to a (resp several) parameter values\n        This allows to define tied parameters where pval = a * modelStateVal + intercept. The intent in particular is to define virtual model parameters such as initial store value as a fraction of the maximum storage capacity.\n\n        Args:\n            data_frame (pd.DataFrame): data frame with columns \"param_name\", \"state_name\", \"scaling_var_name\", \"min_value\", \"max_value\", \"value\", \"intercept\",\n            selector_type (str, optional): [description]. Defaults to \"subareas\".\n\n        Returns:\n            ScalingParameteriser: ScalingParameteriser\n        \"\"\"\n        return sp.linear_parameteriser_from(data_frame, selector_type)\n\n    @staticmethod\n    def linear_parameteriser(\n        param_name: \"VecStr\",\n        state_name: \"VecStr\",\n        scaling_var_name: \"VecStr\",\n        min_p_val: \"VecNum\",\n        max_p_val: \"VecNum\",\n        value: \"VecNum\",\n        selector_type: str = \"subareas\",\n        intercept: \"VecNum\" = 0.0,\n    ):\n        \"\"\"Create a scaled linear parameteriser, tying by a linear transformation a (resp several) model state to a (resp several) parameter values\n\n        This allows to define tied parameters where pval = a * modelStateVal + intercept.\n        The intent in particular is to define virtual model parameters such as initial store value as a fraction of the maximum storage capacity.\n\n        Args:\n\n            param_name (VecStr): the name of the meta-parameter. Note that it can be the same value as inner_param_name without interference, though this may be confusing a choice.\n            state_name (VecStr): the name of the model state to modify, based on the value of the meta-parameter and the state found in 'scalingVarName'\n            scaling_var_name (VecStr): the name of the parameter for each subarea model, to which to apply the area scaled value.\n            min_p_val (VecNum): minimum value allowed for the meta-parameter\n            max_p_val (VecNum): minimum value allowed for the meta-parameter\n            value (VecNum): value for the meta parameter.\n            selector_type (str, optional): an identifier to define to which catchment element(s) the parameteriser will be applied. Defaults to \"subareas\".\n            intercept (VecNum, optional): [description]. Defaults to 0.0.\n\n        Returns:\n            ScalingParameteriser: new ScalingParameteriser\n        \"\"\"\n        return sp.linear_parameteriser(\n            param_name,\n            state_name,\n            scaling_var_name,\n            min_p_val,\n            max_p_val,\n            value,\n            selector_type,\n            intercept,\n        )\n\n    def add_linear_scaled_parameter(\n        self,\n        param_name: str,\n        state_name: str,\n        scaling_var_name: str,\n        min_p_val: float,\n        max_p_val: float,\n        value: float,\n        intercept: float = 0.0,\n    ):\n        swg.AddLinearScalingParameterizer_py(\n            self,\n            param_name,\n            state_name,\n            scaling_var_name,\n            intercept,\n            min_p_val,\n            max_p_val,\n            value,\n        )\n</code></pre>"},{"location":"classes/#swift2.classes.ScalingParameteriser.linear_parameteriser","title":"<code>linear_parameteriser(param_name, state_name, scaling_var_name, min_p_val, max_p_val, value, selector_type='subareas', intercept=0.0)</code>  <code>staticmethod</code>","text":"<p>Create a scaled linear parameteriser, tying by a linear transformation a (resp several) model state to a (resp several) parameter values</p> <p>This allows to define tied parameters where pval = a * modelStateVal + intercept. The intent in particular is to define virtual model parameters such as initial store value as a fraction of the maximum storage capacity.</p> <p>Args:</p> <pre><code>param_name (VecStr): the name of the meta-parameter. Note that it can be the same value as inner_param_name without interference, though this may be confusing a choice.\nstate_name (VecStr): the name of the model state to modify, based on the value of the meta-parameter and the state found in 'scalingVarName'\nscaling_var_name (VecStr): the name of the parameter for each subarea model, to which to apply the area scaled value.\nmin_p_val (VecNum): minimum value allowed for the meta-parameter\nmax_p_val (VecNum): minimum value allowed for the meta-parameter\nvalue (VecNum): value for the meta parameter.\nselector_type (str, optional): an identifier to define to which catchment element(s) the parameteriser will be applied. Defaults to \"subareas\".\nintercept (VecNum, optional): [description]. Defaults to 0.0.\n</code></pre> <p>Returns:</p> Name Type Description <code>ScalingParameteriser</code> <p>new ScalingParameteriser</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>@staticmethod\ndef linear_parameteriser(\n    param_name: \"VecStr\",\n    state_name: \"VecStr\",\n    scaling_var_name: \"VecStr\",\n    min_p_val: \"VecNum\",\n    max_p_val: \"VecNum\",\n    value: \"VecNum\",\n    selector_type: str = \"subareas\",\n    intercept: \"VecNum\" = 0.0,\n):\n    \"\"\"Create a scaled linear parameteriser, tying by a linear transformation a (resp several) model state to a (resp several) parameter values\n\n    This allows to define tied parameters where pval = a * modelStateVal + intercept.\n    The intent in particular is to define virtual model parameters such as initial store value as a fraction of the maximum storage capacity.\n\n    Args:\n\n        param_name (VecStr): the name of the meta-parameter. Note that it can be the same value as inner_param_name without interference, though this may be confusing a choice.\n        state_name (VecStr): the name of the model state to modify, based on the value of the meta-parameter and the state found in 'scalingVarName'\n        scaling_var_name (VecStr): the name of the parameter for each subarea model, to which to apply the area scaled value.\n        min_p_val (VecNum): minimum value allowed for the meta-parameter\n        max_p_val (VecNum): minimum value allowed for the meta-parameter\n        value (VecNum): value for the meta parameter.\n        selector_type (str, optional): an identifier to define to which catchment element(s) the parameteriser will be applied. Defaults to \"subareas\".\n        intercept (VecNum, optional): [description]. Defaults to 0.0.\n\n    Returns:\n        ScalingParameteriser: new ScalingParameteriser\n    \"\"\"\n    return sp.linear_parameteriser(\n        param_name,\n        state_name,\n        scaling_var_name,\n        min_p_val,\n        max_p_val,\n        value,\n        selector_type,\n        intercept,\n    )\n</code></pre>"},{"location":"classes/#swift2.classes.ScalingParameteriser.linear_parameteriser_from","title":"<code>linear_parameteriser_from(data_frame, selector_type='subareas')</code>  <code>staticmethod</code>","text":"<p>Create a scaled linear parameteriser, tying by a linear transformation a (resp several) model state to a (resp several) parameter values This allows to define tied parameters where pval = a * modelStateVal + intercept. The intent in particular is to define virtual model parameters such as initial store value as a fraction of the maximum storage capacity.</p> <p>Parameters:</p> Name Type Description Default <code>data_frame</code> <code>DataFrame</code> <p>data frame with columns \"param_name\", \"state_name\", \"scaling_var_name\", \"min_value\", \"max_value\", \"value\", \"intercept\",</p> required <code>selector_type</code> <code>str</code> <p>[description]. Defaults to \"subareas\".</p> <code>'subareas'</code> <p>Returns:</p> Name Type Description <code>ScalingParameteriser</code> <p>ScalingParameteriser</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>@staticmethod\ndef linear_parameteriser_from(\n    data_frame: pd.DataFrame, selector_type: str = \"subareas\"\n):\n    \"\"\"Create a scaled linear parameteriser, tying by a linear transformation a (resp several) model state to a (resp several) parameter values\n    This allows to define tied parameters where pval = a * modelStateVal + intercept. The intent in particular is to define virtual model parameters such as initial store value as a fraction of the maximum storage capacity.\n\n    Args:\n        data_frame (pd.DataFrame): data frame with columns \"param_name\", \"state_name\", \"scaling_var_name\", \"min_value\", \"max_value\", \"value\", \"intercept\",\n        selector_type (str, optional): [description]. Defaults to \"subareas\".\n\n    Returns:\n        ScalingParameteriser: ScalingParameteriser\n    \"\"\"\n    return sp.linear_parameteriser_from(data_frame, selector_type)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation","title":"<code>Simulation</code>","text":"<p>               Bases: <code>DeletableCffiNativeHandle</code>, <code>SimulationMixin</code></p> <p>Wrapper around single dimension simulation objects</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>class Simulation(DeletableCffiNativeHandle, SimulationMixin):\n    \"\"\"Wrapper around single dimension simulation objects\"\"\"\n\n    def __init__(\n        self,\n        handle: CffiData,\n        release_native: Callable[[CffiData], None],\n        type_id: Optional[str] = None,\n        prior_ref_count: int = 0,\n    ):\n        super(Simulation, self).__init__(\n            handle, release_native, type_id, prior_ref_count\n        )\n\n    @staticmethod\n    def from_json_file(file_path:str) -&gt; \"Simulation\":\n        \"\"\"Create a model simulation from a file with a JSON serialisation.\n\n        Args:\n            file_path (str): valid file path.\n\n        Returns:\n            Simulation: a catchment simulation.\n        \"\"\"\n        return smd.model_from_json_file(file_path)\n\n    def to_json_file(self, file_path:str) -&gt; None:\n        \"\"\"Save a model simulation from a file with a JSON serialisation.\n\n        Args:\n            file_path (str): file path to save to\n        \"\"\"\n        smd.model_to_json_file(self, file_path)\n\n    def clone(self) -&gt; \"Simulation\":\n        \"\"\"Clone this simulation (deep copy)\n\n        Returns:\n            Simulation: A new simulation object\n        \"\"\"\n        return swg.CloneModel_py(self)\n\n    def __str__(self):\n        \"\"\"string representation\"\"\"\n        tid = self.type_id if self.type_id is not None else \"\"\n        return f'Simulation wrapper for a CFFI pointer handle to a native pointer of type id \"{tid}\"'\n\n    def get_simulation_span(self) -&gt; Dict[str, Any]:\n        \"\"\"Gets the simulation span of this simulation\n\n        Returns:\n            Dict[str,Any]: information on start, end, time step\n        \"\"\"\n        return swc.get_simulation_span_pkg(self)\n\n    def set_simulation_span(\n        self, start: ConvertibleToTimestamp, end: ConvertibleToTimestamp\n    ) -&gt; None:\n        \"\"\"\n        Sets the simulation span\n\n        Args:\n            start (ConvertibleToTimestamp): the start date of the simulation. The time zone will be forced to UTC.\n            end (ConvertibleToTimestamp): the end date of the simulation. The time zone will be forced to UTC.\n        \"\"\"\n        ss.set_simulation_span(self, start, end)\n\n    def set_simulation_time_step(self, name: str) -&gt; None:\n        \"\"\"\n        Sets the time step of this simulation\n\n        Args:\n            name (str): a time step identifier, currently 'daily' or 'hourly' are supported. The identifier is made lower case in the function.\n        \"\"\"\n        ss.set_simulation_time_step(self, name)\n\n    def check_simulation(self) -&gt; Dict:\n        \"\"\"\n        Checks whether a simulation is configured to a state where it is executable\n        \"\"\"\n        return ss.check_simulation(self)\n\n    def swap_model(self, model_id: str, what: str = \"runoff\") -&gt; \"Simulation\":\n        \"\"\"\n        Clone and change a simulation, using another model\n\n        Args:\n            model_id (str): the identifier of the new model to use, e.g. 'GR4J'\n            what (str): character identifying the type of structure replaced: 'runoff', 'channel_routing'\n\n        Returns:\n            Simulation: A SWIFT simulation object, clone of the simulation but with a new model type in use.\n\n        \"\"\"\n        return ss.swap_model(self, model_id, what)\n\n    def set_error_correction_model(\n        self, model_id: str, element_id: str, length: int = 1, seed: int = 0\n    ) -&gt; None:\n        \"\"\"\n        Add an error correction model to an element in a catchment\n\n        Args:\n            model_id (str): the identifier of the new model to use, e.g. 'ERRIS'\n            element_id (str): the identifier of the catchment element (node, link, subcatchment) whose outflow rate is corrected.\n            length (int): other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.\n            seed (int): other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.\n\n        \"\"\"\n        ss.set_error_correction_model(self, model_id, element_id, length, seed)\n\n    def sort_by_execution_order(\n        self, split_element_ids: Sequence[str], sorting_option: str = \"\"\n    ) -&gt; List[str]:\n        \"\"\"\n        Sort the specified element ids according to the execution order of the simulation\n\n        Args:\n            split_element_ids (Sequence[str]): a character vector with element identifiers such as 'node.n1', 'link.linkId_2'\n            sorting_option (str): a character - for future options. Ignored for now.\n\n        Returns:\n            List[str]: values in split_element_ids sorted by simulation execution order\n\n        \"\"\"\n        return ss.sort_by_execution_order(self, split_element_ids, sorting_option)\n\n    def get_link_names(self) -&gt; List[str]:\n        \"\"\"\n        Gets all the names of the links in the catchment\n        \"\"\"\n        return ss.get_link_names(self)\n\n    def get_node_names(self) -&gt; List[str]:\n        \"\"\"\n        Gets all the names of the nodes in the catchment\n        \"\"\"\n        return ss.get_node_names(self)\n\n    def get_subarea_names(self) -&gt; List[str]:\n        \"\"\"\n        Gets all the names of the subareas in the catchment\n        \"\"\"\n        return ss.get_subarea_names(self)\n\n    def get_link_ids(self) -&gt; List[str]:\n        \"\"\"\n        Gets all the identifiers of the links in the catchment\n        \"\"\"\n        return ss.get_link_ids(self)\n\n    def get_node_ids(self) -&gt; List[str]:\n        \"\"\"\n        Gets all the identifiers of the nodes in the catchment\n        \"\"\"\n        return ss.get_node_ids(self)\n\n    def get_subarea_ids(self) -&gt; List[str]:\n        \"\"\"\n        Gets all the identifiers of the subareas in the catchment\n        \"\"\"\n        return ss.get_subarea_ids(self)\n\n    def get_variable_ids(\n        self, element_id: Optional[str] = None, full_id: bool = True\n    ) -&gt; List[str]:\n        \"\"\"\n        Gets all the names of the variables of an element (link, node, subarea) within a catchment\n\n        Args:\n            element_id (Optional[str]): a character, identifier of the element within the catchment\n            full_id (bool): boolean, if TRUE return the full hierarchical identifier\n\n        \"\"\"\n        return ss.get_variable_ids(self, element_id, full_id)\n\n    def is_variable_id(self, var_id: \"VecStr\") -&gt; Union[Dict[str, bool], bool]:\n        \"\"\"Are one or more model state identifier(s) valid\n\n        Args:\n            var_id (VecStr): model identifier(s)\n\n        Returns:\n            Union[Dict[str, bool], bool]: whether the identifier(s) are valid. A dictionary is returned if the input is vectorised rather than scalar.\n        \"\"\"\n        return ss.is_variable_id(self, var_id)\n\n    def get_state_value(self, var_id: \"VecStr\") -&gt; Union[Dict[str, float], float]:\n        \"\"\"\n        Gets the value(s) of a model state(s)\n\n        Args:\n            var_id (VecStr): string or sequence of str, model variable state identifier(s)\n\n        Returns:\n            value(s) of the requested model states\n        \"\"\"\n        return ss.get_state_value(self, var_id)\n\n    def set_state_value(\n        self,\n        var_id: Union[str, Sequence[str]],\n        value: Union[float, int, bool, Sequence] = None,\n    ) -&gt; None:\n        \"\"\"\n        Sets the value of a model state\n\n        Args:\n            var_id (Any): character, model variable state identifier(s)\n            value (Any): numeric value(s)\n\n        \"\"\"\n        ss.set_state_value(self, var_id, value)\n\n    def snapshot_state(self) -&gt; \"MemoryStates\":\n        \"\"\"Take a snapshot of the memory states of a simulation\n\n        Returns:\n            MemoryStates: memory states, that can be stored and reapplied\n        \"\"\"\n        return ss.snapshot_state(self)\n\n    def set_states(self, states: \"MemoryStates\") -&gt; None:\n        \"\"\"Apply memory states to a simulation\n\n        Args:\n            states (MemoryStates): memory states\n        \"\"\"\n        ss.set_states(self, states)\n\n    def set_reservoir_model(self, new_model_id: str, element_id: str) -&gt; None:\n        \"\"\"Sets a new reservoir model on an element\n\n        Args:\n            new_model_id (str): Currently one of: \"ControlledReleaseReservoir\", \"LevelVolumeAreaReservoir\", \"FarmDamReservoir\";\n            element_id (str): _description_\n        \"\"\"\n        swg.SetReservoirModel_py(self, new_model_id, element_id)\n\n    def set_reservoir_geometry(\n        self, element_id: str, level: np.ndarray, storage: np.ndarray, area: np.ndarray\n    ) -&gt; None:\n        \"\"\"Sets the geometry of a reservoir\n\n        Args:\n            element_id (str): Element with a suitable reservoir supporting a geometry description\n            level (np.ndarray): array of water surface levels, in S.I. units (m) TO BE CONFIRMED\n            storage (np.ndarray): array of volume storages, in S.I. units (m3) TO BE CONFIRMED\n            area (np.ndarray): array of surfce areas, in S.I. units (m2) TO BE CONFIRMED\n        \"\"\"\n        num_entries = len(level)\n        assert len(storage) == num_entries\n        assert len(area) == num_entries\n        swg.SetReservoirGeometry_py(self, element_id, num_entries, level, storage, area)\n\n    def set_reservoir_min_discharge(\n        self, element_id: str, level: np.ndarray, discharge: np.ndarray\n    ) -&gt; None:\n        \"\"\"Sets a reservoir operating curve, minimum release for a given level\n\n        Args:\n            element_id (str): Element with a suitable reservoir supporting a geometry description\n            level (np.ndarray): array of levels (m)\n            discharge (np.ndarray): array of minimum discharges (m3/s)\n        \"\"\"\n        num_entries = len(level)\n        swg.SetReservoirMinDischarge_py(self, element_id, num_entries, level, discharge)\n\n    def set_reservoir_max_discharge(\n        self, element_id: str, level: np.ndarray, discharge: np.ndarray\n    ) -&gt; None:\n        \"\"\"Sets a reservoir operating curve, maximum release for a given level\n\n        Args:\n            element_id (str): Element with a suitable reservoir supporting a geometry description\n            level (np.ndarray): array of levels (m)\n            discharge (np.ndarray): array of maximum discharges (m3/s)\n        \"\"\"\n        num_entries = len(level)\n        swg.SetReservoirMaxDischarge_py(self, element_id, num_entries, level, discharge)\n\n    def use_state_initialises(self, state_initialiser: \"StateInitialiser\"):\n        \"\"\"Sets the state initialiser to use for a simulation. This forces the removal of any prior state initialiser.\n\n        Args:\n            state_initialiser (StateInitialiser): the new state initialiser to use\n        \"\"\"\n        swg.UseStateInitializerModelRunner_py(self, state_initialiser)\n\n    def remove_state_initialisers(self):\n        \"\"\"Forces the removal of any state initialiser.\"\"\"\n        swg.RemoveStateInitializerModelRunner_py(self)\n\n    def add_state_initialiser(self, state_initialiser: \"StateInitialiser\"):\n        \"\"\"Adds a state initialiser to any prior list of state initialisers\"\"\"\n        swg.AddStateInitializerModelRunner_py(self, state_initialiser)\n\n    def reset_model_states(self) -&gt; None:\n        \"\"\"Reset the model states of a simulation, and apply one or more state initialers if the simulation is configured with any.\"\"\"\n        ss.reset_model_states(self)\n\n    def describe(self, verbosity:Optional[int]=None) -&gt; Dict:\n        \"\"\"Describe the catchment model structure using simple python representations\n\n        Args:\n            verbosity (Optional[int], optional): Future option, unused for now. Defaults to None.\n\n        Returns:\n            Dict: A dictionary representation of the catchment structure\n        \"\"\"\n        return ss.describe(self, verbosity)\n\n    def create_ensemble_forecast_simulation(\n        self,\n        data_library,\n        start: ConvertibleToTimestamp,\n        end: ConvertibleToTimestamp,\n        input_map: Dict[str, List[str]],\n        lead_time: int,\n        ensemble_size: int,\n        n_time_steps_between_forecasts: int,\n    ) -&gt; \"EnsembleForecastSimulation\":\n        \"\"\"\n        Create an ensemble forecast simulation\n\n        Args:\n            data_library (Any): external pointer type ENSEMBLE_DATA_SET_PTR, or a Python class wrapper around it \n            start (ConvertibleToTimestamp): the start date of the simulation. The time zone will be forced to UTC.\n            end (ConvertibleToTimestamp): the end date of the simulation. The time zone will be forced to UTC.\n            input_map (dict): a named list were names are the data library data identifiers, and values are character vectors with model state identifiers.\n            lead_time (int): integer, the length in time steps of the forecasts.\n            ensemble_size (int): ensemble size\n            n_time_steps_between_forecasts (int): nTimeStepsBetweenForecasts\n\n        Returns:\n            An external pointer\n\n        \"\"\"\n        return ss.create_ensemble_forecast_simulation(\n            self,\n            data_library,\n            start,\n            end,\n            input_map,\n            lead_time,\n            ensemble_size,\n            n_time_steps_between_forecasts,\n        )\n\n    def ensemble_simulation(self, ensemble_size: int) -&gt; \"EnsembleSimulation\":\n        \"\"\"Create an ensemble simulation templated from this simulation\n\n        Args:\n            ensemble_size (int): The size of the ensemble dimension\n\n        Returns:\n            EnsembleSimulation: Ensemble simulation (ensemble simulation runner)\n        \"\"\"        \n        return swg.CreateEnsembleModelRunner_py(self, ensembleSize=ensemble_size)\n\n    def erris_ensemble_simulation(\n        self,\n        warmup_start: ConvertibleToTimestamp,\n        warmup_end: ConvertibleToTimestamp,\n        observed_ts: TimeSeriesLike,\n        error_model_element_id: str,\n    ) -&gt; \"EnsembleSimulation\":\n        \"\"\"Creates an ensemble simulation templated on this simulation, with an ERRIS model on one of the network element\n\n        Args:\n            warmup_start (ConvertibleToTimestamp): start time stamp for the warmup period\n            warmup_end (ConvertibleToTimestamp): end time stamp for the warmup period\n            observed_ts (TimeSeriesLike): Time series of observations to correct prediction against\n            error_model_element_id (str): model element identifier where to set up an ERRIS correction model\n\n        Returns:\n            EnsembleSimulation: Ensemble simulation (ensemble simulation runner)\n        \"\"\"\n        from cinterop.timeseries import as_pydatetime\n\n        from swift2.internal import to_interop_univariate_series\n        warmup_start = as_pydatetime(warmup_start)\n        warmup_end = as_pydatetime(warmup_end)\n        values, ts_geom = to_interop_univariate_series(observed_ts)\n        return swg.PrepareEnsembleModelRunner_py(\n            self, warmup_start, warmup_end, values, ts_geom, error_model_element_id\n        )\n\n    def play_inputs(\n        self,\n        data_library: uc.TimeSeriesLibrary,\n        model_var_id: \"VecStr\",\n        data_id: \"VecStr\",\n        resample: \"VecStr\" = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Assign input time series from a time series library to a model simulation\n\n        Args:\n            data_library (TimeSeriesLibrary): external pointer type ENSEMBLE_DATA_SET_PTR, or a Python class wrapper around it \n            model_var_id (str or sequence of str): model state variable unique identifier(s)\n            data_id (str or sequence of str): identifier(s) for data in the data_library. If length is not the same as model_var_id, the elements of data_id are reused to match it\n            resample (str or sequence of str): identifier(s) for how the series is resampled (aggregated or disaggregated). If length is not the same as model_var_id, the elements of resample are reused to match it\n\n        \"\"\"\n        spr.play_inputs(self, data_library, model_var_id, data_id, resample)\n\n    def play_subarea_input(\n        self, input: TimeSeriesLike, subarea_name: str, input_name: str\n    ) -&gt; None:\n        \"\"\"\n        Sets time series as input to a simulation\n\n        Args:\n            input (TimeSeriesLike): univariate time series.\n            subarea_name (str): a valid name of the subarea\n            input_name (str): the name of the input variable to the model (i.e. 'P' for the precip of GR5H)\n\n        \"\"\"\n        spr.play_subarea_input(self, input, subarea_name, input_name)\n\n    def play_input(\n        self, input_ts: TimeSeriesLike, var_ids: Optional[\"VecStr\"] = None\n    ) -&gt; None:\n        \"\"\"\n        Sets one or more time series as input(s) to a simulation\n\n        Args:\n            input_ts (TimeSeriesLike): univariate time series. If an xts time series column names must be valid model variable identifiers, unless explicitely provided via varIds\n            var_ids (optional str or sequence of str): optional character, the variable identifiers to use, overriding the column names of the inputTs. If not NULL, must be of length equal to the number of columns in inputTs\n        \"\"\"\n        spr.play_singular_simulation(self, input_ts, var_ids)\n\n    def get_played(\n        self,\n        var_ids: Optional[\"VecStr\"] = None,\n        start_time: Optional[ConvertibleToTimestamp] = None,\n        end_time: Optional[ConvertibleToTimestamp] = None,\n    ) -&gt; xr.DataArray:\n        \"\"\"\n        Retrieves one or more played (input) time series from a simulation\n\n        Args:\n            var_ids (optional str or sequence of str): name(s) of the model variable(s) into which a time series is played as input. e.g. 'Catchment.StreamflowRate'. If missing, a multivariate time series of all played states is returned; this may be a large amount of data.\n            start_time (datetime like): An optional parameter, the start of a period to subset the time series\n            end_time (datetime like): An optional parameter, the end of a period to subset the time series\n\n        Returns:\n            xr.DataArray: a time series, possibly multivariate.\n\n        \"\"\"\n        return spr.get_played(self, var_ids, start_time, end_time)\n\n    def get_played_varnames(self) -&gt; List[str]:\n        \"\"\"\n        Gets all the names of model states fed an input time series\n        \"\"\"\n        return spr.get_played_varnames(self)\n\n    def get_recorded(\n        self,\n        var_ids: Optional[\"VecStr\"] = None,\n        start_time: Optional[ConvertibleToTimestamp] = None,\n        end_time: Optional[ConvertibleToTimestamp] = None,\n    ) -&gt; xr.DataArray:\n        \"\"\"\n        Retrieves a recorded time series from a simulation\n\n        Args:\n            var_ids (optional str or sequence of str): name(s) of the model variable(s) recorded to a time series. e.g. 'Catchment.StreamflowRate'. If missing, a multivariate time series of all played states is returned; this may be a large amount of data.\n            start_time (datetime like): An optional parameter, the start of a period to subset the time series\n            end_time (datetime like): An optional parameter, the end of a period to subset the time series\n\n        Returns:\n            xr.DataArray: a time series, possibly multivariate.\n\n        \"\"\"\n        return spr.get_recorded(self, var_ids, start_time, end_time)\n\n    def get_all_recorded(self) -&gt; xr.DataArray:\n        \"\"\"Gets all the time series of models variables recorded from\"\"\"\n        return spr.get_all_recorded(self)\n\n    def get_all_played(self) -&gt; xr.DataArray:\n        \"\"\"Gets all the time series of models variables into which input time sereis is/are played\"\"\"\n        return spr.get_all_played(self)\n\n    def apply_recording_function(\n        self,\n        recording_func: Optional[\"RecordToSignature\"],\n        var_ids: \"VecStr\",\n        recording_provider,\n        data_ids: \"VecStr\",\n    ) -&gt; None:\n        \"\"\"DRAFT Advanced/technical. Record states to a record provider using a callable function. \n\n        Likely not for end users. This is used by methods such as \n        [`EnsembleSimulation.record_ensemble_state`][swift2.classes.EnsembleSimulation.record_ensemble_state].\n\n        \"\"\"\n        spr.apply_recording_function(\n            self, recording_func, var_ids, recording_provider, data_ids\n        )\n\n    def record_singular_state(\n        self,\n        var_ids: \"VecStr\" = CATCHMENT_FLOWRATE_VARID,\n        recording_provider: Optional[\"TimeSeriesLibrary\"] = None,\n        data_ids: Optional[\"VecStr\"] = None,\n    ) -&gt; None:\n        \"\"\"DRAFT Advanced/technical. Record states to a record provider. \n\n        Likely not for end users.\n        \"\"\"\n        spr.record_singular_state(self, var_ids, recording_provider, data_ids)\n\n    def cookie_cut_dendritic_catchment(\n        self, bottom_element_id: str, top_element_ids: \"VecStr\"\n    ):\n        \"\"\"cookie cut a dendritic catchment (without confluences)\n\n        Args:\n            bottom_element_id (str): identifier of the most downstream element to keep\n            top_element_ids (str): identifier(s) of the most upstream element(s) to keep\n\n        Returns:\n            Simulation: a subcatchment simulation, cookie cut from the base simulation. Deep clone of objects.\n        \"\"\"\n        return smd.cookie_cut_dendritic_catchment(\n            self, bottom_element_id, top_element_ids\n        )\n\n    def subset_catchment(self, element_id: str, action: str = \"keep_above\"):\n        \"\"\"Subsets a catchment, keeping only a portion above or below a node, link or subarea.\n\n        Args:\n            element_id (str): id of the element to cut at.\n            action (str): how to cut; currently limited to 'keep_above'\n\n        Returns:\n            Simulation: a subcatchment simulation, cookie cut from the base simulation. Deep clone of objects.\n        \"\"\"\n        return smd.subset_catchment(self, element_id, action)\n\n    def split_to_subcatchments(\n        self, split_element_ids: Sequence[str], include_upstream: Sequence[bool] = None\n    ) -&gt; OrderedDict[str, \"Simulation\"]:\n        \"\"\"Split a catchment in subcatchments, given a list of node/link element identifiers\n\n        Args:\n            split_element_ids (str): element identifiers such as 'node.n1', 'link.linkId_2'\n            include_upstream (bool, optional): indicates whether for each element in split_element_ids it should be including in the upstream portion of the subcatchment. Defaults to None.\n\n        Returns:\n            OrderedDict: list of subcatchments resulting from the split\n\n        Examples:\n            &gt;&gt;&gt; _, simulation = sdh.create_test_catchment_structure()\n            &gt;&gt;&gt; e_ids = ['node.n2', 'node.n4']\n            &gt;&gt;&gt; sub_sims = simulation.split_to_subcatchments(e_ids)\n            &gt;&gt;&gt; for k in sub_sims:\n            &gt;&gt;&gt;     print(k)\n            &gt;&gt;&gt;     print(sub_sims[k].get_node_ids())\n            &gt;&gt;&gt;     print(sub_sims[k].get_node_names())\n            node.n4\n            ['n4', 'n3', 'n1']\n            ['n4_name', 'n3_name', 'n1_name']\n            node.n2\n            ['n2', 'n5']\n            ['n2_name', 'n5_name']\n            remainder\n            ['n6']\n            ['n6_name']\n        \"\"\"\n        return smd.split_to_subcatchments(self, split_element_ids, include_upstream)\n\n    def get_catchment_structure(self) -&gt; Dict[str, Any]:\n        \"\"\"Gets the essential connective structure of a catchment\n\n        Args:\n            simulation (Simulation): base catchment simulation\n\n        Returns:\n            Dict[str, Any]: A nested dictionary describing the catchment connectivity of subareas, links, and nodes\n\n        Examples:\n            &gt;&gt;&gt; _, simulation = sdh.create_test_catchment_structure()\n            &gt;&gt;&gt; simulation.get_catchment_structure()\n            {'Node':    Id     Name\n            0  n1  n1_name\n            1  n2  n2_name\n            2  n3  n3_name\n            3  n4  n4_name\n            4  n5  n5_name\n            5  n6  n6_name, 'Link':      Id       Name  LengthMetres    f  ManningsN  Slope\n            0  lnk1  lnk1_name           0.0  0.0        0.0    0.0\n            1  lnk2  lnk2_name           0.0  0.0        0.0    0.0\n            2  lnk3  lnk3_name           0.0  0.0        0.0    0.0\n            3  lnk4  lnk4_name           0.0  0.0        0.0    0.0\n            4  lnk5  lnk5_name           0.0  0.0        0.0    0.0, 'Subarea':      Id       Name  AreaKm2\n            0  lnk1  lnk1_name      1.1\n            1  lnk2  lnk2_name      2.2\n            2  lnk3  lnk3_name      3.3\n            3  lnk4  lnk4_name      4.4\n            4  lnk5  lnk5_name      5.5, 'NodeLink':   DownstreamId UpstreamId LinkId\n            0           n6         n2   lnk1\n            1           n2         n5   lnk2\n            2           n2         n4   lnk3\n            3           n4         n3   lnk4\n            4           n4         n1   lnk5, 'SubareaLink':   LinkId SubareaId\n            0   lnk1      lnk1\n            1   lnk2      lnk2\n            2   lnk3      lnk3\n            3   lnk4      lnk4\n        \"\"\"\n        return smd.get_catchment_structure(self)\n\n    def create_multisite_objective(\n        self,\n        statspec: pd.DataFrame,\n        observations: Sequence[TimeSeriesLike],\n        weights: Dict[str, float],\n    ) -&gt; \"ObjectiveEvaluator\":\n        \"\"\"\n        Creates an objective that combines multiple statistics. Used for joined, \"whole of catchment\" calibration\n\n        Args:\n            statspec (pd.DataFrame): dataframe defining the objectives used. See function [`multi_statistic_definition`][swift2.statistics.multi_statistic_definition] to help build this dataframe.\n            observations (Sequence[TimeSeriesLike]): A list of (time series) observations to calculated the statistics. Must be of same length as the number of rows of statspec.\n            weights (Dict[str, float]): numeric vector of weights to ponderate each objective.\n\n        Returns:\n            ObjectiveEvaluator: an objective evaluator\n\n        Examples:\n            &gt;&gt;&gt; _, ms = sdh.create_test_catchment_structure()\n            &gt;&gt;&gt; from swift2.utils import mk_full_data_id\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; nodeids = ['node.n2', 'node.n4']\n            &gt;&gt;&gt; mvids = mk_full_data_id(nodeids, 'OutflowRate')\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; sdh.configure_test_simulation(\n            ...     ms,\n            ...     data_id='MMH',\n            ...     simul_start='1990-01-01',\n            ...     simul_end='2005-12-31',\n            ...     tstep='daily',\n            ...     varname_rain='P',\n            ...     varname_pet='E',\n            ...     varname_data_rain='rain',\n            ...     varname_data_pet='evap',\n            ... )\n            &gt;&gt;&gt; \n\n            &gt;&gt;&gt; ms.record_state(mvids)\n            &gt;&gt;&gt; ms.exec_simulation()\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; modFlows = ms.get_recorded()\n            &gt;&gt;&gt; \n\n            &gt;&gt;&gt; w = dict(zip(mvids, [1.0, 2.0]))\n            &gt;&gt;&gt; w\n            {'node.n2.OutflowRate': 1.0, 'node.n4.OutflowRate': 2.0}\n            &gt;&gt;&gt; span = ms.get_simulation_span()\n            &gt;&gt;&gt; \n\n            &gt;&gt;&gt; from swift2.utils import rep\n            &gt;&gt;&gt; statspec = sst.multi_statistic_definition(mvids, rep('nse', 2), mvids, mvids, rep(span['start'], 2), rep(span['end'], 2) )\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; statspec\n                        ModelVarId StatisticId          ObjectiveId        ObjectiveName      Start        End\n            0  node.n2.OutflowRate         nse  node.n2.OutflowRate  node.n2.OutflowRate 1990-01-01 2005-12-31\n            1  node.n4.OutflowRate         nse  node.n4.OutflowRate  node.n4.OutflowRate 1990-01-01 2005-12-31\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; # Create synthetic observations\n            &gt;&gt;&gt; observations = [\n            ...     modFlows.sel(variable_identifiers=mvids[0]) * 0.33,\n            ...     modFlows.sel(variable_identifiers=mvids[1]) * 0.77\n            ... ]\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; obj = ms.create_multisite_objective(statspec, observations, w)\n            &gt;&gt;&gt; \n\n            &gt;&gt;&gt; dummy = sp.create_parameteriser()\n            &gt;&gt;&gt; obj.get_scores(dummy)\n            {'node.n2.OutflowRate': -4.152338377267432, 'node.n4.OutflowRate': 0.8884789439301954}\n            &gt;&gt;&gt; \n\n            &gt;&gt;&gt; obj.get_score(dummy)\n            {'scores': {'MultisiteObjectives': 0.7917934964690136}, 'sysconfig': Empty DataFrame\n            Columns: [Name, Value, Min, Max]\n            Index: []}\n            &gt;&gt;&gt; \n        \"\"\"\n        return ssf.create_multisite_objective(self, statspec, observations, weights)\n\n    def create_objective(\n        self,\n        state_name: str,\n        observation: TimeSeriesLike,\n        statistic: str,\n        start_date: ConvertibleToTimestamp,\n        end_date: ConvertibleToTimestamp,\n    ) -&gt; \"ObjectiveEvaluator\":\n        \"\"\"\n        Creates an objective calculator\n\n        Args:\n            state_name (str): The name identifying the model state variable to calibrate against the observation\n            observation (TimeSeriesLike): an xts\n            statistic (str): statistic identifier, e.g. \"NSE\"\n            start_date (ConvertibleToTimestamp): start date of the period to calculate statistics on\n            end_date (ConvertibleToTimestamp): end date of the period to calculate statistics on\n\n        Returns:\n            ObjectiveEvaluator: single objective evaluator\n        \"\"\"\n        return ssf.create_objective(\n            self, state_name, observation, statistic, start_date, end_date\n        )\n\n    def muskingum_param_constraints(\n        self,\n        inner_parameters: \"HypercubeParameteriser\",\n        delta_t: float = 1.0,\n        param_name_k: str = \"K\",\n        param_name_x: str = \"X\",\n    ) -&gt; \"ConstraintParameteriser\":\n        \"\"\"Create a parameteriser with Muskingum-type constraints. \n\n        Given an existing parameteriser, create a wrapper that adds constraints on two of its parameters.\n\n        Args:\n            inner_parameters (HypercubeParameteriser): A SWIFT parameteriser object that contains two Muskingum-type attenuation  and delay parameters.\n            delta_t (int, optional): the simulation time step in HOURS. Defaults to 1.\n            param_name_k (str, optional): the variable identifier to use for the delay parameter of the Muskingum routing. Defaults to \"K\".\n            param_name_x (str, optional): the variable identifier to use for the attenuation parameter of the Muskingum routing. Defaults to \"X\".\n\n        Returns:\n            ConstraintParameteriser: A parameteriser with constraints on the feasibility of the attenuation / delay parameters\n\n        Examples:\n           &gt;&gt;&gt; todo()\n        \"\"\"\n        return sp.create_muskingum_param_constraints(\n            inner_parameters, delta_t, param_name_k, param_name_x, self\n        )\n\n    def prepare_erris_forecasting(\n        self,\n        observation: TimeSeriesLike,\n        error_model_element_id: str,\n        warmup_start: ConvertibleToTimestamp,\n        warmup_end: ConvertibleToTimestamp,\n    ) -&gt; 'EnsembleSimulation':\n        \"\"\"Create an ensemble simulation for forecasting with ERRIS\n\n        Args:\n            observation (TimeSeriesLike): Time series of observations to correct prediction against\n            error_model_element_id (str): model element identifier where to set up an ERRIS correction model\n            warmup_start (ConvertibleToTimestamp): start time stamp for the warmup period\n            warmup_end (ConvertibleToTimestamp): end time stamp for the warmup period\n\n        Returns:\n            EnsembleSimulation: Ensemble simulation (ensemble simulation runner)\n        \"\"\"\n        from swift2.internal import to_interop_univariate_series\n\n        values, ts_geom = to_interop_univariate_series(\n            observation, warmup_start, warmup_end\n        )\n        return swg.PrepareERRISForecasting_py(\n            self, values, ts_geom, error_model_element_id, warmup_start, warmup_end\n        )\n\n    def prepare_dual_pass_forecasting(\n        self,\n        observation: TimeSeriesLike,\n        error_model_element_id: str,\n        warmup_start: ConvertibleToTimestamp,\n        warmup_end: ConvertibleToTimestamp,\n        required_windows_percentage: float,\n    ) -&gt; 'EnsembleSimulation':\n        \"\"\"Create an ensemble simulation for forecasting with the Dual Pass error correction method \n\n        Args:\n            observation (TimeSeriesLike): Time series of observations to correct prediction against\n            error_model_element_id (str): model element identifier where to set up an ERRIS correction model\n            warmup_start (ConvertibleToTimestamp): start time stamp for the warmup period\n            warmup_end (ConvertibleToTimestamp): end time stamp for the warmup period\n            required_windows_percentage (float): required_windows_percentage\n\n        Returns:\n            EnsembleSimulation: Ensemble simulation (ensemble simulation runner)\n        \"\"\"    \n        from swift2.internal import to_interop_univariate_series\n\n        values, ts_geom = to_interop_univariate_series(\n            observation, warmup_start, warmup_end\n        )\n        return swg.PrepareDualPassForecasting_py(\n            self,\n            values,\n            ts_geom,\n            error_model_element_id,\n            warmup_start,\n            warmup_end,\n            required_windows_percentage,\n        )\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.__str__","title":"<code>__str__()</code>","text":"<p>string representation</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def __str__(self):\n    \"\"\"string representation\"\"\"\n    tid = self.type_id if self.type_id is not None else \"\"\n    return f'Simulation wrapper for a CFFI pointer handle to a native pointer of type id \"{tid}\"'\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.add_state_initialiser","title":"<code>add_state_initialiser(state_initialiser)</code>","text":"<p>Adds a state initialiser to any prior list of state initialisers</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def add_state_initialiser(self, state_initialiser: \"StateInitialiser\"):\n    \"\"\"Adds a state initialiser to any prior list of state initialisers\"\"\"\n    swg.AddStateInitializerModelRunner_py(self, state_initialiser)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.apply_recording_function","title":"<code>apply_recording_function(recording_func, var_ids, recording_provider, data_ids)</code>","text":"<p>DRAFT Advanced/technical. Record states to a record provider using a callable function. </p> <p>Likely not for end users. This is used by methods such as  <code>EnsembleSimulation.record_ensemble_state</code>.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def apply_recording_function(\n    self,\n    recording_func: Optional[\"RecordToSignature\"],\n    var_ids: \"VecStr\",\n    recording_provider,\n    data_ids: \"VecStr\",\n) -&gt; None:\n    \"\"\"DRAFT Advanced/technical. Record states to a record provider using a callable function. \n\n    Likely not for end users. This is used by methods such as \n    [`EnsembleSimulation.record_ensemble_state`][swift2.classes.EnsembleSimulation.record_ensemble_state].\n\n    \"\"\"\n    spr.apply_recording_function(\n        self, recording_func, var_ids, recording_provider, data_ids\n    )\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.check_simulation","title":"<code>check_simulation()</code>","text":"<p>Checks whether a simulation is configured to a state where it is executable</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def check_simulation(self) -&gt; Dict:\n    \"\"\"\n    Checks whether a simulation is configured to a state where it is executable\n    \"\"\"\n    return ss.check_simulation(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.clone","title":"<code>clone()</code>","text":"<p>Clone this simulation (deep copy)</p> <p>Returns:</p> Name Type Description <code>Simulation</code> <code>Simulation</code> <p>A new simulation object</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def clone(self) -&gt; \"Simulation\":\n    \"\"\"Clone this simulation (deep copy)\n\n    Returns:\n        Simulation: A new simulation object\n    \"\"\"\n    return swg.CloneModel_py(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.cookie_cut_dendritic_catchment","title":"<code>cookie_cut_dendritic_catchment(bottom_element_id, top_element_ids)</code>","text":"<p>cookie cut a dendritic catchment (without confluences)</p> <p>Parameters:</p> Name Type Description Default <code>bottom_element_id</code> <code>str</code> <p>identifier of the most downstream element to keep</p> required <code>top_element_ids</code> <code>str</code> <p>identifier(s) of the most upstream element(s) to keep</p> required <p>Returns:</p> Name Type Description <code>Simulation</code> <p>a subcatchment simulation, cookie cut from the base simulation. Deep clone of objects.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def cookie_cut_dendritic_catchment(\n    self, bottom_element_id: str, top_element_ids: \"VecStr\"\n):\n    \"\"\"cookie cut a dendritic catchment (without confluences)\n\n    Args:\n        bottom_element_id (str): identifier of the most downstream element to keep\n        top_element_ids (str): identifier(s) of the most upstream element(s) to keep\n\n    Returns:\n        Simulation: a subcatchment simulation, cookie cut from the base simulation. Deep clone of objects.\n    \"\"\"\n    return smd.cookie_cut_dendritic_catchment(\n        self, bottom_element_id, top_element_ids\n    )\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.create_ensemble_forecast_simulation","title":"<code>create_ensemble_forecast_simulation(data_library, start, end, input_map, lead_time, ensemble_size, n_time_steps_between_forecasts)</code>","text":"<p>Create an ensemble forecast simulation</p> <p>Parameters:</p> Name Type Description Default <code>data_library</code> <code>Any</code> <p>external pointer type ENSEMBLE_DATA_SET_PTR, or a Python class wrapper around it </p> required <code>start</code> <code>ConvertibleToTimestamp</code> <p>the start date of the simulation. The time zone will be forced to UTC.</p> required <code>end</code> <code>ConvertibleToTimestamp</code> <p>the end date of the simulation. The time zone will be forced to UTC.</p> required <code>input_map</code> <code>dict</code> <p>a named list were names are the data library data identifiers, and values are character vectors with model state identifiers.</p> required <code>lead_time</code> <code>int</code> <p>integer, the length in time steps of the forecasts.</p> required <code>ensemble_size</code> <code>int</code> <p>ensemble size</p> required <code>n_time_steps_between_forecasts</code> <code>int</code> <p>nTimeStepsBetweenForecasts</p> required <p>Returns:</p> Type Description <code>EnsembleForecastSimulation</code> <p>An external pointer</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def create_ensemble_forecast_simulation(\n    self,\n    data_library,\n    start: ConvertibleToTimestamp,\n    end: ConvertibleToTimestamp,\n    input_map: Dict[str, List[str]],\n    lead_time: int,\n    ensemble_size: int,\n    n_time_steps_between_forecasts: int,\n) -&gt; \"EnsembleForecastSimulation\":\n    \"\"\"\n    Create an ensemble forecast simulation\n\n    Args:\n        data_library (Any): external pointer type ENSEMBLE_DATA_SET_PTR, or a Python class wrapper around it \n        start (ConvertibleToTimestamp): the start date of the simulation. The time zone will be forced to UTC.\n        end (ConvertibleToTimestamp): the end date of the simulation. The time zone will be forced to UTC.\n        input_map (dict): a named list were names are the data library data identifiers, and values are character vectors with model state identifiers.\n        lead_time (int): integer, the length in time steps of the forecasts.\n        ensemble_size (int): ensemble size\n        n_time_steps_between_forecasts (int): nTimeStepsBetweenForecasts\n\n    Returns:\n        An external pointer\n\n    \"\"\"\n    return ss.create_ensemble_forecast_simulation(\n        self,\n        data_library,\n        start,\n        end,\n        input_map,\n        lead_time,\n        ensemble_size,\n        n_time_steps_between_forecasts,\n    )\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.create_multisite_objective","title":"<code>create_multisite_objective(statspec, observations, weights)</code>","text":"<p>Creates an objective that combines multiple statistics. Used for joined, \"whole of catchment\" calibration</p> <p>Parameters:</p> Name Type Description Default <code>statspec</code> <code>DataFrame</code> <p>dataframe defining the objectives used. See function <code>multi_statistic_definition</code> to help build this dataframe.</p> required <code>observations</code> <code>Sequence[TimeSeriesLike]</code> <p>A list of (time series) observations to calculated the statistics. Must be of same length as the number of rows of statspec.</p> required <code>weights</code> <code>Dict[str, float]</code> <p>numeric vector of weights to ponderate each objective.</p> required <p>Returns:</p> Name Type Description <code>ObjectiveEvaluator</code> <code>ObjectiveEvaluator</code> <p>an objective evaluator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; _, ms = sdh.create_test_catchment_structure()\n&gt;&gt;&gt; from swift2.utils import mk_full_data_id\n&gt;&gt;&gt; \n&gt;&gt;&gt; nodeids = ['node.n2', 'node.n4']\n&gt;&gt;&gt; mvids = mk_full_data_id(nodeids, 'OutflowRate')\n&gt;&gt;&gt; \n&gt;&gt;&gt; sdh.configure_test_simulation(\n...     ms,\n...     data_id='MMH',\n...     simul_start='1990-01-01',\n...     simul_end='2005-12-31',\n...     tstep='daily',\n...     varname_rain='P',\n...     varname_pet='E',\n...     varname_data_rain='rain',\n...     varname_data_pet='evap',\n... )\n&gt;&gt;&gt; \n</code></pre> <pre><code>&gt;&gt;&gt; ms.record_state(mvids)\n&gt;&gt;&gt; ms.exec_simulation()\n&gt;&gt;&gt; \n&gt;&gt;&gt; modFlows = ms.get_recorded()\n&gt;&gt;&gt; \n</code></pre> <pre><code>&gt;&gt;&gt; w = dict(zip(mvids, [1.0, 2.0]))\n&gt;&gt;&gt; w\n{'node.n2.OutflowRate': 1.0, 'node.n4.OutflowRate': 2.0}\n&gt;&gt;&gt; span = ms.get_simulation_span()\n&gt;&gt;&gt; \n</code></pre> <pre><code>&gt;&gt;&gt; from swift2.utils import rep\n&gt;&gt;&gt; statspec = sst.multi_statistic_definition(mvids, rep('nse', 2), mvids, mvids, rep(span['start'], 2), rep(span['end'], 2) )\n&gt;&gt;&gt; \n&gt;&gt;&gt; statspec\n            ModelVarId StatisticId          ObjectiveId        ObjectiveName      Start        End\n0  node.n2.OutflowRate         nse  node.n2.OutflowRate  node.n2.OutflowRate 1990-01-01 2005-12-31\n1  node.n4.OutflowRate         nse  node.n4.OutflowRate  node.n4.OutflowRate 1990-01-01 2005-12-31\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Create synthetic observations\n&gt;&gt;&gt; observations = [\n...     modFlows.sel(variable_identifiers=mvids[0]) * 0.33,\n...     modFlows.sel(variable_identifiers=mvids[1]) * 0.77\n... ]\n&gt;&gt;&gt; \n&gt;&gt;&gt; obj = ms.create_multisite_objective(statspec, observations, w)\n&gt;&gt;&gt; \n</code></pre> <pre><code>&gt;&gt;&gt; dummy = sp.create_parameteriser()\n&gt;&gt;&gt; obj.get_scores(dummy)\n{'node.n2.OutflowRate': -4.152338377267432, 'node.n4.OutflowRate': 0.8884789439301954}\n&gt;&gt;&gt; \n</code></pre> <pre><code>&gt;&gt;&gt; obj.get_score(dummy)\n{'scores': {'MultisiteObjectives': 0.7917934964690136}, 'sysconfig': Empty DataFrame\nColumns: [Name, Value, Min, Max]\nIndex: []}\n&gt;&gt;&gt;\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def create_multisite_objective(\n    self,\n    statspec: pd.DataFrame,\n    observations: Sequence[TimeSeriesLike],\n    weights: Dict[str, float],\n) -&gt; \"ObjectiveEvaluator\":\n    \"\"\"\n    Creates an objective that combines multiple statistics. Used for joined, \"whole of catchment\" calibration\n\n    Args:\n        statspec (pd.DataFrame): dataframe defining the objectives used. See function [`multi_statistic_definition`][swift2.statistics.multi_statistic_definition] to help build this dataframe.\n        observations (Sequence[TimeSeriesLike]): A list of (time series) observations to calculated the statistics. Must be of same length as the number of rows of statspec.\n        weights (Dict[str, float]): numeric vector of weights to ponderate each objective.\n\n    Returns:\n        ObjectiveEvaluator: an objective evaluator\n\n    Examples:\n        &gt;&gt;&gt; _, ms = sdh.create_test_catchment_structure()\n        &gt;&gt;&gt; from swift2.utils import mk_full_data_id\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; nodeids = ['node.n2', 'node.n4']\n        &gt;&gt;&gt; mvids = mk_full_data_id(nodeids, 'OutflowRate')\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; sdh.configure_test_simulation(\n        ...     ms,\n        ...     data_id='MMH',\n        ...     simul_start='1990-01-01',\n        ...     simul_end='2005-12-31',\n        ...     tstep='daily',\n        ...     varname_rain='P',\n        ...     varname_pet='E',\n        ...     varname_data_rain='rain',\n        ...     varname_data_pet='evap',\n        ... )\n        &gt;&gt;&gt; \n\n        &gt;&gt;&gt; ms.record_state(mvids)\n        &gt;&gt;&gt; ms.exec_simulation()\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; modFlows = ms.get_recorded()\n        &gt;&gt;&gt; \n\n        &gt;&gt;&gt; w = dict(zip(mvids, [1.0, 2.0]))\n        &gt;&gt;&gt; w\n        {'node.n2.OutflowRate': 1.0, 'node.n4.OutflowRate': 2.0}\n        &gt;&gt;&gt; span = ms.get_simulation_span()\n        &gt;&gt;&gt; \n\n        &gt;&gt;&gt; from swift2.utils import rep\n        &gt;&gt;&gt; statspec = sst.multi_statistic_definition(mvids, rep('nse', 2), mvids, mvids, rep(span['start'], 2), rep(span['end'], 2) )\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; statspec\n                    ModelVarId StatisticId          ObjectiveId        ObjectiveName      Start        End\n        0  node.n2.OutflowRate         nse  node.n2.OutflowRate  node.n2.OutflowRate 1990-01-01 2005-12-31\n        1  node.n4.OutflowRate         nse  node.n4.OutflowRate  node.n4.OutflowRate 1990-01-01 2005-12-31\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # Create synthetic observations\n        &gt;&gt;&gt; observations = [\n        ...     modFlows.sel(variable_identifiers=mvids[0]) * 0.33,\n        ...     modFlows.sel(variable_identifiers=mvids[1]) * 0.77\n        ... ]\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; obj = ms.create_multisite_objective(statspec, observations, w)\n        &gt;&gt;&gt; \n\n        &gt;&gt;&gt; dummy = sp.create_parameteriser()\n        &gt;&gt;&gt; obj.get_scores(dummy)\n        {'node.n2.OutflowRate': -4.152338377267432, 'node.n4.OutflowRate': 0.8884789439301954}\n        &gt;&gt;&gt; \n\n        &gt;&gt;&gt; obj.get_score(dummy)\n        {'scores': {'MultisiteObjectives': 0.7917934964690136}, 'sysconfig': Empty DataFrame\n        Columns: [Name, Value, Min, Max]\n        Index: []}\n        &gt;&gt;&gt; \n    \"\"\"\n    return ssf.create_multisite_objective(self, statspec, observations, weights)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.create_objective","title":"<code>create_objective(state_name, observation, statistic, start_date, end_date)</code>","text":"<p>Creates an objective calculator</p> <p>Parameters:</p> Name Type Description Default <code>state_name</code> <code>str</code> <p>The name identifying the model state variable to calibrate against the observation</p> required <code>observation</code> <code>TimeSeriesLike</code> <p>an xts</p> required <code>statistic</code> <code>str</code> <p>statistic identifier, e.g. \"NSE\"</p> required <code>start_date</code> <code>ConvertibleToTimestamp</code> <p>start date of the period to calculate statistics on</p> required <code>end_date</code> <code>ConvertibleToTimestamp</code> <p>end date of the period to calculate statistics on</p> required <p>Returns:</p> Name Type Description <code>ObjectiveEvaluator</code> <code>ObjectiveEvaluator</code> <p>single objective evaluator</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def create_objective(\n    self,\n    state_name: str,\n    observation: TimeSeriesLike,\n    statistic: str,\n    start_date: ConvertibleToTimestamp,\n    end_date: ConvertibleToTimestamp,\n) -&gt; \"ObjectiveEvaluator\":\n    \"\"\"\n    Creates an objective calculator\n\n    Args:\n        state_name (str): The name identifying the model state variable to calibrate against the observation\n        observation (TimeSeriesLike): an xts\n        statistic (str): statistic identifier, e.g. \"NSE\"\n        start_date (ConvertibleToTimestamp): start date of the period to calculate statistics on\n        end_date (ConvertibleToTimestamp): end date of the period to calculate statistics on\n\n    Returns:\n        ObjectiveEvaluator: single objective evaluator\n    \"\"\"\n    return ssf.create_objective(\n        self, state_name, observation, statistic, start_date, end_date\n    )\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.describe","title":"<code>describe(verbosity=None)</code>","text":"<p>Describe the catchment model structure using simple python representations</p> <p>Parameters:</p> Name Type Description Default <code>verbosity</code> <code>Optional[int]</code> <p>Future option, unused for now. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>A dictionary representation of the catchment structure</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def describe(self, verbosity:Optional[int]=None) -&gt; Dict:\n    \"\"\"Describe the catchment model structure using simple python representations\n\n    Args:\n        verbosity (Optional[int], optional): Future option, unused for now. Defaults to None.\n\n    Returns:\n        Dict: A dictionary representation of the catchment structure\n    \"\"\"\n    return ss.describe(self, verbosity)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.ensemble_simulation","title":"<code>ensemble_simulation(ensemble_size)</code>","text":"<p>Create an ensemble simulation templated from this simulation</p> <p>Parameters:</p> Name Type Description Default <code>ensemble_size</code> <code>int</code> <p>The size of the ensemble dimension</p> required <p>Returns:</p> Name Type Description <code>EnsembleSimulation</code> <code>EnsembleSimulation</code> <p>Ensemble simulation (ensemble simulation runner)</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def ensemble_simulation(self, ensemble_size: int) -&gt; \"EnsembleSimulation\":\n    \"\"\"Create an ensemble simulation templated from this simulation\n\n    Args:\n        ensemble_size (int): The size of the ensemble dimension\n\n    Returns:\n        EnsembleSimulation: Ensemble simulation (ensemble simulation runner)\n    \"\"\"        \n    return swg.CreateEnsembleModelRunner_py(self, ensembleSize=ensemble_size)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.erris_ensemble_simulation","title":"<code>erris_ensemble_simulation(warmup_start, warmup_end, observed_ts, error_model_element_id)</code>","text":"<p>Creates an ensemble simulation templated on this simulation, with an ERRIS model on one of the network element</p> <p>Parameters:</p> Name Type Description Default <code>warmup_start</code> <code>ConvertibleToTimestamp</code> <p>start time stamp for the warmup period</p> required <code>warmup_end</code> <code>ConvertibleToTimestamp</code> <p>end time stamp for the warmup period</p> required <code>observed_ts</code> <code>TimeSeriesLike</code> <p>Time series of observations to correct prediction against</p> required <code>error_model_element_id</code> <code>str</code> <p>model element identifier where to set up an ERRIS correction model</p> required <p>Returns:</p> Name Type Description <code>EnsembleSimulation</code> <code>EnsembleSimulation</code> <p>Ensemble simulation (ensemble simulation runner)</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def erris_ensemble_simulation(\n    self,\n    warmup_start: ConvertibleToTimestamp,\n    warmup_end: ConvertibleToTimestamp,\n    observed_ts: TimeSeriesLike,\n    error_model_element_id: str,\n) -&gt; \"EnsembleSimulation\":\n    \"\"\"Creates an ensemble simulation templated on this simulation, with an ERRIS model on one of the network element\n\n    Args:\n        warmup_start (ConvertibleToTimestamp): start time stamp for the warmup period\n        warmup_end (ConvertibleToTimestamp): end time stamp for the warmup period\n        observed_ts (TimeSeriesLike): Time series of observations to correct prediction against\n        error_model_element_id (str): model element identifier where to set up an ERRIS correction model\n\n    Returns:\n        EnsembleSimulation: Ensemble simulation (ensemble simulation runner)\n    \"\"\"\n    from cinterop.timeseries import as_pydatetime\n\n    from swift2.internal import to_interop_univariate_series\n    warmup_start = as_pydatetime(warmup_start)\n    warmup_end = as_pydatetime(warmup_end)\n    values, ts_geom = to_interop_univariate_series(observed_ts)\n    return swg.PrepareEnsembleModelRunner_py(\n        self, warmup_start, warmup_end, values, ts_geom, error_model_element_id\n    )\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.from_json_file","title":"<code>from_json_file(file_path)</code>  <code>staticmethod</code>","text":"<p>Create a model simulation from a file with a JSON serialisation.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>valid file path.</p> required <p>Returns:</p> Name Type Description <code>Simulation</code> <code>Simulation</code> <p>a catchment simulation.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>@staticmethod\ndef from_json_file(file_path:str) -&gt; \"Simulation\":\n    \"\"\"Create a model simulation from a file with a JSON serialisation.\n\n    Args:\n        file_path (str): valid file path.\n\n    Returns:\n        Simulation: a catchment simulation.\n    \"\"\"\n    return smd.model_from_json_file(file_path)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_all_played","title":"<code>get_all_played()</code>","text":"<p>Gets all the time series of models variables into which input time sereis is/are played</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_all_played(self) -&gt; xr.DataArray:\n    \"\"\"Gets all the time series of models variables into which input time sereis is/are played\"\"\"\n    return spr.get_all_played(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_all_recorded","title":"<code>get_all_recorded()</code>","text":"<p>Gets all the time series of models variables recorded from</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_all_recorded(self) -&gt; xr.DataArray:\n    \"\"\"Gets all the time series of models variables recorded from\"\"\"\n    return spr.get_all_recorded(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_catchment_structure","title":"<code>get_catchment_structure()</code>","text":"<p>Gets the essential connective structure of a catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>base catchment simulation</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A nested dictionary describing the catchment connectivity of subareas, links, and nodes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; _, simulation = sdh.create_test_catchment_structure()\n&gt;&gt;&gt; simulation.get_catchment_structure()\n{'Node':    Id     Name\n0  n1  n1_name\n1  n2  n2_name\n2  n3  n3_name\n3  n4  n4_name\n4  n5  n5_name\n5  n6  n6_name, 'Link':      Id       Name  LengthMetres    f  ManningsN  Slope\n0  lnk1  lnk1_name           0.0  0.0        0.0    0.0\n1  lnk2  lnk2_name           0.0  0.0        0.0    0.0\n2  lnk3  lnk3_name           0.0  0.0        0.0    0.0\n3  lnk4  lnk4_name           0.0  0.0        0.0    0.0\n4  lnk5  lnk5_name           0.0  0.0        0.0    0.0, 'Subarea':      Id       Name  AreaKm2\n0  lnk1  lnk1_name      1.1\n1  lnk2  lnk2_name      2.2\n2  lnk3  lnk3_name      3.3\n3  lnk4  lnk4_name      4.4\n4  lnk5  lnk5_name      5.5, 'NodeLink':   DownstreamId UpstreamId LinkId\n0           n6         n2   lnk1\n1           n2         n5   lnk2\n2           n2         n4   lnk3\n3           n4         n3   lnk4\n4           n4         n1   lnk5, 'SubareaLink':   LinkId SubareaId\n0   lnk1      lnk1\n1   lnk2      lnk2\n2   lnk3      lnk3\n3   lnk4      lnk4\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_catchment_structure(self) -&gt; Dict[str, Any]:\n    \"\"\"Gets the essential connective structure of a catchment\n\n    Args:\n        simulation (Simulation): base catchment simulation\n\n    Returns:\n        Dict[str, Any]: A nested dictionary describing the catchment connectivity of subareas, links, and nodes\n\n    Examples:\n        &gt;&gt;&gt; _, simulation = sdh.create_test_catchment_structure()\n        &gt;&gt;&gt; simulation.get_catchment_structure()\n        {'Node':    Id     Name\n        0  n1  n1_name\n        1  n2  n2_name\n        2  n3  n3_name\n        3  n4  n4_name\n        4  n5  n5_name\n        5  n6  n6_name, 'Link':      Id       Name  LengthMetres    f  ManningsN  Slope\n        0  lnk1  lnk1_name           0.0  0.0        0.0    0.0\n        1  lnk2  lnk2_name           0.0  0.0        0.0    0.0\n        2  lnk3  lnk3_name           0.0  0.0        0.0    0.0\n        3  lnk4  lnk4_name           0.0  0.0        0.0    0.0\n        4  lnk5  lnk5_name           0.0  0.0        0.0    0.0, 'Subarea':      Id       Name  AreaKm2\n        0  lnk1  lnk1_name      1.1\n        1  lnk2  lnk2_name      2.2\n        2  lnk3  lnk3_name      3.3\n        3  lnk4  lnk4_name      4.4\n        4  lnk5  lnk5_name      5.5, 'NodeLink':   DownstreamId UpstreamId LinkId\n        0           n6         n2   lnk1\n        1           n2         n5   lnk2\n        2           n2         n4   lnk3\n        3           n4         n3   lnk4\n        4           n4         n1   lnk5, 'SubareaLink':   LinkId SubareaId\n        0   lnk1      lnk1\n        1   lnk2      lnk2\n        2   lnk3      lnk3\n        3   lnk4      lnk4\n    \"\"\"\n    return smd.get_catchment_structure(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_link_ids","title":"<code>get_link_ids()</code>","text":"<p>Gets all the identifiers of the links in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_link_ids(self) -&gt; List[str]:\n    \"\"\"\n    Gets all the identifiers of the links in the catchment\n    \"\"\"\n    return ss.get_link_ids(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_link_names","title":"<code>get_link_names()</code>","text":"<p>Gets all the names of the links in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_link_names(self) -&gt; List[str]:\n    \"\"\"\n    Gets all the names of the links in the catchment\n    \"\"\"\n    return ss.get_link_names(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_node_ids","title":"<code>get_node_ids()</code>","text":"<p>Gets all the identifiers of the nodes in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_node_ids(self) -&gt; List[str]:\n    \"\"\"\n    Gets all the identifiers of the nodes in the catchment\n    \"\"\"\n    return ss.get_node_ids(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_node_names","title":"<code>get_node_names()</code>","text":"<p>Gets all the names of the nodes in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_node_names(self) -&gt; List[str]:\n    \"\"\"\n    Gets all the names of the nodes in the catchment\n    \"\"\"\n    return ss.get_node_names(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_played","title":"<code>get_played(var_ids=None, start_time=None, end_time=None)</code>","text":"<p>Retrieves one or more played (input) time series from a simulation</p> <p>Parameters:</p> Name Type Description Default <code>var_ids</code> <code>optional str or sequence of str</code> <p>name(s) of the model variable(s) into which a time series is played as input. e.g. 'Catchment.StreamflowRate'. If missing, a multivariate time series of all played states is returned; this may be a large amount of data.</p> <code>None</code> <code>start_time</code> <code>datetime like</code> <p>An optional parameter, the start of a period to subset the time series</p> <code>None</code> <code>end_time</code> <code>datetime like</code> <p>An optional parameter, the end of a period to subset the time series</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>xr.DataArray: a time series, possibly multivariate.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_played(\n    self,\n    var_ids: Optional[\"VecStr\"] = None,\n    start_time: Optional[ConvertibleToTimestamp] = None,\n    end_time: Optional[ConvertibleToTimestamp] = None,\n) -&gt; xr.DataArray:\n    \"\"\"\n    Retrieves one or more played (input) time series from a simulation\n\n    Args:\n        var_ids (optional str or sequence of str): name(s) of the model variable(s) into which a time series is played as input. e.g. 'Catchment.StreamflowRate'. If missing, a multivariate time series of all played states is returned; this may be a large amount of data.\n        start_time (datetime like): An optional parameter, the start of a period to subset the time series\n        end_time (datetime like): An optional parameter, the end of a period to subset the time series\n\n    Returns:\n        xr.DataArray: a time series, possibly multivariate.\n\n    \"\"\"\n    return spr.get_played(self, var_ids, start_time, end_time)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_played_varnames","title":"<code>get_played_varnames()</code>","text":"<p>Gets all the names of model states fed an input time series</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_played_varnames(self) -&gt; List[str]:\n    \"\"\"\n    Gets all the names of model states fed an input time series\n    \"\"\"\n    return spr.get_played_varnames(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_recorded","title":"<code>get_recorded(var_ids=None, start_time=None, end_time=None)</code>","text":"<p>Retrieves a recorded time series from a simulation</p> <p>Parameters:</p> Name Type Description Default <code>var_ids</code> <code>optional str or sequence of str</code> <p>name(s) of the model variable(s) recorded to a time series. e.g. 'Catchment.StreamflowRate'. If missing, a multivariate time series of all played states is returned; this may be a large amount of data.</p> <code>None</code> <code>start_time</code> <code>datetime like</code> <p>An optional parameter, the start of a period to subset the time series</p> <code>None</code> <code>end_time</code> <code>datetime like</code> <p>An optional parameter, the end of a period to subset the time series</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>xr.DataArray: a time series, possibly multivariate.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_recorded(\n    self,\n    var_ids: Optional[\"VecStr\"] = None,\n    start_time: Optional[ConvertibleToTimestamp] = None,\n    end_time: Optional[ConvertibleToTimestamp] = None,\n) -&gt; xr.DataArray:\n    \"\"\"\n    Retrieves a recorded time series from a simulation\n\n    Args:\n        var_ids (optional str or sequence of str): name(s) of the model variable(s) recorded to a time series. e.g. 'Catchment.StreamflowRate'. If missing, a multivariate time series of all played states is returned; this may be a large amount of data.\n        start_time (datetime like): An optional parameter, the start of a period to subset the time series\n        end_time (datetime like): An optional parameter, the end of a period to subset the time series\n\n    Returns:\n        xr.DataArray: a time series, possibly multivariate.\n\n    \"\"\"\n    return spr.get_recorded(self, var_ids, start_time, end_time)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_simulation_span","title":"<code>get_simulation_span()</code>","text":"<p>Gets the simulation span of this simulation</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str,Any]: information on start, end, time step</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_simulation_span(self) -&gt; Dict[str, Any]:\n    \"\"\"Gets the simulation span of this simulation\n\n    Returns:\n        Dict[str,Any]: information on start, end, time step\n    \"\"\"\n    return swc.get_simulation_span_pkg(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_state_value","title":"<code>get_state_value(var_id)</code>","text":"<p>Gets the value(s) of a model state(s)</p> <p>Parameters:</p> Name Type Description Default <code>var_id</code> <code>VecStr</code> <p>string or sequence of str, model variable state identifier(s)</p> required <p>Returns:</p> Type Description <code>Union[Dict[str, float], float]</code> <p>value(s) of the requested model states</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_state_value(self, var_id: \"VecStr\") -&gt; Union[Dict[str, float], float]:\n    \"\"\"\n    Gets the value(s) of a model state(s)\n\n    Args:\n        var_id (VecStr): string or sequence of str, model variable state identifier(s)\n\n    Returns:\n        value(s) of the requested model states\n    \"\"\"\n    return ss.get_state_value(self, var_id)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_subarea_ids","title":"<code>get_subarea_ids()</code>","text":"<p>Gets all the identifiers of the subareas in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_subarea_ids(self) -&gt; List[str]:\n    \"\"\"\n    Gets all the identifiers of the subareas in the catchment\n    \"\"\"\n    return ss.get_subarea_ids(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_subarea_names","title":"<code>get_subarea_names()</code>","text":"<p>Gets all the names of the subareas in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_subarea_names(self) -&gt; List[str]:\n    \"\"\"\n    Gets all the names of the subareas in the catchment\n    \"\"\"\n    return ss.get_subarea_names(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.get_variable_ids","title":"<code>get_variable_ids(element_id=None, full_id=True)</code>","text":"<p>Gets all the names of the variables of an element (link, node, subarea) within a catchment</p> <p>Parameters:</p> Name Type Description Default <code>element_id</code> <code>Optional[str]</code> <p>a character, identifier of the element within the catchment</p> <code>None</code> <code>full_id</code> <code>bool</code> <p>boolean, if TRUE return the full hierarchical identifier</p> <code>True</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_variable_ids(\n    self, element_id: Optional[str] = None, full_id: bool = True\n) -&gt; List[str]:\n    \"\"\"\n    Gets all the names of the variables of an element (link, node, subarea) within a catchment\n\n    Args:\n        element_id (Optional[str]): a character, identifier of the element within the catchment\n        full_id (bool): boolean, if TRUE return the full hierarchical identifier\n\n    \"\"\"\n    return ss.get_variable_ids(self, element_id, full_id)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.is_variable_id","title":"<code>is_variable_id(var_id)</code>","text":"<p>Are one or more model state identifier(s) valid</p> <p>Parameters:</p> Name Type Description Default <code>var_id</code> <code>VecStr</code> <p>model identifier(s)</p> required <p>Returns:</p> Type Description <code>Union[Dict[str, bool], bool]</code> <p>Union[Dict[str, bool], bool]: whether the identifier(s) are valid. A dictionary is returned if the input is vectorised rather than scalar.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def is_variable_id(self, var_id: \"VecStr\") -&gt; Union[Dict[str, bool], bool]:\n    \"\"\"Are one or more model state identifier(s) valid\n\n    Args:\n        var_id (VecStr): model identifier(s)\n\n    Returns:\n        Union[Dict[str, bool], bool]: whether the identifier(s) are valid. A dictionary is returned if the input is vectorised rather than scalar.\n    \"\"\"\n    return ss.is_variable_id(self, var_id)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.muskingum_param_constraints","title":"<code>muskingum_param_constraints(inner_parameters, delta_t=1.0, param_name_k='K', param_name_x='X')</code>","text":"<p>Create a parameteriser with Muskingum-type constraints. </p> <p>Given an existing parameteriser, create a wrapper that adds constraints on two of its parameters.</p> <p>Parameters:</p> Name Type Description Default <code>inner_parameters</code> <code>HypercubeParameteriser</code> <p>A SWIFT parameteriser object that contains two Muskingum-type attenuation  and delay parameters.</p> required <code>delta_t</code> <code>int</code> <p>the simulation time step in HOURS. Defaults to 1.</p> <code>1.0</code> <code>param_name_k</code> <code>str</code> <p>the variable identifier to use for the delay parameter of the Muskingum routing. Defaults to \"K\".</p> <code>'K'</code> <code>param_name_x</code> <code>str</code> <p>the variable identifier to use for the attenuation parameter of the Muskingum routing. Defaults to \"X\".</p> <code>'X'</code> <p>Returns:</p> Name Type Description <code>ConstraintParameteriser</code> <code>ConstraintParameteriser</code> <p>A parameteriser with constraints on the feasibility of the attenuation / delay parameters</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; todo()\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def muskingum_param_constraints(\n    self,\n    inner_parameters: \"HypercubeParameteriser\",\n    delta_t: float = 1.0,\n    param_name_k: str = \"K\",\n    param_name_x: str = \"X\",\n) -&gt; \"ConstraintParameteriser\":\n    \"\"\"Create a parameteriser with Muskingum-type constraints. \n\n    Given an existing parameteriser, create a wrapper that adds constraints on two of its parameters.\n\n    Args:\n        inner_parameters (HypercubeParameteriser): A SWIFT parameteriser object that contains two Muskingum-type attenuation  and delay parameters.\n        delta_t (int, optional): the simulation time step in HOURS. Defaults to 1.\n        param_name_k (str, optional): the variable identifier to use for the delay parameter of the Muskingum routing. Defaults to \"K\".\n        param_name_x (str, optional): the variable identifier to use for the attenuation parameter of the Muskingum routing. Defaults to \"X\".\n\n    Returns:\n        ConstraintParameteriser: A parameteriser with constraints on the feasibility of the attenuation / delay parameters\n\n    Examples:\n       &gt;&gt;&gt; todo()\n    \"\"\"\n    return sp.create_muskingum_param_constraints(\n        inner_parameters, delta_t, param_name_k, param_name_x, self\n    )\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.play_input","title":"<code>play_input(input_ts, var_ids=None)</code>","text":"<p>Sets one or more time series as input(s) to a simulation</p> <p>Parameters:</p> Name Type Description Default <code>input_ts</code> <code>TimeSeriesLike</code> <p>univariate time series. If an xts time series column names must be valid model variable identifiers, unless explicitely provided via varIds</p> required <code>var_ids</code> <code>optional str or sequence of str</code> <p>optional character, the variable identifiers to use, overriding the column names of the inputTs. If not NULL, must be of length equal to the number of columns in inputTs</p> <code>None</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def play_input(\n    self, input_ts: TimeSeriesLike, var_ids: Optional[\"VecStr\"] = None\n) -&gt; None:\n    \"\"\"\n    Sets one or more time series as input(s) to a simulation\n\n    Args:\n        input_ts (TimeSeriesLike): univariate time series. If an xts time series column names must be valid model variable identifiers, unless explicitely provided via varIds\n        var_ids (optional str or sequence of str): optional character, the variable identifiers to use, overriding the column names of the inputTs. If not NULL, must be of length equal to the number of columns in inputTs\n    \"\"\"\n    spr.play_singular_simulation(self, input_ts, var_ids)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.play_inputs","title":"<code>play_inputs(data_library, model_var_id, data_id, resample='')</code>","text":"<p>Assign input time series from a time series library to a model simulation</p> <p>Parameters:</p> Name Type Description Default <code>data_library</code> <code>TimeSeriesLibrary</code> <p>external pointer type ENSEMBLE_DATA_SET_PTR, or a Python class wrapper around it </p> required <code>model_var_id</code> <code>str or sequence of str</code> <p>model state variable unique identifier(s)</p> required <code>data_id</code> <code>str or sequence of str</code> <p>identifier(s) for data in the data_library. If length is not the same as model_var_id, the elements of data_id are reused to match it</p> required <code>resample</code> <code>str or sequence of str</code> <p>identifier(s) for how the series is resampled (aggregated or disaggregated). If length is not the same as model_var_id, the elements of resample are reused to match it</p> <code>''</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def play_inputs(\n    self,\n    data_library: uc.TimeSeriesLibrary,\n    model_var_id: \"VecStr\",\n    data_id: \"VecStr\",\n    resample: \"VecStr\" = \"\",\n) -&gt; None:\n    \"\"\"\n    Assign input time series from a time series library to a model simulation\n\n    Args:\n        data_library (TimeSeriesLibrary): external pointer type ENSEMBLE_DATA_SET_PTR, or a Python class wrapper around it \n        model_var_id (str or sequence of str): model state variable unique identifier(s)\n        data_id (str or sequence of str): identifier(s) for data in the data_library. If length is not the same as model_var_id, the elements of data_id are reused to match it\n        resample (str or sequence of str): identifier(s) for how the series is resampled (aggregated or disaggregated). If length is not the same as model_var_id, the elements of resample are reused to match it\n\n    \"\"\"\n    spr.play_inputs(self, data_library, model_var_id, data_id, resample)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.play_subarea_input","title":"<code>play_subarea_input(input, subarea_name, input_name)</code>","text":"<p>Sets time series as input to a simulation</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>TimeSeriesLike</code> <p>univariate time series.</p> required <code>subarea_name</code> <code>str</code> <p>a valid name of the subarea</p> required <code>input_name</code> <code>str</code> <p>the name of the input variable to the model (i.e. 'P' for the precip of GR5H)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def play_subarea_input(\n    self, input: TimeSeriesLike, subarea_name: str, input_name: str\n) -&gt; None:\n    \"\"\"\n    Sets time series as input to a simulation\n\n    Args:\n        input (TimeSeriesLike): univariate time series.\n        subarea_name (str): a valid name of the subarea\n        input_name (str): the name of the input variable to the model (i.e. 'P' for the precip of GR5H)\n\n    \"\"\"\n    spr.play_subarea_input(self, input, subarea_name, input_name)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.prepare_dual_pass_forecasting","title":"<code>prepare_dual_pass_forecasting(observation, error_model_element_id, warmup_start, warmup_end, required_windows_percentage)</code>","text":"<p>Create an ensemble simulation for forecasting with the Dual Pass error correction method </p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <code>TimeSeriesLike</code> <p>Time series of observations to correct prediction against</p> required <code>error_model_element_id</code> <code>str</code> <p>model element identifier where to set up an ERRIS correction model</p> required <code>warmup_start</code> <code>ConvertibleToTimestamp</code> <p>start time stamp for the warmup period</p> required <code>warmup_end</code> <code>ConvertibleToTimestamp</code> <p>end time stamp for the warmup period</p> required <code>required_windows_percentage</code> <code>float</code> <p>required_windows_percentage</p> required <p>Returns:</p> Name Type Description <code>EnsembleSimulation</code> <code>EnsembleSimulation</code> <p>Ensemble simulation (ensemble simulation runner)</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def prepare_dual_pass_forecasting(\n    self,\n    observation: TimeSeriesLike,\n    error_model_element_id: str,\n    warmup_start: ConvertibleToTimestamp,\n    warmup_end: ConvertibleToTimestamp,\n    required_windows_percentage: float,\n) -&gt; 'EnsembleSimulation':\n    \"\"\"Create an ensemble simulation for forecasting with the Dual Pass error correction method \n\n    Args:\n        observation (TimeSeriesLike): Time series of observations to correct prediction against\n        error_model_element_id (str): model element identifier where to set up an ERRIS correction model\n        warmup_start (ConvertibleToTimestamp): start time stamp for the warmup period\n        warmup_end (ConvertibleToTimestamp): end time stamp for the warmup period\n        required_windows_percentage (float): required_windows_percentage\n\n    Returns:\n        EnsembleSimulation: Ensemble simulation (ensemble simulation runner)\n    \"\"\"    \n    from swift2.internal import to_interop_univariate_series\n\n    values, ts_geom = to_interop_univariate_series(\n        observation, warmup_start, warmup_end\n    )\n    return swg.PrepareDualPassForecasting_py(\n        self,\n        values,\n        ts_geom,\n        error_model_element_id,\n        warmup_start,\n        warmup_end,\n        required_windows_percentage,\n    )\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.prepare_erris_forecasting","title":"<code>prepare_erris_forecasting(observation, error_model_element_id, warmup_start, warmup_end)</code>","text":"<p>Create an ensemble simulation for forecasting with ERRIS</p> <p>Parameters:</p> Name Type Description Default <code>observation</code> <code>TimeSeriesLike</code> <p>Time series of observations to correct prediction against</p> required <code>error_model_element_id</code> <code>str</code> <p>model element identifier where to set up an ERRIS correction model</p> required <code>warmup_start</code> <code>ConvertibleToTimestamp</code> <p>start time stamp for the warmup period</p> required <code>warmup_end</code> <code>ConvertibleToTimestamp</code> <p>end time stamp for the warmup period</p> required <p>Returns:</p> Name Type Description <code>EnsembleSimulation</code> <code>EnsembleSimulation</code> <p>Ensemble simulation (ensemble simulation runner)</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def prepare_erris_forecasting(\n    self,\n    observation: TimeSeriesLike,\n    error_model_element_id: str,\n    warmup_start: ConvertibleToTimestamp,\n    warmup_end: ConvertibleToTimestamp,\n) -&gt; 'EnsembleSimulation':\n    \"\"\"Create an ensemble simulation for forecasting with ERRIS\n\n    Args:\n        observation (TimeSeriesLike): Time series of observations to correct prediction against\n        error_model_element_id (str): model element identifier where to set up an ERRIS correction model\n        warmup_start (ConvertibleToTimestamp): start time stamp for the warmup period\n        warmup_end (ConvertibleToTimestamp): end time stamp for the warmup period\n\n    Returns:\n        EnsembleSimulation: Ensemble simulation (ensemble simulation runner)\n    \"\"\"\n    from swift2.internal import to_interop_univariate_series\n\n    values, ts_geom = to_interop_univariate_series(\n        observation, warmup_start, warmup_end\n    )\n    return swg.PrepareERRISForecasting_py(\n        self, values, ts_geom, error_model_element_id, warmup_start, warmup_end\n    )\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.record_singular_state","title":"<code>record_singular_state(var_ids=CATCHMENT_FLOWRATE_VARID, recording_provider=None, data_ids=None)</code>","text":"<p>DRAFT Advanced/technical. Record states to a record provider. </p> <p>Likely not for end users.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def record_singular_state(\n    self,\n    var_ids: \"VecStr\" = CATCHMENT_FLOWRATE_VARID,\n    recording_provider: Optional[\"TimeSeriesLibrary\"] = None,\n    data_ids: Optional[\"VecStr\"] = None,\n) -&gt; None:\n    \"\"\"DRAFT Advanced/technical. Record states to a record provider. \n\n    Likely not for end users.\n    \"\"\"\n    spr.record_singular_state(self, var_ids, recording_provider, data_ids)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.remove_state_initialisers","title":"<code>remove_state_initialisers()</code>","text":"<p>Forces the removal of any state initialiser.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def remove_state_initialisers(self):\n    \"\"\"Forces the removal of any state initialiser.\"\"\"\n    swg.RemoveStateInitializerModelRunner_py(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.reset_model_states","title":"<code>reset_model_states()</code>","text":"<p>Reset the model states of a simulation, and apply one or more state initialers if the simulation is configured with any.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def reset_model_states(self) -&gt; None:\n    \"\"\"Reset the model states of a simulation, and apply one or more state initialers if the simulation is configured with any.\"\"\"\n    ss.reset_model_states(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.set_error_correction_model","title":"<code>set_error_correction_model(model_id, element_id, length=1, seed=0)</code>","text":"<p>Add an error correction model to an element in a catchment</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>str</code> <p>the identifier of the new model to use, e.g. 'ERRIS'</p> required <code>element_id</code> <code>str</code> <p>the identifier of the catchment element (node, link, subcatchment) whose outflow rate is corrected.</p> required <code>length</code> <code>int</code> <p>other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.</p> <code>1</code> <code>seed</code> <code>int</code> <p>other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.</p> <code>0</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_error_correction_model(\n    self, model_id: str, element_id: str, length: int = 1, seed: int = 0\n) -&gt; None:\n    \"\"\"\n    Add an error correction model to an element in a catchment\n\n    Args:\n        model_id (str): the identifier of the new model to use, e.g. 'ERRIS'\n        element_id (str): the identifier of the catchment element (node, link, subcatchment) whose outflow rate is corrected.\n        length (int): other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.\n        seed (int): other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.\n\n    \"\"\"\n    ss.set_error_correction_model(self, model_id, element_id, length, seed)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.set_reservoir_geometry","title":"<code>set_reservoir_geometry(element_id, level, storage, area)</code>","text":"<p>Sets the geometry of a reservoir</p> <p>Parameters:</p> Name Type Description Default <code>element_id</code> <code>str</code> <p>Element with a suitable reservoir supporting a geometry description</p> required <code>level</code> <code>ndarray</code> <p>array of water surface levels, in S.I. units (m) TO BE CONFIRMED</p> required <code>storage</code> <code>ndarray</code> <p>array of volume storages, in S.I. units (m3) TO BE CONFIRMED</p> required <code>area</code> <code>ndarray</code> <p>array of surfce areas, in S.I. units (m2) TO BE CONFIRMED</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_reservoir_geometry(\n    self, element_id: str, level: np.ndarray, storage: np.ndarray, area: np.ndarray\n) -&gt; None:\n    \"\"\"Sets the geometry of a reservoir\n\n    Args:\n        element_id (str): Element with a suitable reservoir supporting a geometry description\n        level (np.ndarray): array of water surface levels, in S.I. units (m) TO BE CONFIRMED\n        storage (np.ndarray): array of volume storages, in S.I. units (m3) TO BE CONFIRMED\n        area (np.ndarray): array of surfce areas, in S.I. units (m2) TO BE CONFIRMED\n    \"\"\"\n    num_entries = len(level)\n    assert len(storage) == num_entries\n    assert len(area) == num_entries\n    swg.SetReservoirGeometry_py(self, element_id, num_entries, level, storage, area)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.set_reservoir_max_discharge","title":"<code>set_reservoir_max_discharge(element_id, level, discharge)</code>","text":"<p>Sets a reservoir operating curve, maximum release for a given level</p> <p>Parameters:</p> Name Type Description Default <code>element_id</code> <code>str</code> <p>Element with a suitable reservoir supporting a geometry description</p> required <code>level</code> <code>ndarray</code> <p>array of levels (m)</p> required <code>discharge</code> <code>ndarray</code> <p>array of maximum discharges (m3/s)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_reservoir_max_discharge(\n    self, element_id: str, level: np.ndarray, discharge: np.ndarray\n) -&gt; None:\n    \"\"\"Sets a reservoir operating curve, maximum release for a given level\n\n    Args:\n        element_id (str): Element with a suitable reservoir supporting a geometry description\n        level (np.ndarray): array of levels (m)\n        discharge (np.ndarray): array of maximum discharges (m3/s)\n    \"\"\"\n    num_entries = len(level)\n    swg.SetReservoirMaxDischarge_py(self, element_id, num_entries, level, discharge)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.set_reservoir_min_discharge","title":"<code>set_reservoir_min_discharge(element_id, level, discharge)</code>","text":"<p>Sets a reservoir operating curve, minimum release for a given level</p> <p>Parameters:</p> Name Type Description Default <code>element_id</code> <code>str</code> <p>Element with a suitable reservoir supporting a geometry description</p> required <code>level</code> <code>ndarray</code> <p>array of levels (m)</p> required <code>discharge</code> <code>ndarray</code> <p>array of minimum discharges (m3/s)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_reservoir_min_discharge(\n    self, element_id: str, level: np.ndarray, discharge: np.ndarray\n) -&gt; None:\n    \"\"\"Sets a reservoir operating curve, minimum release for a given level\n\n    Args:\n        element_id (str): Element with a suitable reservoir supporting a geometry description\n        level (np.ndarray): array of levels (m)\n        discharge (np.ndarray): array of minimum discharges (m3/s)\n    \"\"\"\n    num_entries = len(level)\n    swg.SetReservoirMinDischarge_py(self, element_id, num_entries, level, discharge)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.set_reservoir_model","title":"<code>set_reservoir_model(new_model_id, element_id)</code>","text":"<p>Sets a new reservoir model on an element</p> <p>Parameters:</p> Name Type Description Default <code>new_model_id</code> <code>str</code> <p>Currently one of: \"ControlledReleaseReservoir\", \"LevelVolumeAreaReservoir\", \"FarmDamReservoir\";</p> required <code>element_id</code> <code>str</code> <p>description</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_reservoir_model(self, new_model_id: str, element_id: str) -&gt; None:\n    \"\"\"Sets a new reservoir model on an element\n\n    Args:\n        new_model_id (str): Currently one of: \"ControlledReleaseReservoir\", \"LevelVolumeAreaReservoir\", \"FarmDamReservoir\";\n        element_id (str): _description_\n    \"\"\"\n    swg.SetReservoirModel_py(self, new_model_id, element_id)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.set_simulation_span","title":"<code>set_simulation_span(start, end)</code>","text":"<p>Sets the simulation span</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>ConvertibleToTimestamp</code> <p>the start date of the simulation. The time zone will be forced to UTC.</p> required <code>end</code> <code>ConvertibleToTimestamp</code> <p>the end date of the simulation. The time zone will be forced to UTC.</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_simulation_span(\n    self, start: ConvertibleToTimestamp, end: ConvertibleToTimestamp\n) -&gt; None:\n    \"\"\"\n    Sets the simulation span\n\n    Args:\n        start (ConvertibleToTimestamp): the start date of the simulation. The time zone will be forced to UTC.\n        end (ConvertibleToTimestamp): the end date of the simulation. The time zone will be forced to UTC.\n    \"\"\"\n    ss.set_simulation_span(self, start, end)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.set_simulation_time_step","title":"<code>set_simulation_time_step(name)</code>","text":"<p>Sets the time step of this simulation</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>a time step identifier, currently 'daily' or 'hourly' are supported. The identifier is made lower case in the function.</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_simulation_time_step(self, name: str) -&gt; None:\n    \"\"\"\n    Sets the time step of this simulation\n\n    Args:\n        name (str): a time step identifier, currently 'daily' or 'hourly' are supported. The identifier is made lower case in the function.\n    \"\"\"\n    ss.set_simulation_time_step(self, name)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.set_state_value","title":"<code>set_state_value(var_id, value=None)</code>","text":"<p>Sets the value of a model state</p> <p>Parameters:</p> Name Type Description Default <code>var_id</code> <code>Any</code> <p>character, model variable state identifier(s)</p> required <code>value</code> <code>Any</code> <p>numeric value(s)</p> <code>None</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_state_value(\n    self,\n    var_id: Union[str, Sequence[str]],\n    value: Union[float, int, bool, Sequence] = None,\n) -&gt; None:\n    \"\"\"\n    Sets the value of a model state\n\n    Args:\n        var_id (Any): character, model variable state identifier(s)\n        value (Any): numeric value(s)\n\n    \"\"\"\n    ss.set_state_value(self, var_id, value)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.set_states","title":"<code>set_states(states)</code>","text":"<p>Apply memory states to a simulation</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>MemoryStates</code> <p>memory states</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def set_states(self, states: \"MemoryStates\") -&gt; None:\n    \"\"\"Apply memory states to a simulation\n\n    Args:\n        states (MemoryStates): memory states\n    \"\"\"\n    ss.set_states(self, states)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.snapshot_state","title":"<code>snapshot_state()</code>","text":"<p>Take a snapshot of the memory states of a simulation</p> <p>Returns:</p> Name Type Description <code>MemoryStates</code> <code>MemoryStates</code> <p>memory states, that can be stored and reapplied</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def snapshot_state(self) -&gt; \"MemoryStates\":\n    \"\"\"Take a snapshot of the memory states of a simulation\n\n    Returns:\n        MemoryStates: memory states, that can be stored and reapplied\n    \"\"\"\n    return ss.snapshot_state(self)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.sort_by_execution_order","title":"<code>sort_by_execution_order(split_element_ids, sorting_option='')</code>","text":"<p>Sort the specified element ids according to the execution order of the simulation</p> <p>Parameters:</p> Name Type Description Default <code>split_element_ids</code> <code>Sequence[str]</code> <p>a character vector with element identifiers such as 'node.n1', 'link.linkId_2'</p> required <code>sorting_option</code> <code>str</code> <p>a character - for future options. Ignored for now.</p> <code>''</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: values in split_element_ids sorted by simulation execution order</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def sort_by_execution_order(\n    self, split_element_ids: Sequence[str], sorting_option: str = \"\"\n) -&gt; List[str]:\n    \"\"\"\n    Sort the specified element ids according to the execution order of the simulation\n\n    Args:\n        split_element_ids (Sequence[str]): a character vector with element identifiers such as 'node.n1', 'link.linkId_2'\n        sorting_option (str): a character - for future options. Ignored for now.\n\n    Returns:\n        List[str]: values in split_element_ids sorted by simulation execution order\n\n    \"\"\"\n    return ss.sort_by_execution_order(self, split_element_ids, sorting_option)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.split_to_subcatchments","title":"<code>split_to_subcatchments(split_element_ids, include_upstream=None)</code>","text":"<p>Split a catchment in subcatchments, given a list of node/link element identifiers</p> <p>Parameters:</p> Name Type Description Default <code>split_element_ids</code> <code>str</code> <p>element identifiers such as 'node.n1', 'link.linkId_2'</p> required <code>include_upstream</code> <code>bool</code> <p>indicates whether for each element in split_element_ids it should be including in the upstream portion of the subcatchment. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrderedDict</code> <code>OrderedDict[str, Simulation]</code> <p>list of subcatchments resulting from the split</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; _, simulation = sdh.create_test_catchment_structure()\n&gt;&gt;&gt; e_ids = ['node.n2', 'node.n4']\n&gt;&gt;&gt; sub_sims = simulation.split_to_subcatchments(e_ids)\n&gt;&gt;&gt; for k in sub_sims:\n&gt;&gt;&gt;     print(k)\n&gt;&gt;&gt;     print(sub_sims[k].get_node_ids())\n&gt;&gt;&gt;     print(sub_sims[k].get_node_names())\nnode.n4\n['n4', 'n3', 'n1']\n['n4_name', 'n3_name', 'n1_name']\nnode.n2\n['n2', 'n5']\n['n2_name', 'n5_name']\nremainder\n['n6']\n['n6_name']\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def split_to_subcatchments(\n    self, split_element_ids: Sequence[str], include_upstream: Sequence[bool] = None\n) -&gt; OrderedDict[str, \"Simulation\"]:\n    \"\"\"Split a catchment in subcatchments, given a list of node/link element identifiers\n\n    Args:\n        split_element_ids (str): element identifiers such as 'node.n1', 'link.linkId_2'\n        include_upstream (bool, optional): indicates whether for each element in split_element_ids it should be including in the upstream portion of the subcatchment. Defaults to None.\n\n    Returns:\n        OrderedDict: list of subcatchments resulting from the split\n\n    Examples:\n        &gt;&gt;&gt; _, simulation = sdh.create_test_catchment_structure()\n        &gt;&gt;&gt; e_ids = ['node.n2', 'node.n4']\n        &gt;&gt;&gt; sub_sims = simulation.split_to_subcatchments(e_ids)\n        &gt;&gt;&gt; for k in sub_sims:\n        &gt;&gt;&gt;     print(k)\n        &gt;&gt;&gt;     print(sub_sims[k].get_node_ids())\n        &gt;&gt;&gt;     print(sub_sims[k].get_node_names())\n        node.n4\n        ['n4', 'n3', 'n1']\n        ['n4_name', 'n3_name', 'n1_name']\n        node.n2\n        ['n2', 'n5']\n        ['n2_name', 'n5_name']\n        remainder\n        ['n6']\n        ['n6_name']\n    \"\"\"\n    return smd.split_to_subcatchments(self, split_element_ids, include_upstream)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.subset_catchment","title":"<code>subset_catchment(element_id, action='keep_above')</code>","text":"<p>Subsets a catchment, keeping only a portion above or below a node, link or subarea.</p> <p>Parameters:</p> Name Type Description Default <code>element_id</code> <code>str</code> <p>id of the element to cut at.</p> required <code>action</code> <code>str</code> <p>how to cut; currently limited to 'keep_above'</p> <code>'keep_above'</code> <p>Returns:</p> Name Type Description <code>Simulation</code> <p>a subcatchment simulation, cookie cut from the base simulation. Deep clone of objects.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def subset_catchment(self, element_id: str, action: str = \"keep_above\"):\n    \"\"\"Subsets a catchment, keeping only a portion above or below a node, link or subarea.\n\n    Args:\n        element_id (str): id of the element to cut at.\n        action (str): how to cut; currently limited to 'keep_above'\n\n    Returns:\n        Simulation: a subcatchment simulation, cookie cut from the base simulation. Deep clone of objects.\n    \"\"\"\n    return smd.subset_catchment(self, element_id, action)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.swap_model","title":"<code>swap_model(model_id, what='runoff')</code>","text":"<p>Clone and change a simulation, using another model</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>str</code> <p>the identifier of the new model to use, e.g. 'GR4J'</p> required <code>what</code> <code>str</code> <p>character identifying the type of structure replaced: 'runoff', 'channel_routing'</p> <code>'runoff'</code> <p>Returns:</p> Name Type Description <code>Simulation</code> <code>Simulation</code> <p>A SWIFT simulation object, clone of the simulation but with a new model type in use.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def swap_model(self, model_id: str, what: str = \"runoff\") -&gt; \"Simulation\":\n    \"\"\"\n    Clone and change a simulation, using another model\n\n    Args:\n        model_id (str): the identifier of the new model to use, e.g. 'GR4J'\n        what (str): character identifying the type of structure replaced: 'runoff', 'channel_routing'\n\n    Returns:\n        Simulation: A SWIFT simulation object, clone of the simulation but with a new model type in use.\n\n    \"\"\"\n    return ss.swap_model(self, model_id, what)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.to_json_file","title":"<code>to_json_file(file_path)</code>","text":"<p>Save a model simulation from a file with a JSON serialisation.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>file path to save to</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def to_json_file(self, file_path:str) -&gt; None:\n    \"\"\"Save a model simulation from a file with a JSON serialisation.\n\n    Args:\n        file_path (str): file path to save to\n    \"\"\"\n    smd.model_to_json_file(self, file_path)\n</code></pre>"},{"location":"classes/#swift2.classes.Simulation.use_state_initialises","title":"<code>use_state_initialises(state_initialiser)</code>","text":"<p>Sets the state initialiser to use for a simulation. This forces the removal of any prior state initialiser.</p> <p>Parameters:</p> Name Type Description Default <code>state_initialiser</code> <code>StateInitialiser</code> <p>the new state initialiser to use</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def use_state_initialises(self, state_initialiser: \"StateInitialiser\"):\n    \"\"\"Sets the state initialiser to use for a simulation. This forces the removal of any prior state initialiser.\n\n    Args:\n        state_initialiser (StateInitialiser): the new state initialiser to use\n    \"\"\"\n    swg.UseStateInitializerModelRunner_py(self, state_initialiser)\n</code></pre>"},{"location":"classes/#swift2.classes.SimulationMixin","title":"<code>SimulationMixin</code>","text":"<p>A parent class for simulation objects. Most users are unlikely to explicitly use it.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>class SimulationMixin:\n    \"\"\"A parent class for simulation objects. Most users are unlikely to explicitly use it.\"\"\"\n\n    def __init__(\n        self,\n    ):\n        super(SimulationMixin, self).__init__()\n\n    def record_state(\n        self,\n        var_ids: \"VecStr\" = CATCHMENT_FLOWRATE_VARID,\n        recording_provider: Optional[\"TimeSeriesLibrary\"] = None,\n        data_ids: Optional[\"VecStr\"] = None,\n    ) -&gt; None:\n        \"\"\"\n        Record a time series of one of the state of the model\n\n        Args:\n            var_ids (VecStr, optional): identifier(s) of the output variable recorded to a time series, e.g. 'Catchment|StreamflowRate' or 'subcatchment.Subarea.runoff'. Defaults to CATCHMENT_FLOWRATE_VARID.\n            recording_provider (TimeSeriesLibrary, optional): _description_. Defaults to None.\n            data_ids (VecStr, optional): _description_. Defaults to None.\n\n        Raises:\n            ValueError: _description_\n        \"\"\"\n        spr.record_state(self, var_ids, recording_provider, data_ids)\n\n    def get_recorded_varnames(self) -&gt; List[str]:\n        \"\"\"\n        Gets all the names of the recorded states\n\n        Returns:\n            List[str]: The names of the state variables being recorded into time series\n        \"\"\"\n        return spr.get_recorded_varnames(self)\n\n    def get_played_varnames(self) -&gt; List[str]:\n        \"\"\"\n        Gets all the names of states fed an input time series\n\n        Returns:\n            List[str]: The names of the state variables fed over the simulation with values from a time series\n        \"\"\"\n        return spr.get_played_varnames(self)\n\n    def exec_simulation(self, reset_initial_states: bool = True) -&gt; None:\n        \"\"\"\n        Execute a simulation\n\n        Args:\n            reset_initial_states (bool): logical, should the states of the model be reinitialized before the first time step.\n\n        \"\"\"\n        ss.exec_simulation(self, reset_initial_states)\n</code></pre>"},{"location":"classes/#swift2.classes.SimulationMixin.exec_simulation","title":"<code>exec_simulation(reset_initial_states=True)</code>","text":"<p>Execute a simulation</p> <p>Parameters:</p> Name Type Description Default <code>reset_initial_states</code> <code>bool</code> <p>logical, should the states of the model be reinitialized before the first time step.</p> <code>True</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def exec_simulation(self, reset_initial_states: bool = True) -&gt; None:\n    \"\"\"\n    Execute a simulation\n\n    Args:\n        reset_initial_states (bool): logical, should the states of the model be reinitialized before the first time step.\n\n    \"\"\"\n    ss.exec_simulation(self, reset_initial_states)\n</code></pre>"},{"location":"classes/#swift2.classes.SimulationMixin.get_played_varnames","title":"<code>get_played_varnames()</code>","text":"<p>Gets all the names of states fed an input time series</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: The names of the state variables fed over the simulation with values from a time series</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_played_varnames(self) -&gt; List[str]:\n    \"\"\"\n    Gets all the names of states fed an input time series\n\n    Returns:\n        List[str]: The names of the state variables fed over the simulation with values from a time series\n    \"\"\"\n    return spr.get_played_varnames(self)\n</code></pre>"},{"location":"classes/#swift2.classes.SimulationMixin.get_recorded_varnames","title":"<code>get_recorded_varnames()</code>","text":"<p>Gets all the names of the recorded states</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: The names of the state variables being recorded into time series</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def get_recorded_varnames(self) -&gt; List[str]:\n    \"\"\"\n    Gets all the names of the recorded states\n\n    Returns:\n        List[str]: The names of the state variables being recorded into time series\n    \"\"\"\n    return spr.get_recorded_varnames(self)\n</code></pre>"},{"location":"classes/#swift2.classes.SimulationMixin.record_state","title":"<code>record_state(var_ids=CATCHMENT_FLOWRATE_VARID, recording_provider=None, data_ids=None)</code>","text":"<p>Record a time series of one of the state of the model</p> <p>Parameters:</p> Name Type Description Default <code>var_ids</code> <code>VecStr</code> <p>identifier(s) of the output variable recorded to a time series, e.g. 'Catchment|StreamflowRate' or 'subcatchment.Subarea.runoff'. Defaults to CATCHMENT_FLOWRATE_VARID.</p> <code>CATCHMENT_FLOWRATE_VARID</code> <code>recording_provider</code> <code>TimeSeriesLibrary</code> <p>description. Defaults to None.</p> <code>None</code> <code>data_ids</code> <code>VecStr</code> <p>description. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def record_state(\n    self,\n    var_ids: \"VecStr\" = CATCHMENT_FLOWRATE_VARID,\n    recording_provider: Optional[\"TimeSeriesLibrary\"] = None,\n    data_ids: Optional[\"VecStr\"] = None,\n) -&gt; None:\n    \"\"\"\n    Record a time series of one of the state of the model\n\n    Args:\n        var_ids (VecStr, optional): identifier(s) of the output variable recorded to a time series, e.g. 'Catchment|StreamflowRate' or 'subcatchment.Subarea.runoff'. Defaults to CATCHMENT_FLOWRATE_VARID.\n        recording_provider (TimeSeriesLibrary, optional): _description_. Defaults to None.\n        data_ids (VecStr, optional): _description_. Defaults to None.\n\n    Raises:\n        ValueError: _description_\n    \"\"\"\n    spr.record_state(self, var_ids, recording_provider, data_ids)\n</code></pre>"},{"location":"classes/#swift2.classes.TransformParameteriser","title":"<code>TransformParameteriser</code>","text":"<p>               Bases: <code>HypercubeParameteriser</code></p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>class TransformParameteriser(HypercubeParameteriser):\n    def __init__(\n        self,\n        handle: CffiData,\n        release_native: Callable[[CffiData], None],\n        type_id: Optional[str] = None,\n        prior_ref_count: int = 0,\n    ):\n        super(TransformParameteriser, self).__init__(\n            handle, release_native, type_id, prior_ref_count\n        )\n\n    def add_transform(\n        self,\n        param_name: str,\n        inner_param_name: str,\n        transform_id: str,\n        a: float = 1.0,\n        b: float = 0.0,\n    ):\n        \"\"\"Create a parameteriser for which parameter transformations can be defined\n\n            This allows to define e.g. a virtual parameter log_X instead of calibrating on the parameter X.\n\n        Args:\n            param_name (str): the name of the meta-parameter. Note that it can be the same value as inner_param_name, but this is NOT recommended.\n            inner_param_name (str): the name of the parameter being transformed\n            transform_id (str): identifier for a known bijective univariate function\n            a (float, optional): parameter in Y = F(ax+b). Defaults to 1.0.\n            b (float, optional): parameter in Y = F(ax+b). Defaults to 0.0.\n        \"\"\"\n        sp.add_transform(self, param_name, inner_param_name, transform_id, a, b)\n</code></pre>"},{"location":"classes/#swift2.classes.TransformParameteriser.add_transform","title":"<code>add_transform(param_name, inner_param_name, transform_id, a=1.0, b=0.0)</code>","text":"<p>Create a parameteriser for which parameter transformations can be defined</p> <pre><code>This allows to define e.g. a virtual parameter log_X instead of calibrating on the parameter X.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>the name of the meta-parameter. Note that it can be the same value as inner_param_name, but this is NOT recommended.</p> required <code>inner_param_name</code> <code>str</code> <p>the name of the parameter being transformed</p> required <code>transform_id</code> <code>str</code> <p>identifier for a known bijective univariate function</p> required <code>a</code> <code>float</code> <p>parameter in Y = F(ax+b). Defaults to 1.0.</p> <code>1.0</code> <code>b</code> <code>float</code> <p>parameter in Y = F(ax+b). Defaults to 0.0.</p> <code>0.0</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def add_transform(\n    self,\n    param_name: str,\n    inner_param_name: str,\n    transform_id: str,\n    a: float = 1.0,\n    b: float = 0.0,\n):\n    \"\"\"Create a parameteriser for which parameter transformations can be defined\n\n        This allows to define e.g. a virtual parameter log_X instead of calibrating on the parameter X.\n\n    Args:\n        param_name (str): the name of the meta-parameter. Note that it can be the same value as inner_param_name, but this is NOT recommended.\n        inner_param_name (str): the name of the parameter being transformed\n        transform_id (str): identifier for a known bijective univariate function\n        a (float, optional): parameter in Y = F(ax+b). Defaults to 1.0.\n        b (float, optional): parameter in Y = F(ax+b). Defaults to 0.0.\n    \"\"\"\n    sp.add_transform(self, param_name, inner_param_name, transform_id, a, b)\n</code></pre>"},{"location":"classes/#swift2.classes.VectorObjectiveScores","title":"<code>VectorObjectiveScores</code>","text":"<p>               Bases: <code>DeletableCffiNativeHandle</code></p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>class VectorObjectiveScores(DeletableCffiNativeHandle):\n    def __init__(\n        self,\n        handle: CffiData,\n        release_native: Callable[[CffiData], None],\n        type_id: Optional[str] = None,\n        prior_ref_count: int = 0,\n    ):\n        super(VectorObjectiveScores, self).__init__(\n            handle, release_native, type_id, prior_ref_count\n        )\n\n    def get_score_at_index(self, index):\n        return sp.get_score_at_index(self, index)\n\n    def get_parameters_at_index(self, index):\n        return sp.get_score_at_index(self, index).parameteriser\n\n    def get_best_score(self, score_name=\"NSE\", convert_to_py=False):\n        return sp.get_best_score(self, score_name, convert_to_py)\n\n    def sort_by_score(self, score_name=\"NSE\"):\n        return sp.sort_by_score(self, score_name)\n\n    def as_dataframe(self):\n        return sp.scores_as_dataframe(self)\n\n    def __str__(self):\n        \"\"\"string representation\"\"\"\n        return f\"{super().__str__()} \\n {str(self.as_dataframe())}\"\n\n    def __repr__(self):\n        \"\"\"representation\"\"\"\n        return f\"{super().__repr__()} \\n {repr(self.as_dataframe())}\"\n\n\n    @property\n    def size(self) -&gt; int:\n        return swg.GetLengthSetOfScores_py(self)\n</code></pre>"},{"location":"classes/#swift2.classes.VectorObjectiveScores.__repr__","title":"<code>__repr__()</code>","text":"<p>representation</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def __repr__(self):\n    \"\"\"representation\"\"\"\n    return f\"{super().__repr__()} \\n {repr(self.as_dataframe())}\"\n</code></pre>"},{"location":"classes/#swift2.classes.VectorObjectiveScores.__str__","title":"<code>__str__()</code>","text":"<p>string representation</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/classes.py</code> <pre><code>def __str__(self):\n    \"\"\"string representation\"\"\"\n    return f\"{super().__str__()} \\n {str(self.as_dataframe())}\"\n</code></pre>"},{"location":"common/","title":"Module common","text":""},{"location":"const/","title":"Module const","text":""},{"location":"doc_helper/","title":"Module doc_helper","text":""},{"location":"doc_helper/#swift2.doc_helper.check_simulation","title":"<code>check_simulation(simulation)</code>","text":"<p>Checks whether a simulation is configured to a state where it is executable</p> <p>Checks whether a simulation is configured to a state where it is executable</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def check_simulation(simulation) -&gt; Dict:\n    \"\"\"\n    Checks whether a simulation is configured to a state where it is executable\n\n    Checks whether a simulation is configured to a state where it is executable\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    \"\"\"\n    # Trying to design this such that we can have several types of messages\n    return {\"errors\": swg.CheckSimulationErrors_py(simulation)}\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.configure_daily_gr4j","title":"<code>configure_daily_gr4j(simulation)</code>","text":"<p>Configure a simulation with GR4J models for daily time step modelling</p> <p>Configure a simulation with GR4J models for daily time step modelling</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def configure_daily_gr4j(simulation):\n    \"\"\"\n    Configure a simulation with GR4J models for daily time step modelling\n\n    Configure a simulation with GR4J models for daily time step modelling\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    \"\"\"\n    pGr4jHourly = create_gr4jh_parameters(hourly=False)\n    apply_sys_config(pGr4jHourly, simulation)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.configure_hourly_gr4j","title":"<code>configure_hourly_gr4j(simulation)</code>","text":"<p>Configure a simulation with GR4J models for hourly time step modelling</p> <p>Configure a simulation with GR4J models for hourly time step modelling</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def configure_hourly_gr4j(simulation):\n    \"\"\"\n    Configure a simulation with GR4J models for hourly time step modelling\n\n    Configure a simulation with GR4J models for hourly time step modelling\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    \"\"\"\n    pGr4jHourly = create_gr4jh_parameters(hourly=True)\n    apply_sys_config(pGr4jHourly, simulation)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.create_catchment","title":"<code>create_catchment(node_ids, node_names, link_ids, link_names, link_from_node, link_to_node, runoff_model_name='GR4J', areas_km2=None)</code>","text":"<p>Create a SWIFT catchment with a specified hydrologic model</p> <p>Create a SWIFT catchment with a specified hydrologic model. This function is intended mostly for testing, not for usual modelling code.</p> <p>Parameters:</p> Name Type Description Default <code>node_ids</code> <code>Any</code> <p>character, node unique identifiers</p> required <code>node_names</code> <code>Any</code> <p>character, node display names</p> required <code>link_ids</code> <code>Any</code> <p>character, links unique identifiers</p> required <code>link_names</code> <code>Any</code> <p>character, links display names</p> required <code>link_from_node</code> <code>Any</code> <p>character, identifier of the links' upstream node</p> required <code>link_to_node</code> <code>Any</code> <p>character, identifier of the links' downstream node</p> required <code>runoff_model_name</code> <code>Any</code> <p>A valid, known SWIFT model name (e.g. 'GR5H')</p> <code>'GR4J'</code> <code>areas_km2</code> <code>Any</code> <p>The areas in square kilometres</p> <code>None</code> <p>Returns:</p> Type Description <p>A SWIFT simulation object (i.e. a model runner)</p> <p>Examples:</p> <p>TODO</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def create_catchment(\n    node_ids: List,\n    node_names: List,\n    link_ids: List,\n    link_names: List,\n    link_from_node: List,\n    link_to_node: List,\n    runoff_model_name: str = \"GR4J\",\n    areas_km2: List[float] = None,\n):\n    \"\"\"\n    Create a SWIFT catchment with a specified hydrologic model\n\n    Create a SWIFT catchment with a specified hydrologic model.\n    This function is intended mostly for testing, not for usual modelling code.\n\n    Args:\n        node_ids (Any): character, node unique identifiers\n        node_names (Any): character, node display names\n        link_ids (Any): character, links unique identifiers\n        link_names (Any): character, links display names\n        link_from_node (Any): character, identifier of the links' upstream node\n        link_to_node (Any): character, identifier of the links' downstream node\n        runoff_model_name (Any): A valid, known SWIFT model name (e.g. 'GR5H')\n        areas_km2 (Any): The areas in square kilometres\n\n    Returns:\n        A SWIFT simulation object (i.e. a model runner)\n\n    Examples:\n        TODO\n\n    \"\"\"\n    # &gt;&gt;&gt; # nodeIds=paste0('n', 1:6)\n    # &gt;&gt;&gt; # linkIds = paste0('lnk', 1:5)\n    # &gt;&gt;&gt; # defn &lt;- list(\n    # &gt;&gt;&gt; # nodeIds=nodeIds,\n    # &gt;&gt;&gt; # nodeNames = paste0(nodeIds, '_name'),\n    # &gt;&gt;&gt; # linkIds=linkIds,\n    # &gt;&gt;&gt; # linkNames = paste0(linkIds, '_name'),\n    # &gt;&gt;&gt; # fromNode = paste0('n', c(2,5,4,3,1)),\n    # &gt;&gt;&gt; # toNode = paste0('n', c(6,2,2,4,4)),\n    # &gt;&gt;&gt; # areasKm2 = c(1.2, 2.3, 4.4, 2.2, 1.5),\n    # &gt;&gt;&gt; # runoffModel = 'GR4J'\n    # &gt;&gt;&gt; # )\n    # &gt;&gt;&gt; # ms &lt;- createCatchment(defn$nodeIds, defn$nodeNames, defn$linkIds, defn$linkNames, defn$fromNode, defn$toNode, defn$runoffModel, defn$areasKm2)\n    if areas_km2 is None:\n        areas_km2 = rep(1.0, len(link_ids))\n    return swg.CreateCatchment_py(\n        numNodes=len(node_ids),\n        nodeIds=node_ids,\n        nodeNames=node_names,\n        numLinks=len(link_ids),\n        linkIds=link_ids,\n        linkNames=link_names,\n        linkFromNode=link_from_node,\n        linkToNode=link_to_node,\n        runoffModelName=runoff_model_name,\n        areasKm2=areas_km2,\n    )\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.create_ensemble_forecast_simulation","title":"<code>create_ensemble_forecast_simulation(simulation, data_library, start, end, input_map, lead_time, ensemble_size, n_time_steps_between_forecasts)</code>","text":"<p>Create an ensemble forecast simulation</p> <p>Create an ensemble forecast simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>data_library</code> <code>Any</code> <p>external pointer type ENSEMBLE_DATA_SET_PTR, or a Python class wrapper around it </p> required <code>start</code> <code>Any</code> <p>the start date of the simulation. The time zone will be forced to UTC.</p> required <code>end</code> <code>Any</code> <p>the end date of the simulation. The time zone will be forced to UTC.</p> required <code>input_map</code> <code>Any</code> <p>a named list were names are the data library data identifiers, and values are character vectors with model state identifiers.</p> required <code>lead_time</code> <code>Any</code> <p>integer, the length in time steps of the forecasts.</p> required <code>ensemble_size</code> <code>Any</code> <p>ensemble size</p> required <code>n_time_steps_between_forecasts</code> <code>Any</code> <p>nTimeStepsBetweenForecasts</p> required <p>Returns:</p> Type Description <p>An external pointer</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def create_ensemble_forecast_simulation(\n    simulation,\n    data_library,\n    start,\n    end,\n    input_map: Dict[str, List[str]],\n    lead_time,\n    ensemble_size,\n    n_time_steps_between_forecasts,\n):\n    \"\"\"\n    Create an ensemble forecast simulation\n\n    Create an ensemble forecast simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        data_library (Any): external pointer type ENSEMBLE_DATA_SET_PTR, or a Python class wrapper around it \n        start (Any): the start date of the simulation. The time zone will be forced to UTC.\n        end (Any): the end date of the simulation. The time zone will be forced to UTC.\n        input_map (Any): a named list were names are the data library data identifiers, and values are character vectors with model state identifiers.\n        lead_time (Any): integer, the length in time steps of the forecasts.\n        ensemble_size (Any): ensemble size\n        n_time_steps_between_forecasts (Any): nTimeStepsBetweenForecasts\n\n    Returns:\n        An external pointer\n\n    \"\"\"\n    s = as_timestamp(start)\n    e = as_timestamp(end)\n    simulation_length = swg.GetNumStepsForTimeSpan_py(simulation, s, e)\n    ef_simulation = swg.CreateEnsembleForecastSimulation_py(\n        simulation,\n        s,\n        lead_time,\n        ensemble_size,\n        simulation_length,\n        nTimeStepsBetweenForecasts=n_time_steps_between_forecasts,\n    )\n    data_ids = input_map.keys()\n    for data_id in data_ids:\n        identifiers = input_map[data_id]\n        swg.PlayDatasetEnsembleForecastInput_py(\n            ef_simulation,\n            data_library,\n            identifiers,\n            rep(data_id, len(identifiers)),\n            len(identifiers),\n        )\n    return ef_simulation\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.create_gr4jh_parameters","title":"<code>create_gr4jh_parameters(hourly=True)</code>","text":"<p>Get a parameter set that configures GR4J for hourly or daily operations</p> <p>Derived from the initial Fortran implementation in SWIFTv1 * UHExponent = 2.5 is the default value for daily time step. Set to 1.25 for hourly time step * PercFactor = 9.0 / 4.0 for daily, 4.0  for hourly time step.</p> <p>Returns:</p> Name Type Description <code>HyperCubeParameteriser</code> <p>a parameter set that can be applied to SWIFT systems with GR4J</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def create_gr4jh_parameters(hourly:bool = True):\n    \"\"\"\n    Get a parameter set that configures GR4J for hourly or daily operations\n\n    Derived from the initial Fortran implementation in SWIFTv1\n    * UHExponent = 2.5 is the default value for daily time step. Set to 1.25 for hourly time step\n    * PercFactor = 9.0 / 4.0 for daily, 4.0  for hourly time step.\n\n    Returns:\n        HyperCubeParameteriser: a parameter set that can be applied to SWIFT systems with GR4J\n\n    \"\"\"\n    # Configure for GR4J but with changed parameters, supposed to be OK for hourly operations according to SWIFTv1\n    uhexponent = 1.25 if hourly else 2.5\n    percfactor = 4.0 if hourly else 9.0 / 4.0\n    return create_parameteriser(\n        type = \"Generic subareas\",\n        specs=_df_from_dict(\n            Name=[\"PercFactor\", \"UHExponent\"],\n            Value=_npf([percfactor, uhexponent]),\n            Min=_npf([percfactor, uhexponent]),\n            Max=_npf([percfactor, uhexponent]),\n        )\n    )\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.create_subarea","title":"<code>create_subarea(model_name, area_km2)</code>","text":"<p>Create a SWIFT subarea with a specified hydrologic model</p> <p>Create a SWIFT subarea with a specified hydrologic model</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>Any</code> <p>A valid, known SWIFT model name (e.g. 'GR5H')</p> required <code>area_km2</code> <code>Any</code> <p>The area in square kilometres</p> required <p>Returns:</p> Type Description <p>A SWIFT simulation object (i.e. a model runner)</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def create_subarea(model_name, area_km2):\n    \"\"\"\n    Create a SWIFT subarea with a specified hydrologic model\n\n    Create a SWIFT subarea with a specified hydrologic model\n\n    Args:\n        model_name (Any): A valid, known SWIFT model name (e.g. 'GR5H')\n        area_km2 (Any): The area in square kilometres\n\n    Returns:\n        A SWIFT simulation object (i.e. a model runner)\n\n    \"\"\"\n    return swg.CreateSubarea_py(model_name, area_km2)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.create_subarea_simulation","title":"<code>create_subarea_simulation(data_id='MMH', simul_start='1990-01-01', simul_end='2005-12-31', model_id='GR4J', tstep='daily', varname_rain='P', varname_pet='E', data_rain_id='rain', data_evap_id='evap')</code>","text":"<p>Creates a one sub-catchment simulation</p> <p>Creates a one sub-catchment simulation. This function is intended for creating sample simulations, not for use in production.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>str</code> <p>data identifier in swift_sample_data</p> <code>'MMH'</code> <code>simul_start</code> <code>str</code> <p>ISO string for the simulation start date time</p> <code>'1990-01-01'</code> <code>simul_end</code> <code>str</code> <p>ISO string for the simulation end date time</p> <code>'2005-12-31'</code> <code>model_id</code> <code>str</code> <p>model identifier</p> <code>'GR4J'</code> <code>tstep</code> <code>str</code> <p>character, 'daily' or 'hourly'</p> <code>'daily'</code> <code>varname_rain</code> <code>str</code> <p>variable name to assign rainfall to</p> <code>'P'</code> <code>varname_pet</code> <code>str</code> <p>variable name to assign PET to</p> <code>'E'</code> <code>data_rain_id</code> <code>str</code> <p>key to use to retrieve the rainfall series from the sample data</p> <code>'rain'</code> <code>data_evap_id</code> <code>str</code> <p>key to use to retrieve the evaporation series from the sample data</p> <code>'evap'</code> <p>Returns:</p> Type Description <p>A SWIFT simulation object, clone of the simulation but with a new model type in use.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def create_subarea_simulation(\n    data_id:str=\"MMH\",\n    simul_start:str=\"1990-01-01\",\n    simul_end:str=\"2005-12-31\",\n    model_id:str=\"GR4J\",\n    tstep:str=\"daily\",\n    varname_rain:str=\"P\",\n    varname_pet:str=\"E\",\n    data_rain_id:str=\"rain\",\n    data_evap_id:str=\"evap\",\n):\n    \"\"\"\n    Creates a one sub-catchment simulation\n\n    Creates a one sub-catchment simulation. This function is intended for creating sample simulations, not for use in production.\n\n    Args:\n        data_id (str): data identifier in swift_sample_data\n        simul_start (str): ISO string for the simulation start date time\n        simul_end (str): ISO string for the simulation end date time\n        model_id (str): model identifier\n        tstep (str): character, 'daily' or 'hourly'\n        varname_rain (str): variable name to assign rainfall to\n        varname_pet (str): variable name to assign PET to\n        data_rain_id (str): key to use to retrieve the rainfall series from the sample data\n        data_evap_id (str): key to use to retrieve the evaporation series from the sample data\n\n    Returns:\n        A SWIFT simulation object, clone of the simulation but with a new model type in use.\n\n    \"\"\"\n    from swift2.doc_helper import sample_series\n    from swift2.wrap.swift_wrap_generated import CreateSubarea_py\n\n    s_span = slice(simul_start, simul_end)\n    rain = sample_series(data_id, data_rain_id)[s_span]\n    evap = sample_series(data_id, data_evap_id)[s_span]\n\n    ms = CreateSubarea_py(model_id, 1.0)\n    s = rain.index[0]\n    e = rain.index[-1]\n    set_simulation_span(ms, s, e)\n    set_simulation_time_step(ms, tstep)\n\n    sa_name = swg.GetSubareaNames_py(ms)[0]\n    play_subarea_input(ms, rain, sa_name, varname_rain)\n    play_subarea_input(ms, evap, sa_name, varname_pet)\n    return ms\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.define_gr4j_scaled_parameter","title":"<code>define_gr4j_scaled_parameter(ref_area=250, time_span=3600, pspec_gr4j=None)</code>","text":"<p>define a scaled and transformed parameterizer for GR4J</p> <p>define a scaled and transformed parameterizer for GR4J</p> <p>Parameters:</p> Name Type Description Default <code>ref_area</code> <code>float</code> <p>the reference area in square kilometres</p> <code>250</code> <code>time_span</code> <code>int</code> <p>the time span of the simulation intented for this model, in seconds</p> <code>3600</code> <code>pspec_gr4j</code> <code>DataFrame</code> <p>optional - data frame specifying the feasible parameter space for parameters x1 to x2 of GR4J</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TransformParameteriser</code> <p>a parameterizer for GR4J, combining time and area scaling and superimposed with log10 transforms for x1, x3, x4 and arc-sinh for x2</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def define_gr4j_scaled_parameter(ref_area:float=250, time_span:int=3600, pspec_gr4j:Optional[pd.DataFrame]=None):\n    \"\"\"\n    define a scaled and transformed parameterizer for GR4J\n\n    define a scaled and transformed parameterizer for GR4J\n\n    Args:\n        ref_area (float): the reference area in square kilometres\n        time_span (int): the time span of the simulation intented for this model, in seconds\n        pspec_gr4j (pd.DataFrame): optional - data frame specifying the feasible parameter space for parameters x1 to x2 of GR4J\n\n    Returns:\n        TransformParameteriser: a parameterizer for GR4J, combining time and area scaling and superimposed with log10 transforms for x1, x3, x4 and arc-sinh for x2\n    \"\"\"\n    time_span = int(time_span)\n    parameteriser = gr4j_scaled_parameteriser(ref_area, time_span)\n    if pspec_gr4j is None:\n        pspec_gr4j = _df_from_dict(\n            Name=[\"x1\", \"x2\", \"x3\", \"x4\"],\n            Value=_npf([3.21137e00, 6.95511e00, 2.06740e00, 2.02033e00]),\n            Min=_npf([1.0e00, -27.0, 1.0e00, 1.0e00]),\n            Max=_npf([6.0e03, 27.0, 1.0e03, 2.4e02]),\n        )\n    set_hypercube(parameteriser, pspec_gr4j)\n    parameteriser = wrap_transform(parameteriser)\n    add_transform(parameteriser, \"log_x4\", \"x4\", \"log10\")\n    add_transform(parameteriser, \"log_x1\", \"x1\", \"log10\")\n    add_transform(parameteriser, \"log_x3\", \"x3\", \"log10\")\n    add_transform(parameteriser, \"asinh_x2\", \"x2\", \"asinh\")\n\n    return parameteriser\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.exec_simulation","title":"<code>exec_simulation(simulation, reset_initial_states=True)</code>","text":"<p>Execute a simulation</p> <p>Execute a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>reset_initial_states</code> <code>Any</code> <p>logical, should the states of the model be reinitialized before the first time step.</p> <code>True</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def exec_simulation(simulation: \"Simulation\", reset_initial_states=True):\n    \"\"\"\n    Execute a simulation\n\n    Execute a simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        reset_initial_states (Any): logical, should the states of the model be reinitialized before the first time step.\n\n    \"\"\"\n    if simulation.type_id == \"ENSEMBLE_FORECAST_SIMULATION_PTR\":\n        swg.ExecuteEnsembleForecastSimulation_py(simulation)\n    elif simulation.type_id == \"ENSEMBLE_SIMULATION_PTR\":\n        raise NotImplementedError(\n            \"execution api entry point for 'ENSEMBLE_SIMULATION_PTR' is not available??\"\n        )\n    else:\n        swg.ExecuteSimulation_py(simulation, reset_initial_states)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.get_catchment_dot_graph","title":"<code>get_catchment_dot_graph(simulation)</code>","text":"<p>Gets a catchment representation in Graphviz DOT format</p> <p>Gets a catchment representation in Graphviz DOT format</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>a string in a notation usable by the DiagrammeR package.</p> <p>Examples:</p> <p>TODO</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def get_catchment_dot_graph(simulation):\n    \"\"\"\n    Gets a catchment representation in Graphviz DOT format\n\n    Gets a catchment representation in Graphviz DOT format\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        a string in a notation usable by the DiagrammeR package.\n\n    Examples:\n        TODO\n\n    \"\"\"\n    # Examples:\n    # &gt;&gt;&gt; # library(swift)\n    # &gt;&gt;&gt; # library('DiagrammeR')\n    # &gt;&gt;&gt; # dataId &lt;- 'MMH'\n    # &gt;&gt;&gt; # simulation &lt;- createTestCatchment(nSubareas=4, dataId=dataId, varNameDataRain='rain', varNameDataPet='evap')\n    # &gt;&gt;&gt; # DiagrammeR(getCatchmentDotGraph(simulation))\n    return swg.GetCatchmentDOTGraph_py(simulation)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.get_free_params","title":"<code>get_free_params(model_id)</code>","text":"<p>Get a default parameter set for models</p> <p>Get a default parameter set for models, as a data frame</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>Any</code> <p>an identifier for the model, e.g. 'GR5H'</p> required <p>Returns:</p> Type Description <p>a data frame with Min, Max, Value, Name</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def get_free_params(model_id):\n    \"\"\"\n    Get a default parameter set for models\n\n    Get a default parameter set for models, as a data frame\n\n    Args:\n        model_id (Any): an identifier for the model, e.g. 'GR5H'\n\n    Returns:\n        a data frame with Min, Max, Value, Name\n\n    \"\"\"\n    pSpec = None\n    if model_id == \"GR5H\":\n        pSpec = _df_from_dict(\n            Name=[\"x1\", \"x2\", \"x3\", \"x4\", \"x5\"],\n            Value=_npf([44.6, 30.0, 10.0, 14.0, 200.0]),\n            Min=_npf([1, 1, 0, 1, 1]),\n            Max=_npf([1000, 400, 1000, 240, 1000.0]),\n        )\n    elif model_id == \"GR6J\":\n        # per202 2014-09-25\n        # I take some values for the parameters from the unit tests, but the min/max bounds are PURE guesses. Q/A TBC.\n        pSpec = _df_from_dict(\n            Name=[\"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\"],\n            Value=_npf([20, -2, 10, 2, 0, 1]),\n            Min=_npf([1, -5, 0, 1, 0, 0]),\n            Max=_npf([1000, 400, 1000, 240, 1, 1]),\n        )\n    elif model_id == \"PDM\":\n        # per202 2014-11-13\n        #\n        pSpec = _df_from_dict(\n            Name=[\n                \"cmax\",\n                \"cminrat\",\n                \"b\",\n                \"be\",\n                \"kg\",\n                \"bg\",\n                \"Strat\",\n                \"k1\",\n                \"k2rat\",\n                \"kb\",\n            ],\n            Value=_npf([400, 0.5, 1.8, 1.0, 1300.0, 1.0, 0.5, 35.0, 0.3, 2.4]),\n            Min=_npf([1, 0, 0.001, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0001, 1.0]),\n            Max=_npf([3000, 1, 2.0, 2.0, 50000.0, 1.0, 1.0, 300.0, 1.0000, 2000.0]),\n        )\n    elif model_id == \"SAC\" or model_id == \"SACSMA\":\n        # rob635 2015-01-11\n        #\n        pSpec = _df_from_dict(\n            Name=[\n                \"UZTWM\",\n                \"UZFWM\",\n                \"UZK\",\n                \"PCTIM\",\n                \"ADIMP\",\n                \"RIVA\",\n                \"REXP\",\n                \"LZTWM\",\n                \"LZFSM\",\n                \"LZFPM\",\n                \"LZSK\",\n                \"LZPK\",\n                \"PFREE\",\n                \"RSERV\",\n                \"SIDE\",\n            ],\n            Value=_npf(\n                [\n                    50,\n                    40,\n                    0.245,\n                    0.01,\n                    0.00,\n                    0.01,\n                    2.00,\n                    130.0,\n                    23.0,\n                    40.0,\n                    0.043,\n                    0.009,\n                    0.10,\n                    0.30,\n                    0.00,\n                ]\n            ),\n            Min=_npf(\n                [\n                    10,\n                    5,\n                    0.100,\n                    0.00,\n                    0.00,\n                    0.00,\n                    1.00,\n                    10.0,\n                    5.0,\n                    10.0,\n                    0.001,\n                    0.001,\n                    0.00,\n                    0.00,\n                    0.00,\n                ]\n            ),\n            Max=_npf(\n                [\n                    300,\n                    150,\n                    0.750,\n                    1.00,\n                    1.00,\n                    1.00,\n                    5.00,\n                    500.0,\n                    400.0,\n                    1000.0,\n                    0.350,\n                    0.050,\n                    0.80,\n                    1.00,\n                    1.00,\n                ]\n            ),\n        )\n    elif model_id == \"GR4J\":\n        # \\\\OSM-01-MEL.it.csiro.au\\CLW_HYDROFORECAST_common\\Projects\\WIRADA_4_1\\Work\\2013_2014_Act2_Flood_Cal\\SWIFT_hourly\\C-F2+F3+F5\\South_Esk\\Output\\Out_CaliPara.txt\n        # \\\\OSM-01-MEL.it.csiro.au\\CLW_HYDROFORECAST_common\\Projects\\WIRADA_4_1\\Work\\2013_2014_Act2_Flood_Cal\\SWIFT_hourly\\C-F2+F3+F5\\South_Esk\\Setup\\Model_Parameters.txt\n        pSpec = _df_from_dict(\n            # Name                 X1             X2             X3             X4\n            # Number                1              2              3              4\n            # Fit(Y\\N)              1              1              1              1\n            # LowBound    1.00000E+00   -2.70000E+01    1.00000E+00    1.00000E+00\n            # UpBound     3.00000E+03    2.70000E+01    6.60000E+02    2.40000E+02\n            # #-Calibrated parameters-----------------------------------------------------------------\n            # Chmt_001    6.50488E+02   -2.80648E-01    7.89123E+00    1.89172E+01\n            Name=[\"x1\", \"x2\", \"x3\", \"x4\"],\n            Value=_npf([6.50488e02, -2.80648e-01, 7.89123e00, 1.89172e01]),\n            Min=_npf([1, -27, 1, 1]),\n            Max=_npf([3.00000e03, 2.70000e01, 6.60000e02, 2.40000e02]),\n        )\n    elif model_id == \"SAC\" or model_id == \"SACSMA\":\n        # rob635 2015-01-11\n        #\n        pSpec = _df_from_dict(\n            Name=[\n                \"UZTWM\",\n                \"UZFWM\",\n                \"UZK\",\n                \"PCTIM\",\n                \"ADIMP\",\n                \"RIVA\",\n                \"REXP\",\n                \"LZTWM\",\n                \"LZFSM\",\n                \"LZFPM\",\n                \"LZSK\",\n                \"LZPK\",\n                \"PFREE\",\n                \"RSERV\",\n                \"SIDE\",\n            ],\n            Value=_npf(\n                [\n                    50,\n                    40,\n                    0.245,\n                    0.01,\n                    0.00,\n                    0.01,\n                    2.00,\n                    130.0,\n                    23.0,\n                    40.0,\n                    0.043,\n                    0.009,\n                    0.10,\n                    0.30,\n                    0.00,\n                ]\n            ),\n            Min=_npf(\n                [\n                    10,\n                    5,\n                    0.100,\n                    0.00,\n                    0.00,\n                    0.00,\n                    1.00,\n                    10.0,\n                    5.0,\n                    10.0,\n                    0.001,\n                    0.001,\n                    0.00,\n                    0.00,\n                    0.00,\n                ]\n            ),\n            Max=_npf(\n                [\n                    300,\n                    150,\n                    0.750,\n                    1.00,\n                    1.00,\n                    1.00,\n                    5.00,\n                    500.0,\n                    400.0,\n                    1000.0,\n                    0.350,\n                    0.050,\n                    0.80,\n                    1.00,\n                    1.00,\n                ]\n            ),\n        )\n    else:\n        raise Exception(\"Model identifier not recognised: \" + model_id)\n    return pSpec\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.get_link_ids","title":"<code>get_link_ids(simulation)</code>","text":"<p>Gets all the identifiers of the links in the catchment</p> <p>Gets all the identifiers of the links in the catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The identifiers of the links in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_link_ids(simulation):\n    \"\"\"\n    Gets all the identifiers of the links in the catchment\n\n    Gets all the identifiers of the links in the catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The identifiers of the links in the catchment\n\n    \"\"\"\n    return swg.GetLinkIdentifiers_py(simulation)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.get_link_names","title":"<code>get_link_names(simulation)</code>","text":"<p>Gets all the names of the links in the catchment</p> <p>Gets all the names of the links in the catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The names of the links in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_link_names(simulation):\n    \"\"\"\n    Gets all the names of the links in the catchment\n\n    Gets all the names of the links in the catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The names of the links in the catchment\n\n    \"\"\"\n\n    return swg.GetLinkNames_py(simulation)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.get_node_ids","title":"<code>get_node_ids(simulation)</code>","text":"<p>Gets all the identifiers of the nodes in the catchment</p> <p>Gets all the identifiers of the nodes in the catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The identifiers of the nodes in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_node_ids(simulation):\n    \"\"\"\n    Gets all the identifiers of the nodes in the catchment\n\n    Gets all the identifiers of the nodes in the catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The identifiers of the nodes in the catchment\n\n    \"\"\"\n    return swg.GetNodeIdentifiers_py(simulation)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.get_node_names","title":"<code>get_node_names(simulation)</code>","text":"<p>Gets all the names of the nodes in the catchment</p> <p>Gets all the names of the nodes in the catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The names of the nodes in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_node_names(simulation):\n    \"\"\"\n    Gets all the names of the nodes in the catchment\n\n    Gets all the names of the nodes in the catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The names of the nodes in the catchment\n\n    \"\"\"\n    return swg.GetNodeNames_py(simulation)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.get_state_value","title":"<code>get_state_value(simulation, var_id)</code>","text":"<p>Gets the value(s) of a model state(s)</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>var_id</code> <code>VecStr</code> <p>string or sequence of str, model variable state identifier(s)</p> required <p>Returns:</p> Type Description <p>numeric vector, value(s) of the requested model states</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_state_value(simulation: \"Simulation\", var_id: \"VecStr\"):\n    \"\"\"\n    Gets the value(s) of a model state(s)\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        var_id (VecStr): string or sequence of str, model variable state identifier(s)\n\n    Returns:\n        numeric vector, value(s) of the requested model states\n\n    \"\"\"\n    if isinstance(var_id, str):\n        var_ids = [var_id]\n    else:\n        var_ids = var_id\n    #  if(is.numeric(value)):\n    f = swg.GetVariable_py\n    #  } else if(is.integer(value)):\n    #    f = GetVariableInt_R\n    #  } else if(is.logical(value)):\n    #    f = GetVariableBool_R\n    #  else:\n    #    stop(paste('value type', type(value), 'is not supported by getStateValue'))\n    #  }\n    return dict([(v, f(simulation, v)) for v in var_ids])\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.get_subarea_ids","title":"<code>get_subarea_ids(simulation)</code>","text":"<p>Gets all the identifiers of the sub-areas in the catchment</p> <p>Gets all the identifiers of the sub-areas in the catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The identifiers of the sub-areas in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_subarea_ids(simulation):\n    \"\"\"\n    Gets all the identifiers of the sub-areas in the catchment\n\n    Gets all the identifiers of the sub-areas in the catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The identifiers of the sub-areas in the catchment\n\n    \"\"\"\n    return swg.GetSubareaIdentifiers_py(simulation)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.get_subarea_names","title":"<code>get_subarea_names(simulation)</code>","text":"<p>Gets all the names of the sub-areas in the catchment</p> <p>Gets all the names of the sub-areas in the catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The names of the sub-areas in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_subarea_names(simulation):\n    \"\"\"\n    Gets all the names of the sub-areas in the catchment\n\n    Gets all the names of the sub-areas in the catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The names of the sub-areas in the catchment\n\n    \"\"\"\n\n    return swg.GetSubareaNames_py(simulation)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.get_variable_ids","title":"<code>get_variable_ids(simulation, element_id=None, full_id=True)</code>","text":"<p>Gets all the names of the variables of an element within a catchment</p> <p>Gets all the names of the variables of an element (link, node, subarea) within a catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>element_id</code> <code>Any</code> <p>a character, identifier of the element within the catchment</p> <code>None</code> <code>full_id</code> <code>Any</code> <p>boolean, if TRUE return the full hierarchical identifier</p> <code>True</code> <p>Returns:</p> Type Description <p>character vector, names (identifiers) of model states in the element</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_variable_ids(simulation: \"Simulation\", element_id=None, full_id=True):\n    \"\"\"\n    Gets all the names of the variables of an element within a catchment\n\n    Gets all the names of the variables of an element (link, node, subarea) within a catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        element_id (Any): a character, identifier of the element within the catchment\n        full_id (Any): boolean, if TRUE return the full hierarchical identifier\n\n    Returns:\n        character vector, names (identifiers) of model states in the element\n\n    \"\"\"\n    s = swg.GetElementVarIdentifiers_py(simulation, element_id)\n    if full_id and element_id is not None:\n        s = [_mkid(element_id, v) for v in s]\n    return s\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.gr4j_scaled_parameteriser","title":"<code>gr4j_scaled_parameteriser(reference_area=240, t_step_seconds=3600)</code>","text":"<p>Get a time step and area scaled parameterizer for the GR4 model structure</p> <p>Get a time step and area scaled parameterizer for the GR4 model structure</p> <p>Parameters:</p> Name Type Description Default <code>reference_area</code> <code>Any</code> <p>The reference area in km^2 for the parameter x4</p> <code>240</code> <code>t_step_seconds</code> <code>Any</code> <p>The simulation time step in seconds.</p> <code>3600</code> <p>Returns:</p> Type Description <p>A SWIFT catchment parameterizer for GR4 model structures</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def gr4j_scaled_parameteriser(reference_area: float = 240, t_step_seconds: int = 3600):\n    \"\"\"\n    Get a time step and area scaled parameterizer for the GR4 model structure\n\n    Get a time step and area scaled parameterizer for the GR4 model structure\n\n    Args:\n        reference_area (Any): The reference area in km^2 for the parameter x4\n        t_step_seconds (Any): The simulation time step in seconds.\n\n    Returns:\n        A SWIFT catchment parameterizer for GR4 model structures\n\n    \"\"\"\n    return swg.CreateGr4ScaledParameterizer_py(reference_area, t_step_seconds)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.inspect","title":"<code>inspect(simulation, element='link', id='1', full_names=False)</code>","text":"<p>Inspect an element of a catchment model</p> <p>Inspect the current state values of an element of a catchment model</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>element</code> <code>Any</code> <p>type of top level element, within c('link','node','subarea')</p> <code>'link'</code> <code>id</code> <code>Any</code> <p>SWIFT simulation</p> <code>'1'</code> <code>full_names</code> <code>Any</code> <p>if TRUE returns the full names of state variable ids (e.g. link.link_1.OutlfowRate)</p> <code>False</code> <p>Returns:</p> Type Description <p>named numeric vector, the current state values of the catchment model element</p> <p>Examples:</p> <p>TODO</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def inspect(simulation: \"Simulation\", element=\"link\", id=\"1\", full_names=False):\n    \"\"\"\n    Inspect an element of a catchment model\n\n    Inspect the current state values of an element of a catchment model\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        element (Any): type of top level element, within c('link','node','subarea')\n        id (Any): SWIFT simulation\n        full_names (Any): if TRUE returns the full names of state variable ids (e.g. link.link_1.OutlfowRate)\n\n    Returns:\n        named numeric vector, the current state values of the catchment model element\n\n    Examples:\n        TODO\n    \"\"\"\n    # Examples:\n    #     &gt;&gt;&gt; # ms &lt;- createTestCatchmentStructure()$model\n    #     &gt;&gt;&gt; # inspect(ms, element='link', id='lnk1')\n    #     &gt;&gt;&gt; # inspect(ms, element='subarea', id='lnk1')\n    #     &gt;&gt;&gt; # inspect(ms, element='subarea', id='lnk1', fullNames=TRUE)\n    all_f_ids = get_variable_ids(simulation, mk_full_data_id(element, id), full_id=True)\n    all_f_ids = np.sort([s for s in set(all_f_ids)])\n    x = get_state_value(simulation, all_f_ids)\n\n    def last_in_vec(v):\n        if len(v) &gt; 0:\n            return v[-1]\n        else:\n            return \"\"\n\n    if not full_names:\n        new_k = dict([(k, last_in_vec(k.split(\".\"))) for k in x.keys()])\n        # if len(new_k) != len(set(new_k)): raise Exception()\n        new_x = dict([(new_k[k], x[k]) for k in x.keys()])\n        x = new_x\n    return x\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.is_common_iterable","title":"<code>is_common_iterable(obj)</code>","text":"<p>True if an object is iterable but not a string (str)</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/utils.py</code> <pre><code>def is_common_iterable(obj: Any) -&gt; bool:\n    \"\"\"True if an object is iterable but not a string (str)\"\"\"\n    if isinstance(obj, str):\n        return False\n    # if isinstance(obj, np.ndarray) and obj.size == 1:\n    #     return False # otherwise likely to get error \"len() of unsized object\"\n    return hasattr(type(obj), \"__iter__\")\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.is_variable_id","title":"<code>is_variable_id(simulation, var_id)</code>","text":"<p>Is a variable identifier valid for a simulation</p> <p>Is a variable identifier valid for a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>var_id</code> <code>Any</code> <p>a character, identifier(s) of the variable(s)</p> required <p>Returns:</p> Type Description <p>logical vector</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def is_variable_id(simulation: \"Simulation\", var_id: \"VecStr\"):\n    \"\"\"\n    Is a variable identifier valid for a simulation\n\n    Is a variable identifier valid for a simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        var_id (Any): a character, identifier(s) of the variable(s)\n\n    Returns:\n        logical vector\n\n    \"\"\"\n    if is_common_iterable(var_id):\n        return dict(\n            [(v, swg.IsValidVariableIdentifier_py(simulation, v)) for v in var_id]\n        )\n    else:\n        return swg.IsValidVariableIdentifier_py(simulation, var_id)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.paste0","title":"<code>paste0(*lists, collapse=None)</code>","text":"<p>Port of R paste0 function</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/utils.py</code> <pre><code>def paste0(*lists, collapse=None):\n    \"\"\"Port of R paste0 function\"\"\"\n    return paste(*lists, sep=\"\", collapse=collapse)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.play_subarea_input","title":"<code>play_subarea_input(simulation, input, subarea_name, input_name)</code>","text":"<p>Sets time series as input to a simulation</p> <p>Sets time series as input to a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>input</code> <code>Any</code> <p>an xts time series.</p> required <code>subarea_name</code> <code>Any</code> <p>a valid name of the subarea</p> required <code>input_name</code> <code>Any</code> <p>the name of the input variable to the model (i.e. 'P' for the precip of GR5H)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/play_record.py</code> <pre><code>def play_subarea_input(simulation: \"Simulation\", input, subarea_name, input_name):\n    \"\"\"\n    Sets time series as input to a simulation\n\n    Sets time series as input to a simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        input (Any): an xts time series.\n        subarea_name (Any): a valid name of the subarea\n        input_name (Any): the name of the input variable to the model (i.e. 'P' for the precip of GR5H)\n\n    \"\"\"\n    play_input(simulation, input, _mkid(\"subarea\", subarea_name, input_name))\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.reset_model_states","title":"<code>reset_model_states(simulation)</code>","text":"<p>Reset the model states of a simulation, and apply one or more state initialers if the simulation is configured with any.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>simulation</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def reset_model_states(simulation: \"Simulation\"):\n    \"\"\"Reset the model states of a simulation, and apply one or more state initialers if the simulation is configured with any.\n\n    Args:\n        simulation (Simulation): simulation\n    \"\"\"\n    swg.ResetModelStates_py(simulation)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.sample_catchment_model","title":"<code>sample_catchment_model(site_id='South_Esk', config_id='catchment')</code>","text":"<p>Deserialize a basic catchment structure from the package sample data</p> <p>Deserialize a basic catchment structure from the package sample data. This function is mostly for documentation purposes.</p> <p>Parameters:</p> Name Type Description Default <code>site_id</code> <code>Any</code> <p>a site identifier</p> <code>'South_Esk'</code> <code>config_id</code> <code>Any</code> <p>a variable identifier for a model structure valid for the given site_id</p> <code>'catchment'</code> <p>Returns:</p> Type Description <p>a model simulation</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def sample_catchment_model(site_id=\"South_Esk\", config_id=\"catchment\"):\n    \"\"\"\n    Deserialize a basic catchment structure from the package sample data\n\n    Deserialize a basic catchment structure from the package sample data. This function is mostly for documentation purposes.\n\n    Args:\n        site_id (Any): a site identifier\n        config_id (Any): a variable identifier for a model structure valid for the given site_id\n\n    Returns:\n        a model simulation\n\n    \"\"\"\n    # if not exists('swiftSampleData')) data(swift_sample_data)\n    s = _sample_data()\n    site_data: Dict = s[site_id]\n    if config_id not in site_data.keys():\n        raise ValueError(\n            \"Sample catchment model for site \"\n            + site_id\n            + \" identified by \"\n            + config_id\n            + \" not found\"\n        )\n    cat_structure = site_data[config_id]\n    return create_catchment_model_from_structure(cat_structure)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.sample_series","title":"<code>sample_series(site_id='MMH', var_name='rain')</code>","text":"<p>Deserialize information to a UTC time series</p> <p>Deserialize information to a UTC time series. This function is overcoming some behaviors in saving/loading xts series to/from binary RData format. Usage is not intended for most users.</p> <p>Parameters:</p> Name Type Description Default <code>site_id</code> <code>Any</code> <p>a site identifier</p> <code>'MMH'</code> <code>var_name</code> <code>Any</code> <p>a variable identifier valid for the given site_id</p> <code>'rain'</code> <p>Returns:</p> Type Description <p>an xts time series with UTC time indexing</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def sample_series(site_id=\"MMH\", var_name=\"rain\"):\n    \"\"\"\n    Deserialize information to a UTC time series\n\n    Deserialize information to a UTC time series. This function is overcoming some behaviors in saving/loading xts series to/from binary RData format. Usage is not intended for most users.\n\n    Args:\n        site_id (Any): a site identifier\n        var_name (Any): a variable identifier valid for the given site_id\n\n    Returns:\n        an xts time series with UTC time indexing\n\n    \"\"\"\n    s = _sample_data()\n    siteData = s[site_id]\n    if var_name not in siteData.keys():\n        keys = list(siteData.keys())\n        kstring = ', '.join(keys)\n        raise KeyError(f\"key {var_name} not found. Valid keys are {kstring}\")\n    varData = siteData[var_name]\n    # if (varData)) stop(paste('Sample data for site', site_id, 'and variable name', var_name, 'not found'))\n    return deserialise_sample_series(varData)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.sce_parameter","title":"<code>sce_parameter(nparams, nshuffle=40)</code>","text":"<p>Create SCE parameters suited for a given number of parameters.</p> <p>Parameters:</p> Name Type Description Default <code>nparams</code> <code>int</code> <p>number of free model parameters</p> required <code>nshuffle</code> <code>int</code> <p>maximum number of shuffles to do, if no other termination criterion. Defaults to 40.</p> <code>40</code> <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dict[str,float]: SCE hyperparameters</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def sce_parameter(nparams: int, nshuffle: int = 40) -&gt; Dict[str, float]:\n    \"\"\"Create SCE parameters suited for a given number of parameters.\n\n    Args:\n        nparams (int): number of free model parameters\n        nshuffle (int, optional): maximum number of shuffles to do, if no other termination criterion. Defaults to 40.\n\n    Returns:\n        Dict[str,float]: SCE hyperparameters\n    \"\"\"\n    sce_params = get_default_sce_parameters()\n    sce_params[\"P\"] = nparams + 2\n    sce_params[\"Pmin\"] = nparams + 2\n    sce_params[\"M\"] = 2 * nparams + 1\n    sce_params[\"Q\"] = max(sce_params[\"M\"] - 2, 2)\n    sce_params[\"NumShuffle\"] = nshuffle\n    return sce_params\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.set_error_correction_model","title":"<code>set_error_correction_model(simulation, model_id, element_id, length=1, seed=0)</code>","text":"<p>Add an error correction model to an element in a catchment</p> <p>Add an error correction model to an element in a catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>model_id</code> <code>str</code> <p>the identifier of the new model to use, e.g. 'ERRIS'</p> required <code>element_id</code> <code>str</code> <p>the identifier of the catchment element (node, link, subcatchment) whose outflow rate is corrected.</p> required <code>length</code> <code>int</code> <p>other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.</p> <code>1</code> <code>seed</code> <code>int</code> <p>other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.</p> <code>0</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def set_error_correction_model(\n    simulation, model_id, element_id, length=1, seed=0\n):  # TODO: revert to use ... if other kind of ECM\n    \"\"\"\n    Add an error correction model to an element in a catchment\n\n    Add an error correction model to an element in a catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        model_id (str): the identifier of the new model to use, e.g. 'ERRIS'\n        element_id (str): the identifier of the catchment element (node, link, subcatchment) whose outflow rate is corrected.\n        length (int): other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.\n        seed (int): other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.\n\n    \"\"\"\n    swg.SetErrorCorrectionModel_py(simulation, model_id, element_id, length, seed)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.set_loglik_param_keys","title":"<code>set_loglik_param_keys(a='a', b='b', m='m', s='s', maxobs='maxobs', ct='ct', censopt='CensOpt')</code>","text":"<p>Specify the global parameter names to use in the log-likelihood calculation</p> <p>Specify the global parameter names to use in the log-likelihood calculation. Consequence of prehistoric legacy.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str</code> <p>the name of the a parameter</p> <code>'a'</code> <code>b</code> <code>str</code> <p>the name of the b parameter</p> <code>'b'</code> <code>m</code> <code>str</code> <p>the name of the m parameter</p> <code>'m'</code> <code>s</code> <code>str</code> <p>the name of the s parameter</p> <code>'s'</code> <code>maxobs</code> <code>str</code> <p>the name of the maxobs parameter</p> <code>'maxobs'</code> <code>ct</code> <code>str</code> <p>the name of the ct parameter</p> <code>'ct'</code> <code>censopt</code> <code>str</code> <p>the name of the censopt parameter</p> <code>'CensOpt'</code> <p>Examples:</p> <p>TODO</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def set_loglik_param_keys(\n    a=\"a\", b=\"b\", m=\"m\", s=\"s\", maxobs=\"maxobs\", ct=\"ct\", censopt=\"CensOpt\"\n):\n    \"\"\"\n    Specify the global parameter names to use in the log-likelihood calculation\n\n    Specify the global parameter names to use in the log-likelihood calculation. Consequence of prehistoric legacy.\n\n    Args:\n        a (str): the name of the a parameter\n        b (str): the name of the b parameter\n        m (str): the name of the m parameter\n        s (str): the name of the s parameter\n        maxobs (str): the name of the maxobs parameter\n        ct (str): the name of the ct parameter\n        censopt (str): the name of the censopt parameter\n\n    Examples:\n        TODO\n    \"\"\"\n    # Examples:\n    #     &gt;&gt;&gt; # set_loglik_param_keys('lambda', 'epsilon', 'm', 's')\n    #     &gt;&gt;&gt; # pSpecGr4j = get_free_params('GR4J')\n    #     &gt;&gt;&gt; # # pSpecGr4j$Value = c(542.1981111, -0.4127542, 7.7403390, 1.2388548)\n    #     &gt;&gt;&gt; # # pSpecGr4j$Min = c(1,-30, 1,1)\n    #     &gt;&gt;&gt; # # pSpecGr4j$Max = c(3000, 30, 1000, 240)\n    #     &gt;&gt;&gt; # # pSpecGr4j$Name = paste0(rootId, pSpecGr4j$Name)\n    #     &gt;&gt;&gt; # pgr4 = create_parameterizer(type='Generic', specs=pSpecGr4j)\n    #     &gt;&gt;&gt; # p = create_parameterizer(type='log-likelihood')\n    #     &gt;&gt;&gt; # p.add(\"epsilon\", -30, 0, -7)\n    #     &gt;&gt;&gt; # p.add(\"m\", 0, 0, 0)\n    #     &gt;&gt;&gt; # p.add(\"s\", 1, 1000, 100)\n    #     &gt;&gt;&gt; # p.add(\"lambda\", -30, 1, -10)\n    #     &gt;&gt;&gt; # parameterizer = concatenate_parameterisers(pgr4, p)\n    #     &gt;&gt;&gt; # print(parameterizer)\n    swg.SetLogLikelihoodVariableNames_py(a, b, m, s, maxobs, ct, censopt)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.set_sample_data","title":"<code>set_sample_data(model_sim, site_id='MMH', rain_data_var='rain', evap_data_var='evap', rain_model_var='P', evap_model_var='E', t_step='daily')</code>","text":"<p>Sets sample input data into a model simulation</p> <p>Sets input data from the included sample data into a model simulation</p> <p>Parameters:</p> Name Type Description Default <code>model_sim</code> <code>Any</code> <p>an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"MODEL_SIMULATION_PTR\"</p> required <code>site_id</code> <code>Any</code> <p>sample data site identifier</p> <code>'MMH'</code> <code>rain_data_var</code> <code>Any</code> <p>time series ID for the rainfall in the sample data</p> <code>'rain'</code> <code>evap_data_var</code> <code>Any</code> <p>time series ID for the evaporation in the sample data</p> <code>'evap'</code> <code>rain_model_var</code> <code>Any</code> <p>sub-area runoff model state identifier for the rainfall, e.g. 'P'</p> <code>'P'</code> <code>evap_model_var</code> <code>Any</code> <p>sub-area runoff model state identifier for the evaporation, e.g. 'E'</p> <code>'E'</code> <code>t_step</code> <code>Any</code> <p>identifier for the time step to set the simulation to.</p> <code>'daily'</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def set_sample_data(\n    model_sim,\n    site_id=\"MMH\",\n    rain_data_var=\"rain\",\n    evap_data_var=\"evap\",\n    rain_model_var=\"P\",\n    evap_model_var=\"E\",\n    t_step=\"daily\",\n):\n    \"\"\"\n    Sets sample input data into a model simulation\n\n    Sets input data from the included sample data into a model simulation\n\n    Args:\n        model_sim (Any): an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"MODEL_SIMULATION_PTR\"\n        site_id (Any): sample data site identifier\n        rain_data_var (Any): time series ID for the rainfall in the sample data\n        evap_data_var (Any): time series ID for the evaporation in the sample data\n        rain_model_var (Any): sub-area runoff model state identifier for the rainfall, e.g. 'P'\n        evap_model_var (Any): sub-area runoff model state identifier for the evaporation, e.g. 'E'\n        t_step (Any): identifier for the time step to set the simulation to.\n\n    \"\"\"\n\n    rain = sample_series(site_id, var_name=rain_data_var)\n    evap = sample_series(site_id, var_name=evap_data_var)\n    sa_ids = get_subarea_ids(model_sim)\n    for sa_id in sa_ids:\n        play_subarea_input(model_sim, rain, sa_id, rain_model_var)\n        play_subarea_input(model_sim, evap, sa_id, evap_model_var)\n    set_simulation_time_step(model_sim, t_step)\n    set_simulation_span(model_sim, start_ts(rain), end_ts(rain))\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.set_simulation_span","title":"<code>set_simulation_span(simulation, start, end)</code>","text":"<p>Sets simulation span</p> <p>Sets the simulation span</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>start</code> <code>Any</code> <p>the start date of the simulation. The time zone will be forced to UTC.</p> required <code>end</code> <code>Any</code> <p>the end date of the simulation. The time zone will be forced to UTC.</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def set_simulation_span(simulation: \"Simulation\", start, end):\n    \"\"\"\n    Sets simulation span\n\n    Sets the simulation span\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        start (Any): the start date of the simulation. The time zone will be forced to UTC.\n        end (Any): the end date of the simulation. The time zone will be forced to UTC.\n\n    \"\"\"\n    s = as_timestamp(start)  # = as_timestamp(start, tz='UTC')\n    e = as_timestamp(end)  # = as_timestamp(end, tz='UTC')\n    swg.SetSpan_py(simulation, s, e)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.set_simulation_time_step","title":"<code>set_simulation_time_step(simulation, name)</code>","text":"<p>Sets the time step of a SWIFT simulation</p> <p>Sets the time step of a SWIFT simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>name</code> <code>Any</code> <p>a time step identifier, The identifier is made lower case in the function. Supported time steps include \"hourly\", \"daily\", \"monthly_qpp\", \"monthly\", and time deltas such as \"24:00:00\", \"01:00:00\", \"03:00:00\". An exception is raised if the string could not be parsed.</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def set_simulation_time_step(simulation: \"Simulation\", name: str):\n    \"\"\"\n    Sets the time step of a SWIFT simulation\n\n    Sets the time step of a SWIFT simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        name (Any): a time step identifier, The identifier is made lower case in the function. Supported time steps include \"hourly\", \"daily\", \"monthly_qpp\", \"monthly\", and time deltas such as \"24:00:00\", \"01:00:00\", \"03:00:00\". An exception is raised if the string could not be parsed.\n\n    \"\"\"\n    name = name.lower()\n    # assert name in set(['daily','hourly'])\n    swg.SetTimeStep_py(simulation, name)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.set_state_value","title":"<code>set_state_value(simulation, var_id, value)</code>","text":"<p>Sets the value of a model state</p> <p>Sets the value of a model state</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>var_id</code> <code>(str, Sequence[str])</code> <p>character, model variable state identifier(s)</p> required <code>value</code> <code>(float, int, bool, Sequence)</code> <p>numeric value(s)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def set_state_value(\n    simulation: \"Simulation\",\n    var_id: Union[str, Sequence[str]],\n    value: Union[float, int, bool, Sequence],\n) -&gt; None:\n    \"\"\"\n    Sets the value of a model state\n\n    Sets the value of a model state\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        var_id (str, Sequence[str]): character, model variable state identifier(s)\n        value (float, int, bool, Sequence): numeric value(s)\n\n    \"\"\"\n\n    def func_set_for(v):\n        if isinstance(v, float): # or isinstance(v, np.float): # np obsolete?\n            return swg.SetVariable_py\n        elif isinstance(v, int): # or isinstance(v, np.int):\n            return swg.SetVariableInt_py\n        elif isinstance(v, bool): # or isinstance(v, np.bool8):\n            return swg.SetVariableBool_py\n        else:\n            raise TypeError(\n                \"value type \" + str(type(v)) + \"is not supported by setStateValue\"\n            )\n\n    if isinstance(var_id, str):\n        f = func_set_for(value)\n        f(simulation, var_id, value)\n        return\n    if isinstance(var_id, dict):\n        d = [(k, v) for k, v in var_id.items()]\n        var_id = [x[0] for x in d]\n        value = [x[1] for x in d]\n    if not is_common_iterable(var_id):\n        raise ValueError(\"var_id must be a string, or an iterable of strings\")\n    if not is_common_iterable(value):\n        value = rep(value, len(var_id))\n    else:\n        assert len(var_id) == len(value)\n\n    for i in range(len(var_id)):\n        k = var_id[i]\n        v = value[i]\n        f = func_set_for(v)\n        f(simulation, k, v)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.set_states","title":"<code>set_states(simulation, states)</code>","text":"<p>Apply memory states to a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>simulation</p> required <code>states</code> <code>MemoryStates</code> <p>memory states</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def set_states(simulation: \"Simulation\", states: \"MemoryStates\"):\n    \"\"\"Apply memory states to a simulation\n\n    Args:\n        simulation (Simulation): simulation\n        states (MemoryStates): memory states\n    \"\"\"\n    swg.ApplyMemoryStates_py(simulation, states)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.short_var_id","title":"<code>short_var_id(var_ids)</code>","text":"<p>Shorten long model variable identifiers to the short model variable name</p> <p>Shorten long model variable identifiers to the short model variable name. This is useful for instance to prepare time series names for multi-plot displays.</p> <p>Parameters:</p> Name Type Description Default <code>var_ids</code> <code>Any</code> <p>character vector</p> required <p>Returns:</p> Type Description <code>VecStr</code> <p>the short model variable identifiers</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; short_var_id('elementtype|elementname|varid')\n&gt;&gt;&gt; short_var_id('elementtype.elementname.varid')\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/swift2/doc_helper.py</code> <pre><code>def short_var_id(var_ids: \"VecStr\") -&gt; \"VecStr\":\n    \"\"\"\n    Shorten long model variable identifiers to the short model variable name\n\n    Shorten long model variable identifiers to the short model variable name. This is useful for instance to prepare time series names for multi-plot displays.\n\n    Args:\n        var_ids (Any): character vector\n\n    Returns:\n        the short model variable identifiers\n\n    Examples:\n        &gt;&gt;&gt; short_var_id('elementtype|elementname|varid')\n        &gt;&gt;&gt; short_var_id('elementtype.elementname.varid')\n\n    \"\"\"\n    if is_common_iterable(var_ids):\n        return [short_var_id(v) for v in var_ids]\n    else:\n        return var_ids.split(\"|\")[-1].split[\".\"][-1]\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.snapshot_state","title":"<code>snapshot_state(simulation)</code>","text":"<p>Take a snapshot of the memory states of a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>model simulation</p> required <p>Returns:</p> Name Type Description <code>MemoryStates</code> <code>MemoryStates</code> <p>memory states, that can be stored and reapplied</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def snapshot_state(simulation: \"Simulation\") -&gt; \"MemoryStates\":\n    \"\"\"Take a snapshot of the memory states of a simulation\n\n    Args:\n        simulation (Simulation): model simulation\n\n    Returns:\n        MemoryStates: memory states, that can be stored and reapplied\n    \"\"\"\n    return swg.SnapshotMemoryStates_py(simulation)\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.sort_by_execution_order","title":"<code>sort_by_execution_order(simulation, split_element_ids, sorting_option='')</code>","text":"<p>Sort the specified element ids according to the execution order of the simulation</p> <p>Sort the specified element ids according to the execution order of the simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>split_element_ids</code> <code>Any</code> <p>a character vector with element identifiers such as 'node.n1', 'link.linkId_2'</p> required <code>sorting_option</code> <code>Any</code> <p>a character - for future options. Ignored for now.</p> <code>''</code> <p>Returns:</p> Type Description <p>values in split_element_ids sorted by simulation execution order</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def sort_by_execution_order(\n    simulation: \"Simulation\", split_element_ids, sorting_option=\"\"\n):\n    \"\"\"\n    Sort the specified element ids according to the execution order of the simulation\n\n    Sort the specified element ids according to the execution order of the simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        split_element_ids (Any): a character vector with element identifiers such as 'node.n1', 'link.linkId_2'\n        sorting_option (Any): a character - for future options. Ignored for now.\n\n    Returns:\n        values in split_element_ids sorted by simulation execution order\n\n    \"\"\"\n    return swc.sort_simulation_elements_by_run_order_pkg(\n        simulation, split_element_ids, sorting_option\n    )\n</code></pre>"},{"location":"doc_helper/#swift2.doc_helper.swap_model","title":"<code>swap_model(simulation, model_id, what='runoff')</code>","text":"<p>Clone and change a simulation, using another runoff model</p> <p>Clone and change a simulation, using another runoff model</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>model_id</code> <code>Any</code> <p>the identifier of the new model to use, e.g. 'GR4J'</p> required <code>what</code> <code>Any</code> <p>character identifying the type of structure: 'runoff', 'channel_routing'</p> <code>'runoff'</code> <p>Returns:</p> Type Description <p>A SWIFT simulation object, clone of the simulation but with a new model type in use.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def swap_model(simulation: \"Simulation\", model_id, what=\"runoff\"):\n    \"\"\"\n    Clone and change a simulation, using another runoff model\n\n    Clone and change a simulation, using another runoff model\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        model_id (Any): the identifier of the new model to use, e.g. 'GR4J'\n        what (Any): character identifying the type of structure: 'runoff', 'channel_routing'\n\n    Returns:\n        A SWIFT simulation object, clone of the simulation but with a new model type in use.\n\n    \"\"\"\n    if what == \"runoff\":\n        cloned = swg.SwapRunoffModel_py(simulation, model_id)\n    elif what == \"channel_routing\":\n        cloned = swg.CloneModel_py(simulation)\n        swg.SetChannelRoutingModel_py(cloned, model_id)\n    else:\n        raise ValueError(f\"option not supported: {what}\")\n    return cloned\n</code></pre>"},{"location":"helpers/","title":"Module helpers","text":""},{"location":"internal/","title":"Module internal","text":""},{"location":"internal/#swift2.internal.simplify_time_series","title":"<code>simplify_time_series(input_ts)</code>","text":"<p>simplify a 1D time series object to a representation suitable for portable serialisation.</p> <p>Parameters:</p> Name Type Description Default <code>input_ts</code> <code>TimeSeriesLike</code> <p>time series</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str,Any]: dictionary with keys \"tsgeom\" for the time series geometry, and \"tsvalues\" for its values.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/internal.py</code> <pre><code>def simplify_time_series(input_ts: TimeSeriesLike) -&gt; Dict[str, Any]:\n    \"\"\"simplify a 1D time series object to a representation suitable for portable serialisation.\n\n    Args:\n        input_ts (TimeSeriesLike): time series\n\n    Returns:\n        Dict[str,Any]: dictionary with keys \"tsgeom\" for the time series geometry, and \"tsvalues\" for its values.\n\n    \"\"\"\n    # from cinterop.timeseries import getTsGeometry\n    # stopifnot(is.xts(input_ts))\n    # def getSeriesColumn(k):\n    #     return(as.numeric(input_ts[,k]))\n    return {\n        TS_INTEROP_GEOM_KEY: marshal.as_native_tsgeom(get_tsgeom(input_ts)),\n        TS_INTEROP_VALUES_KEY: input_ts.values.squeeze(),  # lapply(1:ncol(input_ts), FUN=getSeriesColumn)\n    }\n</code></pre>"},{"location":"internal/#swift2.internal.to_interop_univariate_series","title":"<code>to_interop_univariate_series(ts, from_date=None, to_date=None)</code>","text":"<p>Convert an univariate python time series to a representation suitable for interoperability with a C API</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>TimeSeriesLike</code> <p>Python native time series</p> required <code>from_date</code> <code>ConvertibleToTimestamp</code> <p>start timestamp of the time series to subset to. Defaults to None.</p> <code>None</code> <code>to_date</code> <code>ConvertibleToTimestamp</code> <p>end timestamp of the time series to subset to. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, TimeSeriesGeometryNative]</code> <p>Tuple[np.ndarray, TimeSeriesGeometryNative]: univeriate data and time series geometry for interop.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/internal.py</code> <pre><code>def to_interop_univariate_series(\n    ts: TimeSeriesLike,\n    from_date: ConvertibleToTimestamp = None,\n    to_date: ConvertibleToTimestamp = None,\n) -&gt; Tuple[np.ndarray, TimeSeriesGeometryNative]:\n    \"\"\"Convert an univariate python time series to a representation suitable for interoperability with a C API\n\n    Args:\n        ts (TimeSeriesLike): Python native time series\n        from_date (ConvertibleToTimestamp, optional): start timestamp of the time series to subset to. Defaults to None.\n        to_date (ConvertibleToTimestamp, optional): end timestamp of the time series to subset to. Defaults to None.\n\n    Returns:\n        Tuple[np.ndarray, TimeSeriesGeometryNative]: univeriate data and time series geometry for interop.\n    \"\"\"\n    from cinterop.timeseries import ts_window\n    from swift2.internal import simplify_time_series\n\n    from_date = as_timestamp(from_date) if not from_date is None else None\n    to_date = as_timestamp(to_date) if not from_date is None else None\n    observation = ts_window(ts, from_date, to_date)\n    simple_ts = simplify_time_series(observation)\n    return (simple_ts[TS_INTEROP_VALUES_KEY], simple_ts[TS_INTEROP_GEOM_KEY])\n</code></pre>"},{"location":"license/","title":"License","text":"<pre><code>Terms: \"Software\" covers the python files, documentation, jupyter notebooks, in the \"swift2\" python package. The native library \"swift\" is not included in this definition of \"Software\" for the purpose of this present license. \n</code></pre> <pre><code>The Software is copyright (c) Commonwealth Scientific and Industrial Research Organisation (CSIRO) ABN 41 687 119 230.\n\nCSIRO grants you a licence to the Software on the terms of the BSD 3-Clause Licence.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n    1- Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n    2- Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n    3- Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</code></pre>"},{"location":"model_definitions/","title":"Module model_definitions","text":""},{"location":"model_definitions/#swift2.model_definitions.cookie_cut_dendritic_catchment","title":"<code>cookie_cut_dendritic_catchment(simulation, bottom_element_id, top_element_ids)</code>","text":"<p>cookie cut a dendritic catchment (without confluences)</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>base catchment simulation</p> required <code>bottom_element_id</code> <code>str</code> <p>identifier of the most downstream element to keep</p> required <code>top_element_ids</code> <code>str</code> <p>identifier(s) of the most upstream element(s) to keep</p> required <p>Returns:</p> Name Type Description <code>Simulation</code> <code>Simulation</code> <p>a subcatchment simulation, cookie cut from the base simulation. Deep clone of objects.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/model_definitions.py</code> <pre><code>def cookie_cut_dendritic_catchment(\n    simulation: \"Simulation\", bottom_element_id: str, top_element_ids: str\n) -&gt; \"Simulation\":\n    \"\"\"cookie cut a dendritic catchment (without confluences)\n\n    Args:\n        simulation (Simulation): base catchment simulation\n        bottom_element_id (str): identifier of the most downstream element to keep\n        top_element_ids (str): identifier(s) of the most upstream element(s) to keep\n\n    Returns:\n        Simulation: a subcatchment simulation, cookie cut from the base simulation. Deep clone of objects.\n    \"\"\"\n    # stopifnot(element_id %in% as.character(swift_cal_element_ids))\n    select_network_above_element = True\n    include_element_in_selection = True\n    invert_selection = False\n    subset_simul = swg.SubsetModel_py(\n        simulation,\n        bottom_element_id,\n        select_network_above_element,\n        include_element_in_selection,\n        invert_selection,\n        top_element_ids,\n        len(top_element_ids),\n    )\n    return subset_simul\n</code></pre>"},{"location":"model_definitions/#swift2.model_definitions.get_catchment_structure","title":"<code>get_catchment_structure(simulation)</code>","text":"<p>Gets the essential connective structure of a catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>base catchment simulation</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; _, simulation = sdh.create_test_catchment_structure()\n&gt;&gt;&gt; smd.get_catchment_structure(simulation)\n{'Node':    Id     Name\n0  n1  n1_name\n1  n2  n2_name\n2  n3  n3_name\n3  n4  n4_name\n4  n5  n5_name\n5  n6  n6_name, 'Link':      Id       Name  LengthMetres    f  ManningsN  Slope\n0  lnk1  lnk1_name           0.0  0.0        0.0    0.0\n1  lnk2  lnk2_name           0.0  0.0        0.0    0.0\n2  lnk3  lnk3_name           0.0  0.0        0.0    0.0\n3  lnk4  lnk4_name           0.0  0.0        0.0    0.0\n4  lnk5  lnk5_name           0.0  0.0        0.0    0.0, 'Subarea':      Id       Name  AreaKm2\n0  lnk1  lnk1_name      1.1\n1  lnk2  lnk2_name      2.2\n2  lnk3  lnk3_name      3.3\n3  lnk4  lnk4_name      4.4\n4  lnk5  lnk5_name      5.5, 'NodeLink':   DownstreamId UpstreamId LinkId\n0           n6         n2   lnk1\n1           n2         n5   lnk2\n2           n2         n4   lnk3\n3           n4         n3   lnk4\n4           n4         n1   lnk5, 'SubareaLink':   LinkId SubareaId\n0   lnk1      lnk1\n1   lnk2      lnk2\n2   lnk3      lnk3\n3   lnk4      lnk4\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/swift2/model_definitions.py</code> <pre><code>def get_catchment_structure(simulation) -&gt; Dict:\n    \"\"\"Gets the essential connective structure of a catchment\n\n    Args:\n        simulation (Simulation): base catchment simulation\n\n    Returns:\n        [type]: [description]\n\n    Examples:\n        &gt;&gt;&gt; _, simulation = sdh.create_test_catchment_structure()\n        &gt;&gt;&gt; smd.get_catchment_structure(simulation)\n        {'Node':    Id     Name\n        0  n1  n1_name\n        1  n2  n2_name\n        2  n3  n3_name\n        3  n4  n4_name\n        4  n5  n5_name\n        5  n6  n6_name, 'Link':      Id       Name  LengthMetres    f  ManningsN  Slope\n        0  lnk1  lnk1_name           0.0  0.0        0.0    0.0\n        1  lnk2  lnk2_name           0.0  0.0        0.0    0.0\n        2  lnk3  lnk3_name           0.0  0.0        0.0    0.0\n        3  lnk4  lnk4_name           0.0  0.0        0.0    0.0\n        4  lnk5  lnk5_name           0.0  0.0        0.0    0.0, 'Subarea':      Id       Name  AreaKm2\n        0  lnk1  lnk1_name      1.1\n        1  lnk2  lnk2_name      2.2\n        2  lnk3  lnk3_name      3.3\n        3  lnk4  lnk4_name      4.4\n        4  lnk5  lnk5_name      5.5, 'NodeLink':   DownstreamId UpstreamId LinkId\n        0           n6         n2   lnk1\n        1           n2         n5   lnk2\n        2           n2         n4   lnk3\n        3           n4         n3   lnk4\n        4           n4         n1   lnk5, 'SubareaLink':   LinkId SubareaId\n        0   lnk1      lnk1\n        1   lnk2      lnk2\n        2   lnk3      lnk3\n        3   lnk4      lnk4\n    \"\"\"\n    return swc.get_catchment_structure_pkg(simulation)\n</code></pre>"},{"location":"model_definitions/#swift2.model_definitions.model_from_json_file","title":"<code>model_from_json_file(file_path)</code>","text":"<p>Create a model simulation from a file with a JSON serialisation.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>valid file path.</p> required <p>Returns:</p> Name Type Description <code>Simulation</code> <code>Simulation</code> <p>a catchment simulation.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/model_definitions.py</code> <pre><code>def model_from_json_file(file_path:str) -&gt; \"Simulation\":\n    \"\"\"Create a model simulation from a file with a JSON serialisation.\n\n    Args:\n        file_path (str): valid file path.\n\n    Returns:\n        Simulation: a catchment simulation.\n    \"\"\"\n    from pathlib import Path\n    if not Path(file_path).exists():\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n    return swg.LoadModelSimulationFromJson_py(file_path)\n</code></pre>"},{"location":"model_definitions/#swift2.model_definitions.model_to_json_file","title":"<code>model_to_json_file(simulation, file_path)</code>","text":"<p>Save a model simulation from a file with a JSON serialisation.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>Catchment simulation</p> required <code>file_path</code> <code>str</code> <p>file path to save to</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/model_definitions.py</code> <pre><code>def model_to_json_file(simulation: \"Simulation\", file_path:str) -&gt; None:\n    \"\"\"Save a model simulation from a file with a JSON serialisation.\n\n    Args:\n        simulation (Simulation): Catchment simulation\n        file_path (str): file path to save to\n    \"\"\"\n    swg.SaveModelSimulationToJson_py(simulation, file_path)\n</code></pre>"},{"location":"model_definitions/#swift2.model_definitions.split_to_subcatchments","title":"<code>split_to_subcatchments(simulation, split_element_ids, include_upstream=None)</code>","text":"<p>Split a catchment in subcatchments, given a list of node/link element identifiers</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>base catchment simulation</p> required <code>split_element_ids</code> <code>str</code> <p>element identifiers such as 'node.n1', 'link.linkId_2'</p> required <code>include_upstream</code> <code>bool</code> <p>indicates whether for each element in split_element_ids it should be including in the upstream portion of the subcatchment. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrderedDict</code> <code>OrderedDict[str, Simulation]</code> <p>list of subcatchments resulting from the split</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; _, simulation = sdh.create_test_catchment_structure()\n&gt;&gt;&gt; e_ids = ['node.n2', 'node.n4']\n&gt;&gt;&gt; sub_sims = smd.split_to_subcatchments(simulation, e_ids)\n&gt;&gt;&gt;\n&gt;&gt;&gt; for k in sub_sims:\n...     print(k)\n...     print(sub_sims[k].get_node_ids())\n...     print(sub_sims[k].get_node_names())\n...\nnode.n4\n['n4', 'n3', 'n1']\n['n4_name', 'n3_name', 'n1_name']\nnode.n2\n['n2', 'n5']\n['n2_name', 'n5_name']\nremainder\n['n6']\n['n6_name']\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/swift2/model_definitions.py</code> <pre><code>def split_to_subcatchments(\n    simulation, split_element_ids, include_upstream=None\n) -&gt; OrderedDict[str, \"Simulation\"]:\n    \"\"\"Split a catchment in subcatchments, given a list of node/link element identifiers\n\n    Args:\n        simulation (Simulation): base catchment simulation\n        split_element_ids (str): element identifiers such as 'node.n1', 'link.linkId_2'\n        include_upstream (bool, optional): indicates whether for each element in split_element_ids it should be including in the upstream portion of the subcatchment. Defaults to None.\n\n    Returns:\n        OrderedDict: list of subcatchments resulting from the split\n\n    Examples:\n        &gt;&gt;&gt; _, simulation = sdh.create_test_catchment_structure()\n        &gt;&gt;&gt; e_ids = ['node.n2', 'node.n4']\n        &gt;&gt;&gt; sub_sims = smd.split_to_subcatchments(simulation, e_ids)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; for k in sub_sims:\n        ...     print(k)\n        ...     print(sub_sims[k].get_node_ids())\n        ...     print(sub_sims[k].get_node_names())\n        ...\n        node.n4\n        ['n4', 'n3', 'n1']\n        ['n4_name', 'n3_name', 'n1_name']\n        node.n2\n        ['n2', 'n5']\n        ['n2_name', 'n5_name']\n        remainder\n        ['n6']\n        ['n6_name']\n    \"\"\"\n    from swift2.utils import rep\n\n    if include_upstream is None:\n        include_upstream = rep(True, len(split_element_ids))\n    assert len(split_element_ids) == len(include_upstream)\n    # It is conceivable that we'd cut out on the same link or node (i.e. keep one link+its catchment or just a node\n    # , but for the time being not supported - unnecessary complication\n    if len(split_element_ids) != len(set(split_element_ids)):\n        raise ValueError(\n            \"split_element_ids has some duplicate elements - they must be unique\"\n        )\n    # TODO check that all elements are valid identifiers\n\n    e_ids_sorted = sort_by_execution_order(simulation, split_element_ids)\n    # include_upstreamSorted = sort_by(include_upstream, split_element_ids, e_ids_sorted)\n\n    n = len(e_ids_sorted)\n    result = OrderedDict()\n\n    remaining_catchment = simulation\n    for i in range(n):\n        e_id = e_ids_sorted[i]\n        action_up = (\n            \"keep_above_inclusive\" if include_upstream[i] else \"keep_above_exclusive\"\n        )\n        action_down = (\n            \"keep_below_exclusive\" if include_upstream[i] else \"keep_below_inclusive\"\n        )\n        up_stream = subset_catchment(remaining_catchment, e_id, action=action_up)\n        remaining_catchment = subset_catchment(\n            remaining_catchment, e_id, action=action_down\n        )\n        result[e_ids_sorted[i]] = up_stream\n    # We have n to n+1 outputs, depending on whether we have a remainder subcatchment at the bottom of the catchment.\n    if len(get_node_ids(remaining_catchment) + get_link_ids(remaining_catchment)) &gt; 0:\n        if \"remainder\" in result.keys():\n            raise ValueError(\n                \"There is already a key 'remainder'; cannot add the remaining downstream catchment\"\n            )\n        result[\"remainder\"] = remaining_catchment\n    return result\n</code></pre>"},{"location":"model_definitions/#swift2.model_definitions.subset_catchment","title":"<code>subset_catchment(simulation, element_id, action='keep_above')</code>","text":"<p>Subsets a catchment, keeping only a portion above or below a node, link or subarea.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"MODEL_SIMULATION_PTR\"</p> required <code>element_id</code> <code>str</code> <p>id of the element to cut at.</p> required <code>action</code> <code>str</code> <p>how to cut; currently limited to 'keep_above'</p> <code>'keep_above'</code> <p>Returns:</p> Name Type Description <code>Simulation</code> <code>Simulation</code> <p>a subcatchment simulation, cookie cut from the base simulation. Deep clone of objects.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/model_definitions.py</code> <pre><code>def subset_catchment(\n    simulation: \"Simulation\", element_id: str, action: str = \"keep_above\"\n) -&gt; \"Simulation\":\n    \"\"\"Subsets a catchment, keeping only a portion above or below a node, link or subarea.\n\n    Args:\n        simulation (Simulation): an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"MODEL_SIMULATION_PTR\"\n        element_id (str): id of the element to cut at.\n        action (str): how to cut; currently limited to 'keep_above'\n\n    Returns:\n        Simulation: a subcatchment simulation, cookie cut from the base simulation. Deep clone of objects.\n    \"\"\"\n    # if (action != 'keep_above'):stop('Only subset upstream of a node or link is supported for now')}\n    # 'keep above'\n    # 'keep above exclusive' # above element but element is not in the result;\n    # 'keep below'\n    # 'keep below exclusive'\n\n    action = action.lower()\n    action = action.replace(\"_\", \" \")\n\n    select_network_above_element = \"above\" in action\n    include_element_in_selection = not \"exclusive\" in action\n    invert_selection = False  # TOCHECK\n    return swc.subset_model_pkg(\n        simulation,\n        element_id,\n        select_network_above_element,\n        include_element_in_selection,\n        invert_selection,\n    )\n</code></pre>"},{"location":"parameteriser/","title":"Module parameteriser","text":""},{"location":"parameteriser/#swift2.parameteriser.MhData","title":"<code>MhData</code>","text":"<p>Data log from metaheuristic calibration processes</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>class MhData:\n    \"\"\"Data log from metaheuristic calibration processes\"\"\"\n\n    def __init__(\n        self,\n        data: pd.DataFrame,\n        fitness: str = \"NSE\",\n        messages: str = \"Message\",\n        categories: str = \"Category\",\n    ) -&gt; None:\n        self._fitness = fitness\n        self._messages: str = messages\n        self._categories: str = categories\n        self._data: pd.DataFrame = data\n\n    @property\n    def data(self) -&gt; pd.DataFrame:\n        \"\"\"The inner data of this data log\"\"\"\n        return self._data\n\n    def rename_columns(self, colnames_map: Dict[str, str]) -&gt; None:\n        \"\"\"Rename the columns of the data log according to a mapping. \n\n        This is handy for instance to change fully qualified parameter names \n        such as 'subarea.Wolf_Creek.x1' to just 'x1' to produce more legible plots.\n\n        Args:\n            colnames_map (Dict[str, str]): mapping\n        \"\"\"        \n        d = self._data.rename(colnames_map, axis=1, inplace=False)\n        self._data = d\n\n    def subset_by_pattern(self, colname: str, pattern: str) -&gt; \"MhData\":\n        \"\"\"Subset the log by filtering an attribute by a regexp pattern\n\n        Args:\n            colname (str): column name to filter on\n            pattern (str): regexp pattern, filter definition\n\n        Returns:\n            Any: New MhData object with subset data\n        \"\"\"\n        criterion: pd.DataFrame = self._data[[colname]]\n        indices = criterion.squeeze().str.match(pattern)\n        data = self._data.loc[indices.values]\n        return MhData(data, self._fitness, self._messages, self._categories)\n\n    def bound_fitness(self, obj_lims: Sequence[float] = None) -&gt; pd.DataFrame:\n        \"\"\"Return a copy of the log data with the fitness measure bound by min/max limits\n\n        Args:\n            obj_lims (Sequence[float], optional): min/max limits, length 2. Defaults to None.\n\n        Returns:\n            pd.DataFrame: log data with bound fitness\n        \"\"\"\n        if obj_lims is None:\n            return self._data\n        d = self._data.copy()\n        d = bound_values_df(d, self._fitness, obj_lims)\n        return d\n\n    def subset_by_message(\n        self, pattern: str = \"Initial.*|Reflec.*|Contrac.*|Add.*\"\n    ) -&gt; \"MhData\":\n        \"\"\"Subset the log by filtering the 'Message' column by a regexp pattern\n\n        Args:\n            pattern (str): regexp pattern, filter definition\n\n        Returns:\n            Any: New MhData object with subset data\n        \"\"\"\n        return self.subset_by_pattern(self._messages, pattern)\n\n    def facet_plot(\n        self,\n        y: str,\n        facet_category: str = \"Message\",\n        col_wrap: int = 3,\n        x: str = \"PointNumber\",\n        fig_width_in=15,\n        fig_heigth_in=10,\n    ):\n        \"\"\"Facet plot of parameter value evolution, facetted by a category.\n\n        This method requires the package `seaborn` to be installed.\n\n        Args:\n            y (str): variable name (model parameter) to use for the y-axis, e.g. \"x4\" for GR4J\n            facet_category (str, optional): Data attribute to use to facet. Defaults to \"Message\".\n            col_wrap (int, optional): Max number of columns in the plot. Defaults to 3.\n            x (str, optional): variable name (calibration iteration, or model parameter) to use for the x-axis. Defaults to \"PointNumber\".\n            fig_width_in (int, optional): figure width in inches. Defaults to 15.\n            fig_heigth_in (int, optional): figure height in inches. Defaults to 10.\n\n        Returns:\n            FacetGrid: The plot to display\n        \"\"\"\n        import seaborn as sns\n        df = self.data\n        grid = sns.FacetGrid(df, col = facet_category, col_wrap=col_wrap)\n        grid.map(sns.scatterplot, x, y)\n        grid.figure.set_size_inches(fig_width_in, fig_heigth_in)\n        grid.add_legend()\n        return grid\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.MhData.data","title":"<code>data</code>  <code>property</code>","text":"<p>The inner data of this data log</p>"},{"location":"parameteriser/#swift2.parameteriser.MhData.bound_fitness","title":"<code>bound_fitness(obj_lims=None)</code>","text":"<p>Return a copy of the log data with the fitness measure bound by min/max limits</p> <p>Parameters:</p> Name Type Description Default <code>obj_lims</code> <code>Sequence[float]</code> <p>min/max limits, length 2. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: log data with bound fitness</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def bound_fitness(self, obj_lims: Sequence[float] = None) -&gt; pd.DataFrame:\n    \"\"\"Return a copy of the log data with the fitness measure bound by min/max limits\n\n    Args:\n        obj_lims (Sequence[float], optional): min/max limits, length 2. Defaults to None.\n\n    Returns:\n        pd.DataFrame: log data with bound fitness\n    \"\"\"\n    if obj_lims is None:\n        return self._data\n    d = self._data.copy()\n    d = bound_values_df(d, self._fitness, obj_lims)\n    return d\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.MhData.facet_plot","title":"<code>facet_plot(y, facet_category='Message', col_wrap=3, x='PointNumber', fig_width_in=15, fig_heigth_in=10)</code>","text":"<p>Facet plot of parameter value evolution, facetted by a category.</p> <p>This method requires the package <code>seaborn</code> to be installed.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>str</code> <p>variable name (model parameter) to use for the y-axis, e.g. \"x4\" for GR4J</p> required <code>facet_category</code> <code>str</code> <p>Data attribute to use to facet. Defaults to \"Message\".</p> <code>'Message'</code> <code>col_wrap</code> <code>int</code> <p>Max number of columns in the plot. Defaults to 3.</p> <code>3</code> <code>x</code> <code>str</code> <p>variable name (calibration iteration, or model parameter) to use for the x-axis. Defaults to \"PointNumber\".</p> <code>'PointNumber'</code> <code>fig_width_in</code> <code>int</code> <p>figure width in inches. Defaults to 15.</p> <code>15</code> <code>fig_heigth_in</code> <code>int</code> <p>figure height in inches. Defaults to 10.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>FacetGrid</code> <p>The plot to display</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def facet_plot(\n    self,\n    y: str,\n    facet_category: str = \"Message\",\n    col_wrap: int = 3,\n    x: str = \"PointNumber\",\n    fig_width_in=15,\n    fig_heigth_in=10,\n):\n    \"\"\"Facet plot of parameter value evolution, facetted by a category.\n\n    This method requires the package `seaborn` to be installed.\n\n    Args:\n        y (str): variable name (model parameter) to use for the y-axis, e.g. \"x4\" for GR4J\n        facet_category (str, optional): Data attribute to use to facet. Defaults to \"Message\".\n        col_wrap (int, optional): Max number of columns in the plot. Defaults to 3.\n        x (str, optional): variable name (calibration iteration, or model parameter) to use for the x-axis. Defaults to \"PointNumber\".\n        fig_width_in (int, optional): figure width in inches. Defaults to 15.\n        fig_heigth_in (int, optional): figure height in inches. Defaults to 10.\n\n    Returns:\n        FacetGrid: The plot to display\n    \"\"\"\n    import seaborn as sns\n    df = self.data\n    grid = sns.FacetGrid(df, col = facet_category, col_wrap=col_wrap)\n    grid.map(sns.scatterplot, x, y)\n    grid.figure.set_size_inches(fig_width_in, fig_heigth_in)\n    grid.add_legend()\n    return grid\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.MhData.rename_columns","title":"<code>rename_columns(colnames_map)</code>","text":"<p>Rename the columns of the data log according to a mapping. </p> <p>This is handy for instance to change fully qualified parameter names  such as 'subarea.Wolf_Creek.x1' to just 'x1' to produce more legible plots.</p> <p>Parameters:</p> Name Type Description Default <code>colnames_map</code> <code>Dict[str, str]</code> <p>mapping</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def rename_columns(self, colnames_map: Dict[str, str]) -&gt; None:\n    \"\"\"Rename the columns of the data log according to a mapping. \n\n    This is handy for instance to change fully qualified parameter names \n    such as 'subarea.Wolf_Creek.x1' to just 'x1' to produce more legible plots.\n\n    Args:\n        colnames_map (Dict[str, str]): mapping\n    \"\"\"        \n    d = self._data.rename(colnames_map, axis=1, inplace=False)\n    self._data = d\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.MhData.subset_by_message","title":"<code>subset_by_message(pattern='Initial.*|Reflec.*|Contrac.*|Add.*')</code>","text":"<p>Subset the log by filtering the 'Message' column by a regexp pattern</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>regexp pattern, filter definition</p> <code>'Initial.*|Reflec.*|Contrac.*|Add.*'</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>MhData</code> <p>New MhData object with subset data</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def subset_by_message(\n    self, pattern: str = \"Initial.*|Reflec.*|Contrac.*|Add.*\"\n) -&gt; \"MhData\":\n    \"\"\"Subset the log by filtering the 'Message' column by a regexp pattern\n\n    Args:\n        pattern (str): regexp pattern, filter definition\n\n    Returns:\n        Any: New MhData object with subset data\n    \"\"\"\n    return self.subset_by_pattern(self._messages, pattern)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.MhData.subset_by_pattern","title":"<code>subset_by_pattern(colname, pattern)</code>","text":"<p>Subset the log by filtering an attribute by a regexp pattern</p> <p>Parameters:</p> Name Type Description Default <code>colname</code> <code>str</code> <p>column name to filter on</p> required <code>pattern</code> <code>str</code> <p>regexp pattern, filter definition</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>MhData</code> <p>New MhData object with subset data</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def subset_by_pattern(self, colname: str, pattern: str) -&gt; \"MhData\":\n    \"\"\"Subset the log by filtering an attribute by a regexp pattern\n\n    Args:\n        colname (str): column name to filter on\n        pattern (str): regexp pattern, filter definition\n\n    Returns:\n        Any: New MhData object with subset data\n    \"\"\"\n    criterion: pd.DataFrame = self._data[[colname]]\n    indices = criterion.squeeze().str.match(pattern)\n    data = self._data.loc[indices.values]\n    return MhData(data, self._fitness, self._messages, self._categories)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.add_to_hypercube","title":"<code>add_to_hypercube(parameteriser, specs)</code>","text":"<p>Add entries to a hypercube</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <code>specs</code> <code>DataFrame</code> <p>An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value.</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def add_to_hypercube(parameteriser, specs):\n    \"\"\"Add entries to a hypercube\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n        specs (pd.DataFrame): An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value.\n    \"\"\"\n    swc.add_parameters_pkg(parameteriser, specs)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.add_transform","title":"<code>add_transform(parameteriser, param_name, inner_param_name, transform_id, a=1.0, b=0.0)</code>","text":"<p>Create a parameteriser for which parameter transformations can be defined</p> <pre><code>This allows to define e.g. a virtual parameter log_X instead of calibrating on the parameter X.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>TransformParameteriser</code> <p>A TransformParameteriser wrapper, or a type inheriting from it</p> required <code>param_name</code> <code>str</code> <p>the name of the meta-parameter. Note that it can be the same value as inner_param_name, but this is NOT recommended.</p> required <code>inner_param_name</code> <code>str</code> <p>the name of the parameter being transformed</p> required <code>transform_id</code> <code>str</code> <p>identifier for a known bijective univariate function</p> required <code>a</code> <code>float</code> <p>parameter in Y = F(ax+b). Defaults to 1.0.</p> <code>1.0</code> <code>b</code> <code>float</code> <p>parameter in Y = F(ax+b). Defaults to 0.0.</p> <code>0.0</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def add_transform(\n    parameteriser: \"TransformParameteriser\",\n    param_name: str,\n    inner_param_name: str,\n    transform_id: str,\n    a=1.0,\n    b=0.0,\n):\n    \"\"\"Create a parameteriser for which parameter transformations can be defined\n\n        This allows to define e.g. a virtual parameter log_X instead of calibrating on the parameter X.\n\n    Args:\n        parameteriser (TransformParameteriser): A TransformParameteriser wrapper, or a type inheriting from it\n        param_name (str): the name of the meta-parameter. Note that it can be the same value as inner_param_name, but this is NOT recommended.\n        inner_param_name (str): the name of the parameter being transformed\n        transform_id (str): identifier for a known bijective univariate function\n        a (float, optional): parameter in Y = F(ax+b). Defaults to 1.0.\n        b (float, optional): parameter in Y = F(ax+b). Defaults to 0.0.\n    \"\"\"\n    swg.AddParameterTransform_py(\n        parameteriser, param_name, inner_param_name, transform_id, a, b\n    )\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.apply_sys_config","title":"<code>apply_sys_config(parameteriser, simulation)</code>","text":"<p>Apply a model configuration to a simulation</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <code>simulation</code> <code>Simulation</code> <p>simulation</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def apply_sys_config(parameteriser, simulation):\n    \"\"\"Apply a model configuration to a simulation\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n        simulation (Simulation): simulation\n    \"\"\"\n    if is_score(parameteriser):\n        parameteriser = swg.GetSystemConfigurationWila_py(parameteriser)\n    assert is_hypercube(parameteriser)\n    swg.ApplyConfiguration_py(parameteriser, simulation)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.as_py_structure","title":"<code>as_py_structure(x)</code>","text":"<p>Try to convert an external pointer to a native python representation</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>object, presumably wrapper around an Xptr, to convert to a 'pure' python representation</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def as_py_structure(x: Any):\n    \"\"\"Try to convert an external pointer to a native python representation\n\n    Args:\n        x (Any): object, presumably wrapper around an Xptr, to convert to a 'pure' python representation\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    if not is_cffi_native_handle(x):\n        return x\n    if is_score(x):\n        return swc.scores_as_rpy_dict_pkg(x)\n    elif is_set_of_scores(x):\n        return scores_as_dataframe(x)\n    else:\n        return x\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.backtransform","title":"<code>backtransform(parameteriser)</code>","text":"<p>Get the parameteriser values in the untransformed space</p> <p>Get the parameteriser values in the untransformed space, i.e. remove any transform added via wrapTransform. This allows to transform back e.g. from a virtual parameter log_X to the underlying model (or even virtual/meta) parameter X.</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <p>Returns:</p> Type Description <p>[HypercubeParameteriser]: The parameters definitions without the transforms (if there are any)</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def backtransform(parameteriser):\n    \"\"\"Get the parameteriser values in the untransformed space\n\n    Get the parameteriser values in the untransformed space, i.e. remove any transform added via wrapTransform.\n    This allows to transform back e.g. from a virtual parameter log_X to the underlying model (or even virtual/meta) parameter X.\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n\n    Returns:\n        [HypercubeParameteriser]: The parameters definitions without the transforms (if there are any)\n    \"\"\"\n    return swg.UntransformHypercubeParameterizer_py(parameteriser)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.bound_values_df","title":"<code>bound_values_df(x, colname, lim=None)</code>","text":"<p>min/max bound a column in a data frame</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>[type]</code> <p>a data frame</p> required <code>colname</code> <code>[type]</code> <p>a character vector, name of the column to bound</p> required <code>lim</code> <code>[type]</code> <p>a num vector of the min/max limits to apply, for instance c(0, 1). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def bound_values_df(x, colname, lim=None):\n    \"\"\"min/max bound a column in a data frame\n\n    Args:\n        x ([type]):   a data frame\n        colname ([type]): a character vector, name of the column to bound\n        lim ([type], optional): a num vector of the min/max limits to apply, for instance c(0, 1). Defaults to None.\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    if lim is None:\n        return x\n    return x.assign(**{colname: bound_values(x[[colname]], lim)})\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.concatenate_parameterisers","title":"<code>concatenate_parameterisers(*args, strategy='')</code>","text":"<p>Concatenate hypercubes to a single parameteriser</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>str</code> <p>The strategy to contatenate. Defaults to \"\", equivalent to \"composite\", the only available. May have other options in the future.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>CompositeParameteriser</code> <code>CompositeParameteriser</code> <p>A concatenated parameteriser</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def concatenate_parameterisers(\n    *args: Sequence['HypercubeParameteriser'], strategy: str = \"\"\n) -&gt; \"CompositeParameteriser\":\n    \"\"\"Concatenate hypercubes to a single parameteriser\n\n    Args:\n        strategy (str, optional): The strategy to contatenate. Defaults to \"\", equivalent to \"composite\", the only available. May have other options in the future.\n\n    Returns:\n        CompositeParameteriser: A concatenated parameteriser\n    \"\"\"\n    parameterisers = [x for x in args]\n    return swc.aggregate_parameterisers_pkg(strategy, parameterisers)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.create_multisite_obj_parameteriser","title":"<code>create_multisite_obj_parameteriser(func_parameterisers, func_identifiers, prefixes=None, mix_func_parameteriser=None, hydro_parameteriser=None)</code>","text":"<p>Builds a parameteriser usable with a multisite multiobjective calculator.</p> <p>Parameters:</p> Name Type Description Default <code>func_parameterisers</code> <code>[type]</code> <p>list of external pointers, parameterisers for each function of a multiobjective calculation.</p> required <code>func_identifiers</code> <code>[type]</code> <p>character, identifiers for each of the objectives defined in an multisite objective definition.</p> required <code>prefixes</code> <code>[type]</code> <p>Optional prefixes to use to disambiguate short parameter names used in each function of a multiobjective calculator.. Defaults to None.</p> <code>None</code> <code>mix_func_parameteriser</code> <code>[type]</code> <p>parameteriser, default None. (FUTURE) Optional parameteriser used in mixing the multiple objectives.. Defaults to None.</p> <code>None</code> <code>hydro_parameteriser</code> <code>[type]</code> <p>parameteriser, default None. Optional parameteriser applied to the simulation model.. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def create_multisite_obj_parameteriser(\n    func_parameterisers,\n    func_identifiers,\n    prefixes=None,\n    mix_func_parameteriser=None,\n    hydro_parameteriser=None,\n):\n    \"\"\"Builds a parameteriser usable with a multisite multiobjective calculator.\n\n    Args:\n        func_parameterisers ([type]): list of external pointers, parameterisers for each function of a multiobjective calculation.\n        func_identifiers ([type]): character, identifiers for each of the objectives defined in an multisite objective definition.\n        prefixes ([type], optional): Optional prefixes to use to disambiguate short parameter names used in each function of a multiobjective calculator.. Defaults to None.\n        mix_func_parameteriser ([type], optional): parameteriser, default None. (FUTURE) Optional parameteriser used in mixing the multiple objectives.. Defaults to None.\n        hydro_parameteriser ([type], optional): parameteriser, default None. Optional parameteriser applied to the simulation model.. Defaults to None.\n\n    Returns:\n        [FunctionsParameteriser]: [description]\n    \"\"\"\n    # stopifnot(is.list(func_parameterisers))\n    # stopifnot(len(func_parameterisers) == len(func_identifiers))\n    if not prefixes is None:\n        assert len(func_parameterisers) == len(prefixes)\n    cp = swg.CreateCompositeParameterizer_py()\n    n = len(func_parameterisers)\n    for i in range(n):\n        swg.TagParameterizer_py(func_parameterisers[i], func_identifiers[i])\n        if not prefixes is None:\n            pp = swg.CreatePrefixingParameterizer_py(\n                func_parameterisers[i], prefixes[i]\n            )\n            swg.AddToCompositeParameterizer_py(cp, pp)\n        # else:\n        #     TODO: what? forgot and the R implementation had a minor bug I think\n        #     swg.AddToCompositeParameterizer_py(cp, pp)\n    if not mix_func_parameteriser is None:\n        swg.TagParameterizer_py(mix_func_parameteriser, \"mixing_function\")\n        pmix_func_parameteriser = swg.CreatePrefixingParameterizer_py(\n            mix_func_parameteriser, \"mixing_function.\"\n        )\n        swg.AddToCompositeParameterizer_py(cp, pmix_func_parameteriser)\n    if hydro_parameteriser is None:  # create a dummy\n        hydro_parameteriser = swg.CreateHypercubeParameterizer_py(\"no apply\")\n    fp = swg.CreateFunctionsParameterizer_py(hydro_parameteriser, cp)\n    return fp\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.create_muskingum_param_constraints","title":"<code>create_muskingum_param_constraints(inner_parameters, delta_t=1, param_name_k='K', param_name_x='X', simulation=None)</code>","text":"<p>Create a parameteriser with Muskingum-type constraints. Given an existing parameteriser, create a wrapper that adds constraints on two of its parameters.</p> <p>Parameters:</p> Name Type Description Default <code>inner_parameters</code> <code>[HypercubeParameteriser]</code> <p>A SWIFT parameteriser object.</p> required <code>delta_t</code> <code>int</code> <p>the simulation time step in HOURS. Defaults to 1.</p> <code>1</code> <code>param_name_k</code> <code>str</code> <p>the variable identifier to use for the delay parameter of the Muskingum routing. Defaults to \"K\".</p> <code>'K'</code> <code>param_name_x</code> <code>str</code> <p>the variable identifier to use for the attenuation parameter of the Muskingum routing. Defaults to \"X\".</p> <code>'X'</code> <code>simulation</code> <code>[Simulation]</code> <p>the model simulation from which link properties are inspected to define constraints. The links' parameters must already be set.. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>[description]</p> <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def create_muskingum_param_constraints(\n    inner_parameters, delta_t=1, param_name_k=\"K\", param_name_x=\"X\", simulation=None\n):\n    \"\"\"Create a parameteriser with Muskingum-type constraints. Given an existing parameteriser, create a wrapper that adds constraints on two of its parameters.\n\n    Args:\n        inner_parameters ([HypercubeParameteriser]): A SWIFT parameteriser object.\n        delta_t (int, optional): the simulation time step in HOURS. Defaults to 1.\n        param_name_k (str, optional): the variable identifier to use for the delay parameter of the Muskingum routing. Defaults to \"K\".\n        param_name_x (str, optional): the variable identifier to use for the attenuation parameter of the Muskingum routing. Defaults to \"X\".\n        simulation ([Simulation], optional): the model simulation from which link properties are inspected to define constraints. The links' parameters must already be set.. Defaults to None.\n\n    Raises:\n        ValueError: [description]\n\n    Returns:\n        [ConstraintParameteriser]: [description]\n    \"\"\"\n    if simulation is None:\n        raise ValueError(\"simulation argument must not be None\")\n    p = swg.CreateMuskingumConstraint_py(\n        inner_parameters, delta_t, param_name_k, param_name_x, simulation\n    )\n    return p\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.create_parameter_sampler","title":"<code>create_parameter_sampler(seed, parameteriser, type)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>seed</code> <code>[type]</code> <p>seed integer, the seed to use for the sampler</p> required <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <code>type</code> <code>str</code> <p>identifying a method such as 'urs' for uniform random sampling.</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def create_parameter_sampler(seed, parameteriser, type: str):\n    \"\"\"\n\n    Args:\n        seed ([type]): seed integer, the seed to use for the sampler\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n        type (str): identifying a method such as 'urs' for uniform random sampling.\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    return swg.CreateCandidateFactorySeedWila_py(parameteriser, type, seed)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.create_parameteriser","title":"<code>create_parameteriser(type='Generic subareas', specs=None)</code>","text":"<p>Create a SWIFT parameteriser</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>A string identifying the (likely SWIFT-specific) type of parameteriser to use. Recognised types are (case insensitive) 'log-likelihood', 'generic', 'subareas', 'links', 'nodes' and 'muskingum'. Defaults to \"Generic subareas\".</p> <code>'Generic subareas'</code> <code>specs</code> <code>DataFrame</code> <p>An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>[HypercubeParameteriser]: new parameteriser</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def create_parameteriser(type=\"Generic subareas\", specs: pd.DataFrame = None):\n    \"\"\"Create a SWIFT parameteriser\n\n    Args:\n        type (str, optional): A string identifying the (likely SWIFT-specific) type of parameteriser to use. Recognised types are (case insensitive) 'log-likelihood', 'generic', 'subareas', 'links', 'nodes' and 'muskingum'. Defaults to \"Generic subareas\".\n        specs (pd.DataFrame, optional): An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value. Defaults to None.\n\n    Returns:\n        [HypercubeParameteriser]: new parameteriser\n    \"\"\"\n    p = swg.CreateHypercubeParameterizer_py(strategy=type)\n    # TODO: consider how to reuse mh::setHyperCube without introducing an undesirable package dependency\n    # Maybe pass a function to a function in the mh package\n    if specs is not None:\n        add_to_hypercube(p, specs)\n    return p\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.create_sce_optim_swift","title":"<code>create_sce_optim_swift(objective, termination_criterion, sce_params, population_initialiser)</code>","text":"<p>Build an SCE optimiser for a SWIFT model</p> <p>Parameters:</p> Name Type Description Default <code>objective</code> <code>ObjectiveEvaluator</code> <p>an objective calculator</p> required <code>termination_criterion</code> <code>SceTerminationCondition</code> <p>An object that can be passed to SCE for testing the completion of the algorithm.</p> required <code>sce_params</code> <code>dict</code> <p>optional; parameters controlling the behavior of the SCE optimisers.</p> required <code>population_initialiser</code> <code>CandidateFactorySeed</code> <p>an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type HYPERCUBE_PTR or coercible to it, or a type of object that can seed a sampler i.e. coercible to a type CANDIDATE_FACTORY_SEED_WILA_PTR. If the argument is a hypercube, a uniform random sampler is created.</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def create_sce_optim_swift(\n    objective, termination_criterion, sce_params, population_initialiser\n):\n    \"\"\"Build an SCE optimiser for a SWIFT model\n\n    Args:\n        objective ('ObjectiveEvaluator'):  an objective calculator\n        termination_criterion ('SceTerminationCondition'):  An object that can be passed to SCE for testing the completion of the algorithm.\n        sce_params (dict):  optional; parameters controlling the behavior of the SCE optimisers.\n        population_initialiser ('CandidateFactorySeed'):  an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type HYPERCUBE_PTR or coercible to it, or a type of object that can seed a sampler i.e. coercible to a type CANDIDATE_FACTORY_SEED_WILA_PTR. If the argument is a hypercube, a uniform random sampler is created.\n\n    Returns:\n        [Optimiser]: [description]\n    \"\"\"\n\n    if is_sampler_seeding(population_initialiser):\n        # nothing to do.\n        pass\n    elif is_hypercube(population_initialiser):\n        population_initialiser = create_parameter_sampler(\n            0, population_initialiser, \"urs\"\n        )\n    else:\n        raise ValueError(\n            \"population_initialiser must be provided (can be a sampler or a hypercube)\"\n        )\n    # if(missing(terminationCriterion)) terminationCriterion = maxWallTimeTermination()\n    # if(missing(SCEpars)) SCEpars = getDefaultSceParameters()\n    if termination_criterion is None:\n        max_hours = str(10 / 3600)\n        termination_criterion = create_sce_termination_wila(\n            \"relative standard deviation\", [\"0.002\", max_hours]\n        )\n    if sce_params is None:\n        sce_params = get_default_sce_parameters()\n    return swg.CreateShuffledComplexEvolutionWila_py(\n        objective, termination_criterion, sce_params, population_initialiser\n    )\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.create_sce_termination_wila","title":"<code>create_sce_termination_wila(type, arguments)</code>","text":"<p>Create a type of termination criteria suitable for the SCE algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>A type of termination criterion; currently at least \"relative standard deviation\" and \"maximum evaluations\" are valid options</p> required <code>arguments</code> <code>Sequence[str]</code> <p>Arguments, in string forms even for numeric values, options for the selected type.</p> required <p>Returns:</p> Name Type Description <code>SceTerminationCondition</code> <code>SceTerminationCondition</code> <p>[description]</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def create_sce_termination_wila(\n    type: str, arguments: Sequence[str]\n) -&gt; \"SceTerminationCondition\":\n    \"\"\"Create a type of termination criteria suitable for the SCE algorithm.\n\n    Args:\n        type (str): A type of termination criterion; currently at least \"relative standard deviation\" and \"maximum evaluations\" are valid options\n        arguments (Sequence[str]): Arguments, in string forms even for numeric values, options for the selected type.\n\n    Returns:\n        SceTerminationCondition: [description]\n    \"\"\"\n    return swg.CreateSceTerminationWila_py(type, arguments, len(arguments))\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.evaluate_score_for_parameters","title":"<code>evaluate_score_for_parameters(objective, parameteriser)</code>","text":"<p>Computes the value of an objective for a given set of parameters</p> <p>Parameters:</p> Name Type Description Default <code>objective</code> <code>[type]</code> <p>an objective calculator</p> required <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def evaluate_score_for_parameters(objective, parameteriser):\n    \"\"\"Computes the value of an objective for a given set of parameters\n\n    Args:\n        objective ([type]): an objective calculator\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    return swc.evaluate_score_wila_pkg(objective, parameteriser)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.example_parameteriser","title":"<code>example_parameteriser(type, strict=False)</code>","text":"<p>Get examples of typical parameterisers</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>identifier for a type of parameteriser including 'log-likelihood'</p> required <code>strict</code> <code>bool</code> <p>If True an error is raised if the type is not found, otherwise a dummy empty parameteriser is returned.. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def example_parameteriser(type: str, strict=False):\n    \"\"\"Get examples of typical parameterisers\n\n    Args:\n        type (str): identifier for a type of parameteriser including 'log-likelihood'\n        strict (bool, optional): If True an error is raised if the type is not found, otherwise a dummy empty parameteriser is returned.. Defaults to False.\n\n    Returns:\n        [HypercubeParameteriser]: [description]\n    \"\"\"\n    type = type.lower()\n    if type == \"log-likelihood\":\n        p = create_parameteriser(type=\"no apply\")\n        calc_m_and_s = 1.0  # meaning true\n        censopt = 0.0\n        add_to_hypercube(\n            p,\n            _df_from_dict(\n                Name=[\"b\", \"m\", \"s\", \"a\", \"maxobs\", \"ct\", \"censopt\", \"calc_mod_m_s\"],\n                Min=_npf([-30, 0, 1, -30, 100.0, 0.01, censopt, calc_m_and_s]),\n                Max=_npf([0, 0, 1000, 1, 100.0, 0.01, censopt, calc_m_and_s]),\n                Value=_npf([-7, 0, 100, -10, 100.0, 0.01, censopt, calc_m_and_s]),\n            ),\n        )\n        return p\n    if not strict:\n        return create_parameteriser(type=\"Generic\")\n    else:\n        raise Exception(\"No example parameteriser yet for type \" + type)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.execute_optimisation","title":"<code>execute_optimisation(optimiser)</code>","text":"<p>Launch an optimization task, as defined by the object passed as an argument</p> <p>Parameters:</p> Name Type Description Default <code>optimiser</code> <code>Optimiser</code> <p>the instance of the optimiser that has been created for the optimisation task about to be launched.</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def execute_optimisation(optimiser):\n    \"\"\"Launch an optimization task, as defined by the object passed as an argument\n\n    Args:\n        optimiser (Optimiser): the instance of the optimiser that has been created for the optimisation task about to be launched.\n\n    Returns:\n        [VectorObjectiveScores]: [description]\n    \"\"\"\n    return swg.ExecuteOptimizerWila_py(optimiser)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.extract_optimisation_log","title":"<code>extract_optimisation_log(estimator, fitness_name='log.likelihood')</code>","text":"<p>Extract the logger from a parameter extimator (optimiser or related)</p> <p>Parameters:</p> Name Type Description Default <code>estimator</code> <code>Optimiser</code> <p>the optimiser instance</p> required <code>fitness_name</code> <code>str</code> <p>name of the fitness function to extract. Defaults to \"log.likelihood\".</p> <code>'log.likelihood'</code> <p>Returns:</p> Name Type Description <code>MhData</code> <code>MhData</code> <p>an object with methods to analyse the optimisation log</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def extract_optimisation_log(estimator, fitness_name=\"log.likelihood\") -&gt; 'MhData':\n    \"\"\"Extract the logger from a parameter extimator (optimiser or related)\n\n    Args:\n        estimator (Optimiser): the optimiser instance\n        fitness_name (str, optional): name of the fitness function to extract. Defaults to \"log.likelihood\".\n\n    Returns:\n        MhData: an object with methods to analyse the optimisation log\n    \"\"\"\n    optim_log = get_logger_content(estimator, add_numbering=True)\n    log_mh = mk_optim_log(\n        optim_log, fitness=fitness_name, messages=\"Message\", categories=\"Category\"\n    )\n    # geom_ops = log_mh.subset_by_message()\n    # return {\"data\": log_mh, \"geom_ops\": geom_ops}\n    return log_mh\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.feasible_muskingum_bounds","title":"<code>feasible_muskingum_bounds(simulation, delta_t_hours=1)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>[description]</p> required <code>delta_t_hours</code> <code>int</code> <p>[description]. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def feasible_muskingum_bounds(simulation: \"Simulation\", delta_t_hours=1):\n    \"\"\"[summary]\n\n    Args:\n        simulation (Simulation): [description]\n        delta_t_hours (int, optional): [description]. Defaults to 1.\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    return swg.GetFeasibleMuskingumBounds_py(simulation, delta_t_hours)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.filtered_parameters","title":"<code>filtered_parameters(parameteriser)</code>","text":"<p>Wrap a parameteriser in a filter that can hide some parameters</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it. A deep copy of the input is taken.</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def filtered_parameters(parameteriser):\n    \"\"\"Wrap a parameteriser in a filter that can hide some parameters\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it. A deep copy of the input is taken.\n\n    Returns:\n        [FilteringParameteriser]: [description]\n    \"\"\"\n    return swg.CreateFilteringParameterizer_py(parameteriser)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.get_best_score","title":"<code>get_best_score(scores_population, score_name='NSE', convert_to_py=False)</code>","text":"<p>Gets the best score in a population for a given objective</p> <p>Parameters:</p> Name Type Description Default <code>scores_population</code> <code>[type]</code> <p>an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type VEC_OBJECTIVE_SCORES_PTR</p> required <code>score_name</code> <code>str</code> <p>name of the objective to use for sorting. Defaults to \"NSE\".</p> <code>'NSE'</code> <code>convert_to_py</code> <code>bool</code> <p>should the returned score be converted to an R representation. Default False. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def get_best_score(scores_population, score_name=\"NSE\", convert_to_py=False):\n    \"\"\"Gets the best score in a population for a given objective\n\n    Args:\n        scores_population ([type]): an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type VEC_OBJECTIVE_SCORES_PTR\n        score_name (str, optional): name of the objective to use for sorting. Defaults to \"NSE\".\n        convert_to_py (bool, optional): should the returned score be converted to an R representation. Default False. Defaults to False.\n\n    Returns:\n        [ObjectiveScores or Dict]: [description]\n    \"\"\"\n    sorted_results = sort_by_score(scores_population, score_name)\n    s = get_score_at_index(sorted_results, 1)\n    if convert_to_py:\n        return swc.scores_as_rpy_dict_pkg(s)\n    else:\n        return s\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.get_default_sce_parameters","title":"<code>get_default_sce_parameters()</code>","text":"<p>[summary]</p> <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def get_default_sce_parameters():\n    \"\"\"[summary]\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    from swift2.wrap.swift_wrap_custom import default_sce_parameters_pkg\n\n    return default_sce_parameters_pkg()\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.get_logger_content","title":"<code>get_logger_content(optimiser, add_numbering=False)</code>","text":"<p>Gets logger content on an optimiser, recorded detail of the optimisation process for post-optimisation analysis.</p> <p>Parameters:</p> Name Type Description Default <code>optimiser</code> <code>[type]</code> <p>the instance of the optimiser that has been created for the optimisation task about to be launched.</p> required <code>add_numbering</code> <code>bool</code> <p>Add an explicit column for numbering the lines of the log. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The data log of the optimiser</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def get_logger_content(optimiser:DeletableCffiNativeHandle, add_numbering:bool=False) -&gt; pd.DataFrame:\n    \"\"\"Gets logger content on an optimiser, recorded detail of the optimisation process for post-optimisation analysis.\n\n    Args:\n        optimiser ([type]): the instance of the optimiser that has been created for the optimisation task about to be launched.\n        add_numbering (bool, optional): Add an explicit column for numbering the lines of the log. Defaults to False.\n\n    Returns:\n        pd.DataFrame: The data log of the optimiser\n    \"\"\"\n    # coercion to data.frame is a workaround for https://jira.csiro.au/browse/WIRADA-245\n    if is_cffi_native_handle(optimiser, type_id=\"ERRIS_STAGED_CALIBRATION_PTR\"):\n        log_data = swg.GetERRISCalibrationLog_py(optimiser)\n    else:\n        log_data = swg.GetOptimizerLogDataWila_py(optimiser)\n    return convert_optimisation_logger(log_data, add_numbering)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.get_marginal_termination","title":"<code>get_marginal_termination(tolerance=1e-06, cutoff_no_improvement=10, max_hours=0.05)</code>","text":"<p>Create an termination criterion based on the rate of marginal fitness improvement</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <code>[type]</code> <p>the increment in the objective below which the improvement is considered negligible. Defaults to 1e-06.</p> <code>1e-06</code> <code>cutoff_no_improvement</code> <code>int</code> <p>the maximum number of successive times the algorithm fails to improve the objective function.. Defaults to 10.</p> <code>10</code> <code>max_hours</code> <code>float</code> <p>the maximum wall time runtime for the optimisation. Defaults to 0.05.</p> <code>0.05</code> <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def get_marginal_termination(tolerance=1e-06, cutoff_no_improvement=10, max_hours=0.05):\n    \"\"\"Create an termination criterion based on the rate of marginal fitness improvement\n\n    Args:\n        tolerance ([type], optional): the increment in the objective below which the improvement is considered negligible. Defaults to 1e-06.\n        cutoff_no_improvement (int, optional): the maximum number of successive times the algorithm fails to improve the objective function.. Defaults to 10.\n        max_hours (float, optional): the maximum wall time runtime for the optimisation. Defaults to 0.05.\n\n    Returns:\n        [SceTerminationCondition]: [description]\n    \"\"\"\n    return swg.CreateSceMarginalTerminationWila_py(\n        tolerance=tolerance,\n        cutoffNoImprovement=cutoff_no_improvement,\n        maxHours=max_hours,\n    )\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.get_max_iteration_termination","title":"<code>get_max_iteration_termination(max_iterations=1000)</code>","text":"<p>Create an termination criterion based on the number of objective evaluations</p> <p>Parameters:</p> Name Type Description Default <code>max_iterations</code> <code>int</code> <p>number of iterations, which, if less than total count of optim objective evaluations, defines optim termination.. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def get_max_iteration_termination(max_iterations=1000):\n    \"\"\"Create an termination criterion based on the number of objective evaluations\n\n    Args:\n        max_iterations (int, optional): number of iterations, which, if less than total count of optim objective evaluations, defines optim termination.. Defaults to 1000.\n\n    Returns:\n        [SceTerminationCondition]: [description]\n    \"\"\"\n    return swg.CreateSceMaxIterationTerminationWila_py(maxIterations=max_iterations)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.get_max_runtime_termination","title":"<code>get_max_runtime_termination(max_hours=0.05)</code>","text":"<p>Create an termination criterion based on the wall clock runtime</p> <p>Parameters:</p> Name Type Description Default <code>max_hours</code> <code>float</code> <p>the maximum wall time runtime in hours for the optimisation. Defaults to 0.05.</p> <code>0.05</code> <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def get_max_runtime_termination(max_hours=0.05):\n    \"\"\"Create an termination criterion based on the wall clock runtime\n\n    Args:\n        max_hours (float, optional): the maximum wall time runtime in hours for the optimisation. Defaults to 0.05.\n\n    Returns:\n        [SceTerminationCondition]: [description]\n    \"\"\"\n    return swg.CreateSceMaxRuntimeTerminationWila_py(maxHours=max_hours)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.get_score_at_index","title":"<code>get_score_at_index(scores_population, index)</code>","text":"<p>Get an objective scores in a vector thereof</p> <p>Parameters:</p> Name Type Description Default <code>scores_population</code> <code>[type]</code> <p>an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type VEC_OBJECTIVE_SCORES_PTR</p> required <code>index</code> <code>int</code> <p>one-based index in the population</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def get_score_at_index(scores_population, index: int):\n    \"\"\"Get an objective scores in a vector thereof\n\n    Args:\n        scores_population ([type]): an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type VEC_OBJECTIVE_SCORES_PTR\n        index (int): one-based index in the population\n\n    Returns:\n        [ObjectiveScores]: [description]\n    \"\"\"\n    return swg.GetScoresAtIndex_py(scores_population, index - 1)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.hide_parameters","title":"<code>hide_parameters(parameteriser, patterns, regex=False, starts_with=False, strict=False)</code>","text":"<p>Hide some parameters (from the outside e.g. optimisers) in a filter parameteriser</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <code>patterns</code> <code>[type]</code> <p>character, one or more pattern to match and hide matching parameters. Match according to other parameters.</p> required <code>regex</code> <code>bool</code> <p>logical, defaults False, should the patterns be used as regular expressions.. Defaults to False.</p> <code>False</code> <code>starts_with</code> <code>bool</code> <p>logical, defaults False. Ignored if regex is True. Should the patterns be used as starting strings in the parameter names.. Defaults to False.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>logical, default False. Used only if regex and starts_with are False. If True, raises an error if one of the \"patterns\" has no exact match in the parameters.. Defaults to False.</p> <code>False</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def hide_parameters(\n    parameteriser, patterns, regex=False, starts_with=False, strict=False\n):\n    \"\"\"Hide some parameters (from the outside e.g. optimisers) in a filter parameteriser\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n        patterns ([type]):  character, one or more pattern to match and hide matching parameters. Match according to other parameters.\n        regex (bool, optional): logical, defaults False, should the patterns be used as regular expressions.. Defaults to False.\n        starts_with (bool, optional): logical, defaults False. Ignored if regex is True. Should the patterns be used as starting strings in the parameter names.. Defaults to False.\n        strict (bool, optional): logical, default False. Used only if regex and starts_with are False. If True, raises an error if one of the \"patterns\" has no exact match in the parameters.. Defaults to False.\n    \"\"\"\n    swg.HideParameters_py(parameteriser, patterns, regex, starts_with, strict)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.is_hypercube","title":"<code>is_hypercube(p_set)</code>","text":"<p>Is the object a native parameteriser that can be cast as a hypercube?</p> <p>Parameters:</p> Name Type Description Default <code>p_set</code> <code>CffiNativeHandle</code> <p>[description]</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def is_hypercube(p_set: CffiNativeHandle):\n    \"\"\"Is the object a native parameteriser that can be cast as a hypercube?\n\n    Args:\n        p_set (CffiNativeHandle): [description]\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    # TODO: implement a SWIFT API function to check this.\n    # KLUDGE:\n    from refcount.interop import is_cffi_native_handle\n\n    return is_cffi_native_handle(p_set) and p_set.type_id in [\n        \"HYPERCUBE_PTR\",\n        \"COMPOSITE_PARAMETERIZER_PTR\",\n        \"FUNCTIONS_PARAMETERIZER_PTR\",\n        \"CONSTRAINT_PARAMETERIZER_PTR\",\n        \"SCALING_PARAMETERIZER_PTR\",\n        \"STATE_INIT_PARAMETERIZER_PTR\",\n        \"TRANSFORM_PARAMETERIZER_PTR\",\n        \"STATE_INITIALIZER_PTR\",\n        \"SUBAREAS_SCALING_PARAMETERIZER_PTR\",\n        \"HYPERCUBE_WILA_PTR\",\n        \"XPtr&lt;OpaquePointer&gt;\",  # TODO this is to circumvent issues now that some functions are generated from Rcpp code rather than API. See e.g. aggregate_parameterisers_pkg\n    ]\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.is_sampler_seeding","title":"<code>is_sampler_seeding(obj)</code>","text":"<p>Is the argument a native object that is a seeded candidate parameteriser factory</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>CffiNativeHandle</code> <p>[description]</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def is_sampler_seeding(obj: CffiNativeHandle):\n    \"\"\"Is the argument a native object that is a seeded candidate parameteriser factory\n\n    Args:\n        obj (CffiNativeHandle): [description]\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    # KLUDGE:\n    from refcount.interop import is_cffi_native_handle\n\n    return is_cffi_native_handle(obj, \"CANDIDATE_FACTORY_SEED_WILA_PTR\")\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.is_score","title":"<code>is_score(x)</code>","text":"<p>OBJECTIVE_SCORES_WILA_PTR</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>[type]</code> <p>[description]</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def is_score(x):\n    \"\"\"OBJECTIVE_SCORES_WILA_PTR\n\n    Args:\n        x ([type]): [description]\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    # TODO: implement a SWIFT API function to check this.\n    # KLUDGE?:\n    return is_cffi_native_handle(x, type_id=\"OBJECTIVE_SCORES_WILA_PTR\")\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.is_set_of_scores","title":"<code>is_set_of_scores(x)</code>","text":"<p>VEC_OBJECTIVE_SCORES_PTR</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>[type]</code> <p>[description]</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def is_set_of_scores(x):\n    \"\"\"VEC_OBJECTIVE_SCORES_PTR\n\n    Args:\n        x ([type]): [description]\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    return is_cffi_native_handle(x, type_id=\"VEC_OBJECTIVE_SCORES_PTR\")\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.linear_parameteriser","title":"<code>linear_parameteriser(param_name, state_name, scaling_var_name, min_p_val, max_p_val, value, selector_type='subareas', intercept=0.0)</code>","text":"<p>Create a scaled linear parameteriser, tying by a linear transformation a (resp several) model state to a (resp several) parameter values</p> <p>This allows to define tied parameters where pval = a * modelStateVal + intercept. The intent in particular is to define virtual model parameters such as initial store value as a fraction of the maximum storage capacity.</p> <p>Args:</p> <pre><code>param_name (VecStr): the name of the meta-parameter. Note that it can be the same value as inner_param_name without interference, though this may be confusing a choice.\nstate_name (VecStr): the name of the model state to modify, based on the value of the meta-parameter and the state found in 'scalingVarName'\nscaling_var_name (VecStr): the name of the parameter for each subarea model, to which to apply the area scaled value.\nmin_p_val (VecNum): minimum value allowed for the meta-parameter\nmax_p_val (VecNum): minimum value allowed for the meta-parameter\nvalue (VecNum): value for the meta parameter.\nselector_type (str, optional): an identifier to define to which catchment element(s) the parameteriser will be applied. Defaults to \"subareas\".\nintercept (VecNum, optional): intercepts in the linear relationship(s). Defaults to 0.0.\n</code></pre> <p>Returns:</p> Type Description <p>[ScalingParameteriser]: new ScalingParameteriser</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def linear_parameteriser(\n    param_name: VecStr,\n    state_name: VecStr,\n    scaling_var_name: VecStr,\n    min_p_val: VecNum,\n    max_p_val: VecNum,\n    value: VecNum,\n    selector_type: str = \"subareas\",\n    intercept: VecNum = 0.0,\n):\n    \"\"\"Create a scaled linear parameteriser, tying by a linear transformation a (resp several) model state to a (resp several) parameter values\n\n    This allows to define tied parameters where pval = a * modelStateVal + intercept.\n    The intent in particular is to define virtual model parameters such as initial store value as a fraction of the maximum storage capacity.\n\n    Args:\n\n        param_name (VecStr): the name of the meta-parameter. Note that it can be the same value as inner_param_name without interference, though this may be confusing a choice.\n        state_name (VecStr): the name of the model state to modify, based on the value of the meta-parameter and the state found in 'scalingVarName'\n        scaling_var_name (VecStr): the name of the parameter for each subarea model, to which to apply the area scaled value.\n        min_p_val (VecNum): minimum value allowed for the meta-parameter\n        max_p_val (VecNum): minimum value allowed for the meta-parameter\n        value (VecNum): value for the meta parameter.\n        selector_type (str, optional): an identifier to define to which catchment element(s) the parameteriser will be applied. Defaults to \"subareas\".\n        intercept (VecNum, optional): intercepts in the linear relationship(s). Defaults to 0.0.\n\n    Returns:\n        [ScalingParameteriser]: new ScalingParameteriser\n    \"\"\"\n    # stopifnot(len(selectorType) == 1)\n    param_name, state_name, scaling_var_name, min_p_val, max_p_val, value = listify(\n        param_name, state_name, scaling_var_name, min_p_val, max_p_val, value\n    )\n    lengths = [\n        len(x)\n        for x in [param_name, state_name, scaling_var_name, min_p_val, max_p_val, value]\n    ]\n    if len(set(lengths)) != 1:\n        raise Exception(\n            \"arguments must all be vectors of same length: param_name, state_name, scalingVarName, minPval, maxPval, value\"\n        )\n    if not is_common_iterable(intercept):\n        intercept = np.repeat(intercept, lengths[0])\n    elif len(intercept) != lengths[0]:\n        raise Exception(\n            'argument \"intercept\" be of length 1 or the same as: param_name, state_name, scalingVarName, minPval, maxPval, value'\n        )\n    p = swg.CreateTargetScalingParameterizer_py(selector_type)\n    for i in range(lengths[0]):\n        swg.AddLinearScalingParameterizer_py(\n            p,\n            param_name[i],\n            state_name[i],\n            scaling_var_name[i],\n            intercept[i],\n            min_p_val[i],\n            max_p_val[i],\n            value[i],\n        )\n    return p\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.linear_parameteriser_from","title":"<code>linear_parameteriser_from(data_frame, selector_type='subareas')</code>","text":"<p>Create a scaled linear parameteriser, tying by a linear transformation a (resp several) model state to a (resp several) parameter values</p> <p>This allows to define tied parameters where pval = a * modelStateVal + intercept. The intent in particular is to define virtual model parameters such as initial store value as a fraction of the maximum storage capacity. Args:     data_frame (pd.DataFrame): data frame with columns \"param_name\", \"state_name\", \"scaling_var_name\", \"min_value\", \"max_value\", \"value\", \"intercept\",     selector_type (str, optional): [description]. Defaults to \"subareas\".</p> <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def linear_parameteriser_from(\n    data_frame: pd.DataFrame, selector_type: str = \"subareas\"\n):\n    \"\"\"Create a scaled linear parameteriser, tying by a linear transformation a (resp several) model state to a (resp several) parameter values\n\n    This allows to define tied parameters where pval = a * modelStateVal + intercept.\n    The intent in particular is to define virtual model parameters such as initial store value as a fraction of the maximum storage capacity.\n    Args:\n        data_frame (pd.DataFrame): data frame with columns \"param_name\", \"state_name\", \"scaling_var_name\", \"min_value\", \"max_value\", \"value\", \"intercept\",\n        selector_type (str, optional): [description]. Defaults to \"subareas\".\n\n    Returns:\n        [ScalingParameteriser]: ScalingParameteriser\n    \"\"\"\n    return linear_parameteriser(\n        param_name=data_frame[[PARAM_NAME_COL]],\n        state_name=data_frame[[STATE_NAME_COL]],\n        scaling_var_name=data_frame[[SCALING_VAR_NAME_COL]],\n        min_p_val=data_frame[[MIN_VALUE_COL]],\n        max_p_val=data_frame[[MAX_VALUE_COL]],\n        value=data_frame[[VALUE_COL]],\n        selector_type=selector_type,\n        intercept=data_frame[[INTERCEPT_COL]],\n    )\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.make_state_init_parameteriser","title":"<code>make_state_init_parameteriser(parameteriser)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <p>Returns:</p> Type Description <p>[StateInitParameteriser]: new state initialisation parameteriser</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def make_state_init_parameteriser(parameteriser):\n    \"\"\"[summary]\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n\n    Returns:\n        [StateInitParameteriser]: new state initialisation parameteriser\n    \"\"\"\n    return swg.CreateStateInitParameterizer_py(parameteriser)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.parameteriser_as_dataframe","title":"<code>parameteriser_as_dataframe(parameteriser)</code>","text":"<p>Convert an external object hypercube parameteriser to a pandas data frame</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <p>Returns:</p> Type Description <p>[type]: [a data frame]</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def parameteriser_as_dataframe(parameteriser):\n    \"\"\"Convert an external object hypercube parameteriser to a pandas data frame\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n\n    Returns:\n        [type]: [a data frame]\n    \"\"\"\n    return swc.parameteriser_to_data_frame_pkg(parameteriser)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.parameteriser_for_score","title":"<code>parameteriser_for_score(score)</code>","text":"<p>Gets the parameteriser for a score</p> <p>Parameters:</p> Name Type Description Default <code>score</code> <code>[type]</code> <p>[description]</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def parameteriser_for_score(score:'ObjectiveScores'):\n    \"\"\"Gets the parameteriser for a score\n\n    Args:\n        score ([type]): [description]\n\n    Returns:\n        [HypercubeParameteriser]: [description]\n    \"\"\"\n    return swg.GetSystemConfigurationWila_py(score)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.scores_as_dataframe","title":"<code>scores_as_dataframe(scores_population)</code>","text":"<p>Convert objective scores to a pandas data frame representation</p> <p>Parameters:</p> Name Type Description Default <code>scores_population</code> <code>[type]</code> <p>[description]</p> required <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def scores_as_dataframe(scores_population):\n    \"\"\"Convert objective scores to a pandas data frame representation\n\n    Args:\n        scores_population ([type]): [description]\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    return swc.vec_scores_as_dataframe_pkg(scores_population)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.set_calibration_logger","title":"<code>set_calibration_logger(optimiser, type='')</code>","text":"<p>Sets logging on an optimiser, so as to record a detail of the optimisation process for post-optimisation analysis.</p> <p>Parameters:</p> Name Type Description Default <code>optimiser</code> <code>[type]</code> <p>[description]</p> required <code>type</code> <code>str</code> <p>[description]. Defaults to \"\".</p> <code>''</code> <p>Returns:</p> Type Description Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def set_calibration_logger(optimiser, type=\"\"):\n    \"\"\"Sets logging on an optimiser, so as to record a detail of the optimisation process for post-optimisation analysis.\n\n    Args:\n        optimiser ([type]): [description]\n        type (str, optional): [description]. Defaults to \"\".\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    return swg.SetOptimizerLoggerWila_py(optimiser, type)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.set_hypercube","title":"<code>set_hypercube(parameteriser, specs)</code>","text":"<p>Set the properties of a hypercube parameteriser</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <code>specs</code> <code>DataFrame</code> <p>An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value.</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def set_hypercube(parameteriser: \"HypercubeParameteriser\", specs: pd.DataFrame):\n    \"\"\"Set the properties of a hypercube parameteriser\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n        specs (pd.DataFrame): An optional data frame description of the parameter set, with at least columns Name, Min, Max, Value.\n    \"\"\"\n    swc.set_parameters_pkg(parameteriser, specs)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.set_max_parameter_value","title":"<code>set_max_parameter_value(parameteriser, variable_name, value)</code>","text":"<p>Sets the maximum value of a model parameter value</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <code>variable_name</code> <code>str or iterable of str</code> <p>model variable state identifier(s)</p> required <code>value</code> <code>numeric or iterable of numeric</code> <p>value(s)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def set_max_parameter_value(parameteriser, variable_name, value):\n    \"\"\"Sets the maximum value of a model parameter value\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n        variable_name (str or iterable of str): model variable state identifier(s)\n        value (numeric or iterable of numeric): value(s)\n    \"\"\"\n    _sapply_parameter_set(\n        parameteriser, variable_name, value, swg.SetMaxParameterValue_py\n    )\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.set_min_parameter_value","title":"<code>set_min_parameter_value(parameteriser, variable_name, value)</code>","text":"<p>Sets the minimum value of a model parameter value</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <code>variable_name</code> <code>str or iterable of str</code> <p>model variable state identifier(s)</p> required <code>value</code> <code>numeric or iterable of numeric</code> <p>value(s)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def set_min_parameter_value(parameteriser, variable_name, value):\n    \"\"\"Sets the minimum value of a model parameter value\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n        variable_name (str or iterable of str): model variable state identifier(s)\n        value (numeric or iterable of numeric): value(s)\n    \"\"\"\n    _sapply_parameter_set(\n        parameteriser, variable_name, value, swg.SetMinParameterValue_py\n    )\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.set_parameter_value","title":"<code>set_parameter_value(parameteriser, variable_name, value)</code>","text":"<p>Sets the value of a model parameter value</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <code>variable_name</code> <code>str or iterable of str</code> <p>model variable state identifier(s)</p> required <code>value</code> <code>numeric or iterable of numeric</code> <p>value(s)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def set_parameter_value(parameteriser, variable_name, value):\n    \"\"\"Sets the value of a model parameter value\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n        variable_name (str or iterable of str): model variable state identifier(s)\n        value (numeric or iterable of numeric): value(s)\n    \"\"\"\n    _sapply_parameter_set(parameteriser, variable_name, value, swg.SetParameterValue_py)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.show_parameters","title":"<code>show_parameters(parameteriser, patterns, regex=False, starts_with=False)</code>","text":"<p>Show some parameters (from the outside e.g. optimisers) in a filter parameteriser</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <code>patterns</code> <code>[type]</code> <p>character, one or more pattern to match and show matching parameters. Match according to other parameters</p> required <code>regex</code> <code>bool</code> <p>should the patterns be used as regular expressions. Defaults to False.</p> <code>False</code> <code>starts_with</code> <code>bool</code> <p>should the patterns be used as starting strings in the parameter names. Defaults to False.</p> <code>False</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def show_parameters(parameteriser, patterns, regex=False, starts_with=False):\n    \"\"\"Show some parameters (from the outside e.g. optimisers) in a filter parameteriser\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n        patterns ([type]):  character, one or more pattern to match and show matching parameters. Match according to other parameters\n        regex (bool, optional): should the patterns be used as regular expressions. Defaults to False.\n        starts_with (bool, optional): should the patterns be used as starting strings in the parameter names. Defaults to False.\n    \"\"\"\n    swg.ShowParameters_py(parameteriser, patterns, regex, starts_with)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.sort_by_score","title":"<code>sort_by_score(scores_population, score_name='NSE')</code>","text":"<p>Sort objective scores according to one of the objective values</p> <p>Parameters:</p> Name Type Description Default <code>scores_population</code> <code>[type]</code> <p>an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type VEC_OBJECTIVE_SCORES_PTR</p> required <code>score_name</code> <code>str</code> <p>name of the objective to use for sorting. Defaults to \"NSE\".</p> <code>'NSE'</code> <p>Returns:</p> Name Type Description <code>VectorObjectiveScores</code> <p>an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type VEC_OBJECTIVE_SCORES_PTR</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def sort_by_score(scores_population, score_name=\"NSE\"):\n    \"\"\"Sort objective scores according to one of the objective values\n\n    Args:\n        scores_population ([type]): an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type VEC_OBJECTIVE_SCORES_PTR\n        score_name (str, optional): name of the objective to use for sorting. Defaults to \"NSE\".\n\n    Returns:\n        VectorObjectiveScores: an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type VEC_OBJECTIVE_SCORES_PTR\n    \"\"\"\n    return swg.SortSetOfScoresBy_py(scores_population, score_name)\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.subcatchment_parameteriser","title":"<code>subcatchment_parameteriser(parameteriser, subcatchment)</code>","text":"<p>Create a parameteriser that gets applied to a subset of a whole catchment</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <code>subcatchment</code> <code>Simulation</code> <p>the subcatchment, subset of a whole catchment, identifying which elements (subareas, nodes, links) will be parameterised by the new parameteriser. Other catchment elements are untouched.</p> required <p>Returns:</p> Type Description <p>[HypercubeParameteriser]: New parameteriser whose application is limited to the subcatchment.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sub_cats = simulation.split_to_subcatchments([\"node.node_7\", \"node.node_10\"])\n&gt;&gt;&gt; sc = sub_cats[\"node.node_7\"]\n&gt;&gt;&gt; p = sp.create_parameteriser('generic subarea')\n&gt;&gt;&gt; p.add_parameter_to_hypercube(\"x1\", 32, 1, 6e3)\n&gt;&gt;&gt; sp = p.subcatchment_parameteriser(sc)\n&gt;&gt;&gt; sp.apply_sys_config(simulation)\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def subcatchment_parameteriser(parameteriser, subcatchment):\n    \"\"\"Create a parameteriser that gets applied to a subset of a whole catchment\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n        subcatchment (Simulation): the subcatchment, subset of a whole catchment, identifying which elements (subareas, nodes, links) will be parameterised by the new parameteriser. Other catchment elements are untouched.\n\n    Returns:\n        [HypercubeParameteriser]: New parameteriser whose application is limited to the subcatchment.\n\n    Examples:\n        &gt;&gt;&gt; sub_cats = simulation.split_to_subcatchments([\"node.node_7\", \"node.node_10\"])\n        &gt;&gt;&gt; sc = sub_cats[\"node.node_7\"]\n        &gt;&gt;&gt; p = sp.create_parameteriser('generic subarea')\n        &gt;&gt;&gt; p.add_parameter_to_hypercube(\"x1\", 32, 1, 6e3)\n        &gt;&gt;&gt; sp = p.subcatchment_parameteriser(sc)\n        &gt;&gt;&gt; sp.apply_sys_config(simulation)\n\n    \"\"\"\n    p = swg.CreateSubcatchmentHypercubeParameterizer_py(parameteriser, subcatchment)\n    return p\n</code></pre>"},{"location":"parameteriser/#swift2.parameteriser.wrap_transform","title":"<code>wrap_transform(parameteriser)</code>","text":"<p>Create a parameteriser for which parameter transformations can be defined.</p> <p>This allows to define e.g. a virtual parameter log_X instead of calibrating on the parameter X.</p> <p>Parameters:</p> Name Type Description Default <code>parameteriser</code> <code>HypercubeParameteriser</code> <p>A HypercubeParameteriser wrapper, or a type inheriting from it</p> required <p>Returns:</p> Name Type Description <code>TransformParameteriser</code> <p>A new parameteriser (TransformParameteriser) which has methods to define parameter transforms</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/parameteriser.py</code> <pre><code>def wrap_transform(parameteriser):\n    \"\"\"Create a parameteriser for which parameter transformations can be defined.\n\n    This allows to define e.g. a virtual parameter log_X instead of calibrating on the parameter X.\n\n    Args:\n        parameteriser (HypercubeParameteriser): A HypercubeParameteriser wrapper, or a type inheriting from it\n\n    Returns:\n        TransformParameteriser: A new parameteriser (TransformParameteriser) which has methods to define parameter transforms\n    \"\"\"\n    return swg.CreateTransformParameterizer_py(parameteriser)\n</code></pre>"},{"location":"play_record/","title":"Module play_record","text":""},{"location":"play_record/#swift2.play_record.get_played","title":"<code>get_played(simulation, var_ids=None, start_time=None, end_time=None)</code>","text":"<p>Retrieves a played time series from a simulation</p> <p>Retrieves a played time series from a simulation.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>var_ids</code> <code>Any</code> <p>name of the output variable played to a time series. 'Catchment|StreamflowRate'. If missing, a multivariate time series of all played states is returned; this may be a large amount of data.</p> <code>None</code> <code>start_time</code> <code>Any</code> <p>An optional parameter, the start of a period to subset the time series</p> <code>None</code> <code>end_time</code> <code>Any</code> <p>An optional parameter, the end of a period to subset the time series</p> <code>None</code> <p>Returns:</p> Type Description <p>an xts time series, possibly multivariate.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/play_record.py</code> <pre><code>def get_played(simulation: \"Simulation\", var_ids=None, start_time=None, end_time=None):\n    \"\"\"\n    Retrieves a played time series from a simulation\n\n    Retrieves a played time series from a simulation.\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        var_ids (Any): name of the output variable played to a time series. 'Catchment|StreamflowRate'. If missing, a multivariate time series of all played states is returned; this may be a large amount of data.\n        start_time (Any): An optional parameter, the start of a period to subset the time series\n        end_time (Any): An optional parameter, the end of a period to subset the time series\n\n    Returns:\n        an xts time series, possibly multivariate.\n\n    \"\"\"\n\n    series = None\n    if var_ids is None:\n        var_ids = get_played_varnames(simulation)\n    series = si.internal_get_played_tts(simulation, var_ids)\n    return si.get_ts_window(series, start_time, end_time)\n</code></pre>"},{"location":"play_record/#swift2.play_record.get_played_varnames","title":"<code>get_played_varnames(simulation)</code>","text":"<p>Gets all the names of states fed an input time series</p> <p>Gets all the names of states fed an input time series</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The names of the state variables fed over the simulation with values from a time series</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/play_record.py</code> <pre><code>def get_played_varnames(simulation):\n    \"\"\"\n    Gets all the names of states fed an input time series\n\n    Gets all the names of states fed an input time series\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The names of the state variables fed over the simulation with values from a time series\n\n    \"\"\"\n    return swg.GetPlayedVariableNames_py(simulation)\n</code></pre>"},{"location":"play_record/#swift2.play_record.get_recorded","title":"<code>get_recorded(simulation, var_ids=None, start_time=None, end_time=None)</code>","text":"<p>Retrieves a recorded time series from a simulation</p> <p>Retrieves a recorded time series from a simulation.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>var_ids</code> <code>Any</code> <p>name of the output variable recorded to a time series. 'Catchment|StreamflowRate'. If missing, a multivariate time series of all recorded states is returned; this may be a large amount of data.</p> <code>None</code> <code>start_time</code> <code>Any</code> <p>An optional parameter, the start of a period to subset the time series</p> <code>None</code> <code>end_time</code> <code>Any</code> <p>An optional parameter, the end of a period to subset the time series</p> <code>None</code> <p>Returns:</p> Type Description <p>an xts time series, possibly multivariate.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/play_record.py</code> <pre><code>def get_recorded(\n    simulation: \"Simulation\", var_ids=None, start_time=None, end_time=None\n):\n    \"\"\"\n    Retrieves a recorded time series from a simulation\n\n    Retrieves a recorded time series from a simulation.\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        var_ids (Any): name of the output variable recorded to a time series. 'Catchment|StreamflowRate'. If missing, a multivariate time series of all recorded states is returned; this may be a large amount of data.\n        start_time (Any): An optional parameter, the start of a period to subset the time series\n        end_time (Any): An optional parameter, the end of a period to subset the time series\n\n    Returns:\n        an xts time series, possibly multivariate.\n\n    \"\"\"\n    if si.is_ensemble_forecast_simulation(simulation):\n        return get_recorded_ensemble_forecast(simulation, var_ids, start_time, end_time)\n    else:\n        series = None\n        if var_ids is None:\n            var_ids = get_recorded_varnames(simulation)\n        series = si.internal_get_recorded_tts(simulation, var_ids)\n        return si.get_ts_window(series, start_time, end_time)\n</code></pre>"},{"location":"play_record/#swift2.play_record.get_recorded_ensemble_forecast","title":"<code>get_recorded_ensemble_forecast(simulation, var_id, start_time=None, end_time=None)</code>","text":"<p>Retrieves a recorded time series from a simulation</p> <p>Retrieves a recorded time series from a simulation.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>var_ids</code> <code>Any</code> <p>name of the output variable recorded to a time series. 'Catchment|StreamflowRate'. If missing, a multivariate time series of all recorded states is returned; this may be a large amount of data.</p> required <code>start_time</code> <code>Any</code> <p>NOT USED YET An optional parameter, the start of a period to subset the time series</p> <code>None</code> <code>end_time</code> <code>Any</code> <p>NOT USED YET An optional parameter, the end of a period to subset the time series</p> <code>None</code> <p>Returns:</p> Type Description <p>an xts time series, possibly multivariate.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/play_record.py</code> <pre><code>def get_recorded_ensemble_forecast(\n    simulation, var_id: str, start_time=None, end_time=None\n):\n    \"\"\"\n    Retrieves a recorded time series from a simulation\n\n    Retrieves a recorded time series from a simulation.\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        var_ids (Any): name of the output variable recorded to a time series. 'Catchment|StreamflowRate'. If missing, a multivariate time series of all recorded states is returned; this may be a large amount of data.\n        start_time (Any): NOT USED YET An optional parameter, the start of a period to subset the time series\n        end_time (Any): NOT USED YET An optional parameter, the end of a period to subset the time series\n\n    Returns:\n        an xts time series, possibly multivariate.\n\n    \"\"\"\n    si.check_ensemble_forecast_simulation(simulation)\n    return swg.GetRecordedEnsembleForecastTimeSeries_py(simulation, var_id)\n</code></pre>"},{"location":"play_record/#swift2.play_record.get_recorded_varnames","title":"<code>get_recorded_varnames(simulation)</code>","text":"<p>Gets all the names of the recorded states</p> <p>Gets all the names of the recorded states</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The names of the state variables being recorded into time series</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/play_record.py</code> <pre><code>def get_recorded_varnames(simulation):\n    \"\"\"\n    Gets all the names of the recorded states\n\n    Gets all the names of the recorded states\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The names of the state variables being recorded into time series\n\n    \"\"\"\n    return swg.GetRecordedVariableNames_py(simulation)\n</code></pre>"},{"location":"play_record/#swift2.play_record.play_ensemble_forecast_input","title":"<code>play_ensemble_forecast_input(simulation, input_ts, var_id)</code>","text":"<p>Sets time series as input to a simulation</p> <p>Sets time series as input to a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Any</code> <p>an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"ENSEMBLE_FORECAST_SIMULATION_PTR\"</p> required <code>input_ts</code> <code>Any</code> <p>an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"ENSEMBLE_FORECAST_TIME_SERIES_PTR\"</p> required <code>var_id</code> <code>Any</code> <p>character of length one, the variable identifier to use</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/play_record.py</code> <pre><code>def play_ensemble_forecast_input(\n    simulation: \"EnsembleForecastSimulation\",\n    input_ts: \"EnsembleForecastTimeSeries\",\n    var_id: str,\n) -&gt; None:\n    \"\"\"\n    Sets time series as input to a simulation\n\n    Sets time series as input to a simulation\n\n    Args:\n        simulation (Any): an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"ENSEMBLE_FORECAST_SIMULATION_PTR\"\n        input_ts (Any): an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"ENSEMBLE_FORECAST_TIME_SERIES_PTR\"\n        var_id (Any): character of length one, the variable identifier to use\n\n    \"\"\"\n    si.check_ensemble_forecast_simulation(simulation)\n    si.check_ensemble_forecast_time_series(input_ts)\n    assert isinstance(var_id, str)\n    swg.PlayEnsembleForecastTimeSeries_py(simulation, input_ts, var_id)\n</code></pre>"},{"location":"play_record/#swift2.play_record.play_input","title":"<code>play_input(simulation, input_ts, var_ids=None)</code>","text":"<p>Sets time series as input to a simulation</p> <p>Sets time series as input to a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>input_ts</code> <code>Any</code> <p>an xts time series, or an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"ENSEMBLE_FORECAST_TIME_SERIES_PTR\". if an xts time series column names must be valid model variable identifiers, unless explicitely provided via varIds</p> required <code>var_ids</code> <code>Any</code> <p>optional character, the variable identifiers to use, overriding the column names of the inputTs. If not NULL, must be of length equal to the number of columns in inputTs</p> <code>None</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/play_record.py</code> <pre><code>def play_input(\n    simulation: \"NdSimulation\", input_ts: \"TimeSeriesLike\", var_ids: VecStr = None\n) -&gt; None:\n    \"\"\"\n    Sets time series as input to a simulation\n\n    Sets time series as input to a simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        input_ts (Any): an xts time series, or an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"ENSEMBLE_FORECAST_TIME_SERIES_PTR\". if an xts time series column names must be valid model variable identifiers, unless explicitely provided via varIds\n        var_ids (Any): optional character, the variable identifiers to use, overriding the column names of the inputTs. If not NULL, must be of length equal to the number of columns in inputTs\n\n    \"\"\"\n    if si.is_ensemble_forecast_simulation(\n        simulation\n    ) and si.is_ensemble_forecast_time_series(input_ts):\n        play_ensemble_forecast_input(simulation, input_ts, var_ids)\n    elif si.is_ensemble_simulation(\n        simulation\n    ):  # ??? and si.is_ensemble_forecast_time_series(input_ts):\n        raise NotImplementedError(\"play input into ensemble simulation not supported\")\n    # } else {\n    # stopifnot(is.xts(input_ts))\n    else:\n        play_singular_simulation(simulation, input_ts, var_ids)\n</code></pre>"},{"location":"play_record/#swift2.play_record.play_inputs","title":"<code>play_inputs(simulation, data_library, model_var_id, data_id, resample='')</code>","text":"<p>Assign input time series from a time series library to a model simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>data_library</code> <code>TimeSeriesLibrary</code> <p>external pointer type ENSEMBLE_DATA_SET_PTR, or a Python class wrapper around it </p> required <code>model_var_id</code> <code>str or sequence of str</code> <p>model state variable unique identifier(s)</p> required <code>data_id</code> <code>str or sequence of str</code> <p>identifier(s) for data in the data_library. If length is not the same as model_var_id, the elements of data_id are reused to match it</p> required <code>resample</code> <code>str or sequence of str</code> <p>identifier(s) for how the series is resampled (aggregated or disaggregated). If length is not the same as model_var_id, the elements of resample are reused to match it</p> <code>''</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/play_record.py</code> <pre><code>def play_inputs(\n    simulation: \"Simulation\", data_library:uc.TimeSeriesLibrary, model_var_id:\"VecStr\", data_id:\"VecStr\", resample:\"VecStr\"=\"\"\n):\n    \"\"\"\n    Assign input time series from a time series library to a model simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        data_library (TimeSeriesLibrary): external pointer type ENSEMBLE_DATA_SET_PTR, or a Python class wrapper around it \n        model_var_id (str or sequence of str): model state variable unique identifier(s)\n        data_id (str or sequence of str): identifier(s) for data in the data_library. If length is not the same as model_var_id, the elements of data_id are reused to match it\n        resample (str or sequence of str): identifier(s) for how the series is resampled (aggregated or disaggregated). If length is not the same as model_var_id, the elements of resample are reused to match it\n\n    \"\"\"\n    # model_var_id &lt;- as.character(model_var_id)\n    # data_id &lt;- as.character(data_id)\n    # resample &lt;- as.character(resample)\n    # TODO: match the behavior of R, perhaps.\n    assert len(model_var_id) == len(data_id)\n    assert len(model_var_id) == len(resample)\n    # if(len(model_var_id) != len(data_id)):\n    #     # warning('Reusing argument `data_id` to match length of `model_var_id`')\n    #     data_id = np.repeat(data_id, length.out=length(model_var_id))\n\n    # if(length(resample)!=length(model_var_id)) {\n    # if(length(resample) != 1 || resample[1] != '') warning('Reusing argument `resample` to match the length of `model_var_id`')\n    # resample &lt;- rep(resample, length.out=length(model_var_id))\n    # }\n    swg.PlayDatasetInputs_py(\n        simulation, data_library, model_var_id, data_id, resample, len(model_var_id)\n    )\n</code></pre>"},{"location":"play_record/#swift2.play_record.play_subarea_input","title":"<code>play_subarea_input(simulation, input, subarea_name, input_name)</code>","text":"<p>Sets time series as input to a simulation</p> <p>Sets time series as input to a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>input</code> <code>Any</code> <p>an xts time series.</p> required <code>subarea_name</code> <code>Any</code> <p>a valid name of the subarea</p> required <code>input_name</code> <code>Any</code> <p>the name of the input variable to the model (i.e. 'P' for the precip of GR5H)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/play_record.py</code> <pre><code>def play_subarea_input(simulation: \"Simulation\", input, subarea_name, input_name):\n    \"\"\"\n    Sets time series as input to a simulation\n\n    Sets time series as input to a simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        input (Any): an xts time series.\n        subarea_name (Any): a valid name of the subarea\n        input_name (Any): the name of the input variable to the model (i.e. 'P' for the precip of GR5H)\n\n    \"\"\"\n    play_input(simulation, input, _mkid(\"subarea\", subarea_name, input_name))\n</code></pre>"},{"location":"play_record/#swift2.play_record.record_state","title":"<code>record_state(simulation, var_ids=CATCHMENT_FLOWRATE_VARID, recording_provider=None, data_ids=None)</code>","text":"<p>Record a time series of one of the state of the model</p> <p>Record a time series of one of the state of the model</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Any</code> <p>an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"MODEL_SIMULATION_PTR\", \"ENSEMBLE_SIMULATION_PTR\" or \"ENSEMBLE_FORECAST_SIMULATION_PTR\"</p> required <code>var_ids</code> <code>VecStr</code> <p>identifier(s) of the output variable recorded to a time series, e.g. 'Catchment|StreamflowRate' or 'subcatchment.Subarea.runoff'. Defaults to CATCHMENT_FLOWRATE_VARID.</p> <code>CATCHMENT_FLOWRATE_VARID</code> <code>recording_provider</code> <code>TimeSeriesLibrary</code> <p>description. Defaults to None.</p> <code>None</code> <code>data_ids</code> <code>VecStr</code> <p>description. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/play_record.py</code> <pre><code>def record_state(\n    simulation,\n    var_ids: VecStr = CATCHMENT_FLOWRATE_VARID,\n    recording_provider: \"TimeSeriesLibrary\" = None,\n    data_ids: \"VecStr\" = None,\n):\n    \"\"\"\n    Record a time series of one of the state of the model\n\n    Record a time series of one of the state of the model\n\n    Args:\n        simulation (Any): an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"MODEL_SIMULATION_PTR\", \"ENSEMBLE_SIMULATION_PTR\" or \"ENSEMBLE_FORECAST_SIMULATION_PTR\"\n        var_ids (VecStr, optional): identifier(s) of the output variable recorded to a time series, e.g. 'Catchment|StreamflowRate' or 'subcatchment.Subarea.runoff'. Defaults to CATCHMENT_FLOWRATE_VARID.\n        recording_provider (TimeSeriesLibrary, optional): _description_. Defaults to None.\n        data_ids (VecStr, optional): _description_. Defaults to None.\n\n    Raises:\n        ValueError: _description_\n    \"\"\"\n    # checkRecordingConsistency(var_ids, recording_provider, data_ids)\n    # var_ids &lt;- as.character(var_ids)\n    # data_ids &lt;- as.character(data_ids)\n    # recordSingularState(simulation, var_ids, recording_provider, data_ids)Err\n    if si.is_ensemble_forecast_simulation(simulation):\n        record_ensemble_forecast_state(\n            simulation, var_ids, recording_provider, data_ids\n        )\n    elif si.is_ensemble_simulation(simulation):\n        record_ensemble_state(simulation, var_ids, recording_provider, data_ids)\n    elif si.is_singular_simulation(simulation):\n        record_singular_state(simulation, var_ids, recording_provider, data_ids)\n    else:\n        raise ValueError(\"Unknown type of simulation\")\n</code></pre>"},{"location":"proto/","title":"Module proto","text":"<p>Prototypes</p>"},{"location":"prototypes/","title":"Module prototypes","text":""},{"location":"prototypes/#swift2.prototypes.estimate_transformation_parameters","title":"<code>estimate_transformation_parameters(calib_obs, estimation_start, estimation_end, censor_threshold, exclusion, exclusion_start, exclusion_end, termination_condition=None)</code>","text":"<p>Estimate the transformation parameters for a log-likelihood for a series of observations</p> <p>Parameters:</p> Name Type Description Default <code>calib_obs</code> <code>TimeSeriesLike</code> <p>An timeseries of observed data</p> required <code>estimation_start</code> <code>datetime</code> <p>Start of estimation period</p> required <code>estimation_end</code> <code>datetime</code> <p>End of estimation period</p> required <code>censor_threshold</code> <code>float</code> <p>The value below which observations are treated a censored data (Default=0.0)</p> required <code>exclusion</code> <code>bool</code> <p>Start of period exclued from estimation</p> required <code>exclusion_start</code> <code>datetime</code> <p>End of period exclued from estimation</p> required <code>exclusion_end</code> <code>datetime</code> <p>Use the exclusion period (bool)</p> required <code>termination_condition</code> <code>SceTerminationCondition</code> <p>A SWIFT termination condition used by the optimisation. Default max runtime of ~3 minutes if None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>HypercubeParameteriser</code> <code>HypercubeParameteriser</code> <p>transformation parameters</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/prototypes.py</code> <pre><code>def estimate_transformation_parameters(\n    calib_obs: TimeSeriesLike,\n    estimation_start: datetime,\n    estimation_end: datetime,\n    censor_threshold: float,\n    exclusion: bool,\n    exclusion_start: datetime,\n    exclusion_end: datetime,\n    termination_condition: \"SceTerminationCondition\" = None,\n) -&gt; \"HypercubeParameteriser\":\n    \"\"\"Estimate the transformation parameters for a log-likelihood for a series of observations\n\n    Args:\n        calib_obs (TimeSeriesLike):  An timeseries of observed data\n        estimation_start (datetime): Start of estimation period\n        estimation_end (datetime): End of estimation period\n        censor_threshold (float): The value below which observations are treated a censored data (Default=0.0)\n        exclusion (bool): Start of period exclued from estimation\n        exclusion_start (datetime): End of period exclued from estimation\n        exclusion_end (datetime): Use the exclusion period (bool)\n        termination_condition (SceTerminationCondition): A SWIFT termination condition used by the optimisation. Default max runtime of ~3 minutes if None.\n\n    Returns:\n        HypercubeParameteriser: transformation parameters\n    \"\"\"\n    import swift2.internal as si\n\n    CENS_OPTION = 2\n    simple_ts = si.simplify_time_series(calib_obs)\n    if termination_condition is None:\n        termination_condition = get_max_runtime_termination()\n\n    return swg.EstimateTransformationParameters_py(\n        obsValues=simple_ts[si.TS_INTEROP_VALUES_KEY],\n        obsGeom=simple_ts[si.TS_INTEROP_GEOM_KEY],\n        estimationStart=estimation_start,\n        estimationEnd=estimation_end,\n        censThr=censor_threshold,\n        censOpt=CENS_OPTION,\n        exclusionStart=exclusion_start,\n        exclusionEnd=exclusion_end,\n        exclusion=exclusion,\n        terminationCondition=termination_condition,\n    )\n</code></pre>"},{"location":"simulation/","title":"Module simulation","text":""},{"location":"simulation/#swift2.simulation.check_simulation","title":"<code>check_simulation(simulation)</code>","text":"<p>Checks whether a simulation is configured to a state where it is executable</p> <p>Checks whether a simulation is configured to a state where it is executable</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def check_simulation(simulation) -&gt; Dict:\n    \"\"\"\n    Checks whether a simulation is configured to a state where it is executable\n\n    Checks whether a simulation is configured to a state where it is executable\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    \"\"\"\n    # Trying to design this such that we can have several types of messages\n    return {\"errors\": swg.CheckSimulationErrors_py(simulation)}\n</code></pre>"},{"location":"simulation/#swift2.simulation.create_catchment","title":"<code>create_catchment(node_ids, node_names, link_ids, link_names, link_from_node, link_to_node, runoff_model_name='GR4J', areas_km2=None)</code>","text":"<p>Create a SWIFT catchment with a specified hydrologic model</p> <p>Create a SWIFT catchment with a specified hydrologic model. This function is intended mostly for testing, not for usual modelling code.</p> <p>Parameters:</p> Name Type Description Default <code>node_ids</code> <code>Any</code> <p>character, node unique identifiers</p> required <code>node_names</code> <code>Any</code> <p>character, node display names</p> required <code>link_ids</code> <code>Any</code> <p>character, links unique identifiers</p> required <code>link_names</code> <code>Any</code> <p>character, links display names</p> required <code>link_from_node</code> <code>Any</code> <p>character, identifier of the links' upstream node</p> required <code>link_to_node</code> <code>Any</code> <p>character, identifier of the links' downstream node</p> required <code>runoff_model_name</code> <code>Any</code> <p>A valid, known SWIFT model name (e.g. 'GR5H')</p> <code>'GR4J'</code> <code>areas_km2</code> <code>Any</code> <p>The areas in square kilometres</p> <code>None</code> <p>Returns:</p> Type Description <p>A SWIFT simulation object (i.e. a model runner)</p> <p>Examples:</p> <p>TODO</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def create_catchment(\n    node_ids: List,\n    node_names: List,\n    link_ids: List,\n    link_names: List,\n    link_from_node: List,\n    link_to_node: List,\n    runoff_model_name: str = \"GR4J\",\n    areas_km2: List[float] = None,\n):\n    \"\"\"\n    Create a SWIFT catchment with a specified hydrologic model\n\n    Create a SWIFT catchment with a specified hydrologic model.\n    This function is intended mostly for testing, not for usual modelling code.\n\n    Args:\n        node_ids (Any): character, node unique identifiers\n        node_names (Any): character, node display names\n        link_ids (Any): character, links unique identifiers\n        link_names (Any): character, links display names\n        link_from_node (Any): character, identifier of the links' upstream node\n        link_to_node (Any): character, identifier of the links' downstream node\n        runoff_model_name (Any): A valid, known SWIFT model name (e.g. 'GR5H')\n        areas_km2 (Any): The areas in square kilometres\n\n    Returns:\n        A SWIFT simulation object (i.e. a model runner)\n\n    Examples:\n        TODO\n\n    \"\"\"\n    # &gt;&gt;&gt; # nodeIds=paste0('n', 1:6)\n    # &gt;&gt;&gt; # linkIds = paste0('lnk', 1:5)\n    # &gt;&gt;&gt; # defn &lt;- list(\n    # &gt;&gt;&gt; # nodeIds=nodeIds,\n    # &gt;&gt;&gt; # nodeNames = paste0(nodeIds, '_name'),\n    # &gt;&gt;&gt; # linkIds=linkIds,\n    # &gt;&gt;&gt; # linkNames = paste0(linkIds, '_name'),\n    # &gt;&gt;&gt; # fromNode = paste0('n', c(2,5,4,3,1)),\n    # &gt;&gt;&gt; # toNode = paste0('n', c(6,2,2,4,4)),\n    # &gt;&gt;&gt; # areasKm2 = c(1.2, 2.3, 4.4, 2.2, 1.5),\n    # &gt;&gt;&gt; # runoffModel = 'GR4J'\n    # &gt;&gt;&gt; # )\n    # &gt;&gt;&gt; # ms &lt;- createCatchment(defn$nodeIds, defn$nodeNames, defn$linkIds, defn$linkNames, defn$fromNode, defn$toNode, defn$runoffModel, defn$areasKm2)\n    if areas_km2 is None:\n        areas_km2 = rep(1.0, len(link_ids))\n    return swg.CreateCatchment_py(\n        numNodes=len(node_ids),\n        nodeIds=node_ids,\n        nodeNames=node_names,\n        numLinks=len(link_ids),\n        linkIds=link_ids,\n        linkNames=link_names,\n        linkFromNode=link_from_node,\n        linkToNode=link_to_node,\n        runoffModelName=runoff_model_name,\n        areasKm2=areas_km2,\n    )\n</code></pre>"},{"location":"simulation/#swift2.simulation.create_ensemble_forecast_simulation","title":"<code>create_ensemble_forecast_simulation(simulation, data_library, start, end, input_map, lead_time, ensemble_size, n_time_steps_between_forecasts)</code>","text":"<p>Create an ensemble forecast simulation</p> <p>Create an ensemble forecast simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>data_library</code> <code>Any</code> <p>external pointer type ENSEMBLE_DATA_SET_PTR, or a Python class wrapper around it </p> required <code>start</code> <code>Any</code> <p>the start date of the simulation. The time zone will be forced to UTC.</p> required <code>end</code> <code>Any</code> <p>the end date of the simulation. The time zone will be forced to UTC.</p> required <code>input_map</code> <code>Any</code> <p>a named list were names are the data library data identifiers, and values are character vectors with model state identifiers.</p> required <code>lead_time</code> <code>Any</code> <p>integer, the length in time steps of the forecasts.</p> required <code>ensemble_size</code> <code>Any</code> <p>ensemble size</p> required <code>n_time_steps_between_forecasts</code> <code>Any</code> <p>nTimeStepsBetweenForecasts</p> required <p>Returns:</p> Type Description <p>An external pointer</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def create_ensemble_forecast_simulation(\n    simulation,\n    data_library,\n    start,\n    end,\n    input_map: Dict[str, List[str]],\n    lead_time,\n    ensemble_size,\n    n_time_steps_between_forecasts,\n):\n    \"\"\"\n    Create an ensemble forecast simulation\n\n    Create an ensemble forecast simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        data_library (Any): external pointer type ENSEMBLE_DATA_SET_PTR, or a Python class wrapper around it \n        start (Any): the start date of the simulation. The time zone will be forced to UTC.\n        end (Any): the end date of the simulation. The time zone will be forced to UTC.\n        input_map (Any): a named list were names are the data library data identifiers, and values are character vectors with model state identifiers.\n        lead_time (Any): integer, the length in time steps of the forecasts.\n        ensemble_size (Any): ensemble size\n        n_time_steps_between_forecasts (Any): nTimeStepsBetweenForecasts\n\n    Returns:\n        An external pointer\n\n    \"\"\"\n    s = as_timestamp(start)\n    e = as_timestamp(end)\n    simulation_length = swg.GetNumStepsForTimeSpan_py(simulation, s, e)\n    ef_simulation = swg.CreateEnsembleForecastSimulation_py(\n        simulation,\n        s,\n        lead_time,\n        ensemble_size,\n        simulation_length,\n        nTimeStepsBetweenForecasts=n_time_steps_between_forecasts,\n    )\n    data_ids = input_map.keys()\n    for data_id in data_ids:\n        identifiers = input_map[data_id]\n        swg.PlayDatasetEnsembleForecastInput_py(\n            ef_simulation,\n            data_library,\n            identifiers,\n            rep(data_id, len(identifiers)),\n            len(identifiers),\n        )\n    return ef_simulation\n</code></pre>"},{"location":"simulation/#swift2.simulation.create_subarea","title":"<code>create_subarea(model_name, area_km2)</code>","text":"<p>Create a SWIFT subarea with a specified hydrologic model</p> <p>Create a SWIFT subarea with a specified hydrologic model</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>Any</code> <p>A valid, known SWIFT model name (e.g. 'GR5H')</p> required <code>area_km2</code> <code>Any</code> <p>The area in square kilometres</p> required <p>Returns:</p> Type Description <p>A SWIFT simulation object (i.e. a model runner)</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def create_subarea(model_name, area_km2):\n    \"\"\"\n    Create a SWIFT subarea with a specified hydrologic model\n\n    Create a SWIFT subarea with a specified hydrologic model\n\n    Args:\n        model_name (Any): A valid, known SWIFT model name (e.g. 'GR5H')\n        area_km2 (Any): The area in square kilometres\n\n    Returns:\n        A SWIFT simulation object (i.e. a model runner)\n\n    \"\"\"\n    return swg.CreateSubarea_py(model_name, area_km2)\n</code></pre>"},{"location":"simulation/#swift2.simulation.create_subarea_simulation","title":"<code>create_subarea_simulation(data_id='MMH', simul_start='1990-01-01', simul_end='2005-12-31', model_id='GR4J', tstep='daily', varname_rain='P', varname_pet='E', data_rain_id='rain', data_evap_id='evap')</code>","text":"<p>Creates a one sub-catchment simulation</p> <p>Creates a one sub-catchment simulation. This function is intended for creating sample simulations, not for use in production.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>str</code> <p>data identifier in swift_sample_data</p> <code>'MMH'</code> <code>simul_start</code> <code>str</code> <p>ISO string for the simulation start date time</p> <code>'1990-01-01'</code> <code>simul_end</code> <code>str</code> <p>ISO string for the simulation end date time</p> <code>'2005-12-31'</code> <code>model_id</code> <code>str</code> <p>model identifier</p> <code>'GR4J'</code> <code>tstep</code> <code>str</code> <p>character, 'daily' or 'hourly'</p> <code>'daily'</code> <code>varname_rain</code> <code>str</code> <p>variable name to assign rainfall to</p> <code>'P'</code> <code>varname_pet</code> <code>str</code> <p>variable name to assign PET to</p> <code>'E'</code> <code>data_rain_id</code> <code>str</code> <p>key to use to retrieve the rainfall series from the sample data</p> <code>'rain'</code> <code>data_evap_id</code> <code>str</code> <p>key to use to retrieve the evaporation series from the sample data</p> <code>'evap'</code> <p>Returns:</p> Type Description <p>A SWIFT simulation object, clone of the simulation but with a new model type in use.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def create_subarea_simulation(\n    data_id:str=\"MMH\",\n    simul_start:str=\"1990-01-01\",\n    simul_end:str=\"2005-12-31\",\n    model_id:str=\"GR4J\",\n    tstep:str=\"daily\",\n    varname_rain:str=\"P\",\n    varname_pet:str=\"E\",\n    data_rain_id:str=\"rain\",\n    data_evap_id:str=\"evap\",\n):\n    \"\"\"\n    Creates a one sub-catchment simulation\n\n    Creates a one sub-catchment simulation. This function is intended for creating sample simulations, not for use in production.\n\n    Args:\n        data_id (str): data identifier in swift_sample_data\n        simul_start (str): ISO string for the simulation start date time\n        simul_end (str): ISO string for the simulation end date time\n        model_id (str): model identifier\n        tstep (str): character, 'daily' or 'hourly'\n        varname_rain (str): variable name to assign rainfall to\n        varname_pet (str): variable name to assign PET to\n        data_rain_id (str): key to use to retrieve the rainfall series from the sample data\n        data_evap_id (str): key to use to retrieve the evaporation series from the sample data\n\n    Returns:\n        A SWIFT simulation object, clone of the simulation but with a new model type in use.\n\n    \"\"\"\n    from swift2.doc_helper import sample_series\n    from swift2.wrap.swift_wrap_generated import CreateSubarea_py\n\n    s_span = slice(simul_start, simul_end)\n    rain = sample_series(data_id, data_rain_id)[s_span]\n    evap = sample_series(data_id, data_evap_id)[s_span]\n\n    ms = CreateSubarea_py(model_id, 1.0)\n    s = rain.index[0]\n    e = rain.index[-1]\n    set_simulation_span(ms, s, e)\n    set_simulation_time_step(ms, tstep)\n\n    sa_name = swg.GetSubareaNames_py(ms)[0]\n    play_subarea_input(ms, rain, sa_name, varname_rain)\n    play_subarea_input(ms, evap, sa_name, varname_pet)\n    return ms\n</code></pre>"},{"location":"simulation/#swift2.simulation.exec_simulation","title":"<code>exec_simulation(simulation, reset_initial_states=True)</code>","text":"<p>Execute a simulation</p> <p>Execute a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>reset_initial_states</code> <code>Any</code> <p>logical, should the states of the model be reinitialized before the first time step.</p> <code>True</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def exec_simulation(simulation: \"Simulation\", reset_initial_states=True):\n    \"\"\"\n    Execute a simulation\n\n    Execute a simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        reset_initial_states (Any): logical, should the states of the model be reinitialized before the first time step.\n\n    \"\"\"\n    if simulation.type_id == \"ENSEMBLE_FORECAST_SIMULATION_PTR\":\n        swg.ExecuteEnsembleForecastSimulation_py(simulation)\n    elif simulation.type_id == \"ENSEMBLE_SIMULATION_PTR\":\n        raise NotImplementedError(\n            \"execution api entry point for 'ENSEMBLE_SIMULATION_PTR' is not available??\"\n        )\n    else:\n        swg.ExecuteSimulation_py(simulation, reset_initial_states)\n</code></pre>"},{"location":"simulation/#swift2.simulation.get_link_ids","title":"<code>get_link_ids(simulation)</code>","text":"<p>Gets all the identifiers of the links in the catchment</p> <p>Gets all the identifiers of the links in the catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The identifiers of the links in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_link_ids(simulation):\n    \"\"\"\n    Gets all the identifiers of the links in the catchment\n\n    Gets all the identifiers of the links in the catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The identifiers of the links in the catchment\n\n    \"\"\"\n    return swg.GetLinkIdentifiers_py(simulation)\n</code></pre>"},{"location":"simulation/#swift2.simulation.get_link_names","title":"<code>get_link_names(simulation)</code>","text":"<p>Gets all the names of the links in the catchment</p> <p>Gets all the names of the links in the catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The names of the links in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_link_names(simulation):\n    \"\"\"\n    Gets all the names of the links in the catchment\n\n    Gets all the names of the links in the catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The names of the links in the catchment\n\n    \"\"\"\n\n    return swg.GetLinkNames_py(simulation)\n</code></pre>"},{"location":"simulation/#swift2.simulation.get_node_ids","title":"<code>get_node_ids(simulation)</code>","text":"<p>Gets all the identifiers of the nodes in the catchment</p> <p>Gets all the identifiers of the nodes in the catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The identifiers of the nodes in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_node_ids(simulation):\n    \"\"\"\n    Gets all the identifiers of the nodes in the catchment\n\n    Gets all the identifiers of the nodes in the catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The identifiers of the nodes in the catchment\n\n    \"\"\"\n    return swg.GetNodeIdentifiers_py(simulation)\n</code></pre>"},{"location":"simulation/#swift2.simulation.get_node_names","title":"<code>get_node_names(simulation)</code>","text":"<p>Gets all the names of the nodes in the catchment</p> <p>Gets all the names of the nodes in the catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The names of the nodes in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_node_names(simulation):\n    \"\"\"\n    Gets all the names of the nodes in the catchment\n\n    Gets all the names of the nodes in the catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The names of the nodes in the catchment\n\n    \"\"\"\n    return swg.GetNodeNames_py(simulation)\n</code></pre>"},{"location":"simulation/#swift2.simulation.get_state_value","title":"<code>get_state_value(simulation, var_id)</code>","text":"<p>Gets the value(s) of a model state(s)</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>var_id</code> <code>VecStr</code> <p>string or sequence of str, model variable state identifier(s)</p> required <p>Returns:</p> Type Description <p>numeric vector, value(s) of the requested model states</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_state_value(simulation: \"Simulation\", var_id: \"VecStr\"):\n    \"\"\"\n    Gets the value(s) of a model state(s)\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        var_id (VecStr): string or sequence of str, model variable state identifier(s)\n\n    Returns:\n        numeric vector, value(s) of the requested model states\n\n    \"\"\"\n    if isinstance(var_id, str):\n        var_ids = [var_id]\n    else:\n        var_ids = var_id\n    #  if(is.numeric(value)):\n    f = swg.GetVariable_py\n    #  } else if(is.integer(value)):\n    #    f = GetVariableInt_R\n    #  } else if(is.logical(value)):\n    #    f = GetVariableBool_R\n    #  else:\n    #    stop(paste('value type', type(value), 'is not supported by getStateValue'))\n    #  }\n    return dict([(v, f(simulation, v)) for v in var_ids])\n</code></pre>"},{"location":"simulation/#swift2.simulation.get_subarea_ids","title":"<code>get_subarea_ids(simulation)</code>","text":"<p>Gets all the identifiers of the sub-areas in the catchment</p> <p>Gets all the identifiers of the sub-areas in the catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The identifiers of the sub-areas in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_subarea_ids(simulation):\n    \"\"\"\n    Gets all the identifiers of the sub-areas in the catchment\n\n    Gets all the identifiers of the sub-areas in the catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The identifiers of the sub-areas in the catchment\n\n    \"\"\"\n    return swg.GetSubareaIdentifiers_py(simulation)\n</code></pre>"},{"location":"simulation/#swift2.simulation.get_subarea_names","title":"<code>get_subarea_names(simulation)</code>","text":"<p>Gets all the names of the sub-areas in the catchment</p> <p>Gets all the names of the sub-areas in the catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <p>Returns:</p> Type Description <p>The names of the sub-areas in the catchment</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_subarea_names(simulation):\n    \"\"\"\n    Gets all the names of the sub-areas in the catchment\n\n    Gets all the names of the sub-areas in the catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n\n    Returns:\n        The names of the sub-areas in the catchment\n\n    \"\"\"\n\n    return swg.GetSubareaNames_py(simulation)\n</code></pre>"},{"location":"simulation/#swift2.simulation.get_variable_ids","title":"<code>get_variable_ids(simulation, element_id=None, full_id=True)</code>","text":"<p>Gets all the names of the variables of an element within a catchment</p> <p>Gets all the names of the variables of an element (link, node, subarea) within a catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>element_id</code> <code>Any</code> <p>a character, identifier of the element within the catchment</p> <code>None</code> <code>full_id</code> <code>Any</code> <p>boolean, if TRUE return the full hierarchical identifier</p> <code>True</code> <p>Returns:</p> Type Description <p>character vector, names (identifiers) of model states in the element</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def get_variable_ids(simulation: \"Simulation\", element_id=None, full_id=True):\n    \"\"\"\n    Gets all the names of the variables of an element within a catchment\n\n    Gets all the names of the variables of an element (link, node, subarea) within a catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        element_id (Any): a character, identifier of the element within the catchment\n        full_id (Any): boolean, if TRUE return the full hierarchical identifier\n\n    Returns:\n        character vector, names (identifiers) of model states in the element\n\n    \"\"\"\n    s = swg.GetElementVarIdentifiers_py(simulation, element_id)\n    if full_id and element_id is not None:\n        s = [_mkid(element_id, v) for v in s]\n    return s\n</code></pre>"},{"location":"simulation/#swift2.simulation.is_variable_id","title":"<code>is_variable_id(simulation, var_id)</code>","text":"<p>Is a variable identifier valid for a simulation</p> <p>Is a variable identifier valid for a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>var_id</code> <code>Any</code> <p>a character, identifier(s) of the variable(s)</p> required <p>Returns:</p> Type Description <p>logical vector</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def is_variable_id(simulation: \"Simulation\", var_id: \"VecStr\"):\n    \"\"\"\n    Is a variable identifier valid for a simulation\n\n    Is a variable identifier valid for a simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        var_id (Any): a character, identifier(s) of the variable(s)\n\n    Returns:\n        logical vector\n\n    \"\"\"\n    if is_common_iterable(var_id):\n        return dict(\n            [(v, swg.IsValidVariableIdentifier_py(simulation, v)) for v in var_id]\n        )\n    else:\n        return swg.IsValidVariableIdentifier_py(simulation, var_id)\n</code></pre>"},{"location":"simulation/#swift2.simulation.reset_model_states","title":"<code>reset_model_states(simulation)</code>","text":"<p>Reset the model states of a simulation, and apply one or more state initialers if the simulation is configured with any.</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>simulation</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def reset_model_states(simulation: \"Simulation\"):\n    \"\"\"Reset the model states of a simulation, and apply one or more state initialers if the simulation is configured with any.\n\n    Args:\n        simulation (Simulation): simulation\n    \"\"\"\n    swg.ResetModelStates_py(simulation)\n</code></pre>"},{"location":"simulation/#swift2.simulation.set_error_correction_model","title":"<code>set_error_correction_model(simulation, model_id, element_id, length=1, seed=0)</code>","text":"<p>Add an error correction model to an element in a catchment</p> <p>Add an error correction model to an element in a catchment</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>model_id</code> <code>str</code> <p>the identifier of the new model to use, e.g. 'ERRIS'</p> required <code>element_id</code> <code>str</code> <p>the identifier of the catchment element (node, link, subcatchment) whose outflow rate is corrected.</p> required <code>length</code> <code>int</code> <p>other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.</p> <code>1</code> <code>seed</code> <code>int</code> <p>other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.</p> <code>0</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def set_error_correction_model(\n    simulation, model_id, element_id, length=1, seed=0\n):  # TODO: revert to use ... if other kind of ECM\n    \"\"\"\n    Add an error correction model to an element in a catchment\n\n    Add an error correction model to an element in a catchment\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        model_id (str): the identifier of the new model to use, e.g. 'ERRIS'\n        element_id (str): the identifier of the catchment element (node, link, subcatchment) whose outflow rate is corrected.\n        length (int): other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.\n        seed (int): other parameters to pass to the creation of the error correction model. Currently length of the AR model only supported.\n\n    \"\"\"\n    swg.SetErrorCorrectionModel_py(simulation, model_id, element_id, length, seed)\n</code></pre>"},{"location":"simulation/#swift2.simulation.set_simulation_span","title":"<code>set_simulation_span(simulation, start, end)</code>","text":"<p>Sets simulation span</p> <p>Sets the simulation span</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>start</code> <code>Any</code> <p>the start date of the simulation. The time zone will be forced to UTC.</p> required <code>end</code> <code>Any</code> <p>the end date of the simulation. The time zone will be forced to UTC.</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def set_simulation_span(simulation: \"Simulation\", start, end):\n    \"\"\"\n    Sets simulation span\n\n    Sets the simulation span\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        start (Any): the start date of the simulation. The time zone will be forced to UTC.\n        end (Any): the end date of the simulation. The time zone will be forced to UTC.\n\n    \"\"\"\n    s = as_timestamp(start)  # = as_timestamp(start, tz='UTC')\n    e = as_timestamp(end)  # = as_timestamp(end, tz='UTC')\n    swg.SetSpan_py(simulation, s, e)\n</code></pre>"},{"location":"simulation/#swift2.simulation.set_simulation_time_step","title":"<code>set_simulation_time_step(simulation, name)</code>","text":"<p>Sets the time step of a SWIFT simulation</p> <p>Sets the time step of a SWIFT simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>name</code> <code>Any</code> <p>a time step identifier, The identifier is made lower case in the function. Supported time steps include \"hourly\", \"daily\", \"monthly_qpp\", \"monthly\", and time deltas such as \"24:00:00\", \"01:00:00\", \"03:00:00\". An exception is raised if the string could not be parsed.</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def set_simulation_time_step(simulation: \"Simulation\", name: str):\n    \"\"\"\n    Sets the time step of a SWIFT simulation\n\n    Sets the time step of a SWIFT simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        name (Any): a time step identifier, The identifier is made lower case in the function. Supported time steps include \"hourly\", \"daily\", \"monthly_qpp\", \"monthly\", and time deltas such as \"24:00:00\", \"01:00:00\", \"03:00:00\". An exception is raised if the string could not be parsed.\n\n    \"\"\"\n    name = name.lower()\n    # assert name in set(['daily','hourly'])\n    swg.SetTimeStep_py(simulation, name)\n</code></pre>"},{"location":"simulation/#swift2.simulation.set_state_value","title":"<code>set_state_value(simulation, var_id, value)</code>","text":"<p>Sets the value of a model state</p> <p>Sets the value of a model state</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>var_id</code> <code>(str, Sequence[str])</code> <p>character, model variable state identifier(s)</p> required <code>value</code> <code>(float, int, bool, Sequence)</code> <p>numeric value(s)</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def set_state_value(\n    simulation: \"Simulation\",\n    var_id: Union[str, Sequence[str]],\n    value: Union[float, int, bool, Sequence],\n) -&gt; None:\n    \"\"\"\n    Sets the value of a model state\n\n    Sets the value of a model state\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        var_id (str, Sequence[str]): character, model variable state identifier(s)\n        value (float, int, bool, Sequence): numeric value(s)\n\n    \"\"\"\n\n    def func_set_for(v):\n        if isinstance(v, float): # or isinstance(v, np.float): # np obsolete?\n            return swg.SetVariable_py\n        elif isinstance(v, int): # or isinstance(v, np.int):\n            return swg.SetVariableInt_py\n        elif isinstance(v, bool): # or isinstance(v, np.bool8):\n            return swg.SetVariableBool_py\n        else:\n            raise TypeError(\n                \"value type \" + str(type(v)) + \"is not supported by setStateValue\"\n            )\n\n    if isinstance(var_id, str):\n        f = func_set_for(value)\n        f(simulation, var_id, value)\n        return\n    if isinstance(var_id, dict):\n        d = [(k, v) for k, v in var_id.items()]\n        var_id = [x[0] for x in d]\n        value = [x[1] for x in d]\n    if not is_common_iterable(var_id):\n        raise ValueError(\"var_id must be a string, or an iterable of strings\")\n    if not is_common_iterable(value):\n        value = rep(value, len(var_id))\n    else:\n        assert len(var_id) == len(value)\n\n    for i in range(len(var_id)):\n        k = var_id[i]\n        v = value[i]\n        f = func_set_for(v)\n        f(simulation, k, v)\n</code></pre>"},{"location":"simulation/#swift2.simulation.set_states","title":"<code>set_states(simulation, states)</code>","text":"<p>Apply memory states to a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>simulation</p> required <code>states</code> <code>MemoryStates</code> <p>memory states</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def set_states(simulation: \"Simulation\", states: \"MemoryStates\"):\n    \"\"\"Apply memory states to a simulation\n\n    Args:\n        simulation (Simulation): simulation\n        states (MemoryStates): memory states\n    \"\"\"\n    swg.ApplyMemoryStates_py(simulation, states)\n</code></pre>"},{"location":"simulation/#swift2.simulation.snapshot_state","title":"<code>snapshot_state(simulation)</code>","text":"<p>Take a snapshot of the memory states of a simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>model simulation</p> required <p>Returns:</p> Name Type Description <code>MemoryStates</code> <code>MemoryStates</code> <p>memory states, that can be stored and reapplied</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def snapshot_state(simulation: \"Simulation\") -&gt; \"MemoryStates\":\n    \"\"\"Take a snapshot of the memory states of a simulation\n\n    Args:\n        simulation (Simulation): model simulation\n\n    Returns:\n        MemoryStates: memory states, that can be stored and reapplied\n    \"\"\"\n    return swg.SnapshotMemoryStates_py(simulation)\n</code></pre>"},{"location":"simulation/#swift2.simulation.sort_by_execution_order","title":"<code>sort_by_execution_order(simulation, split_element_ids, sorting_option='')</code>","text":"<p>Sort the specified element ids according to the execution order of the simulation</p> <p>Sort the specified element ids according to the execution order of the simulation</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>split_element_ids</code> <code>Any</code> <p>a character vector with element identifiers such as 'node.n1', 'link.linkId_2'</p> required <code>sorting_option</code> <code>Any</code> <p>a character - for future options. Ignored for now.</p> <code>''</code> <p>Returns:</p> Type Description <p>values in split_element_ids sorted by simulation execution order</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def sort_by_execution_order(\n    simulation: \"Simulation\", split_element_ids, sorting_option=\"\"\n):\n    \"\"\"\n    Sort the specified element ids according to the execution order of the simulation\n\n    Sort the specified element ids according to the execution order of the simulation\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        split_element_ids (Any): a character vector with element identifiers such as 'node.n1', 'link.linkId_2'\n        sorting_option (Any): a character - for future options. Ignored for now.\n\n    Returns:\n        values in split_element_ids sorted by simulation execution order\n\n    \"\"\"\n    return swc.sort_simulation_elements_by_run_order_pkg(\n        simulation, split_element_ids, sorting_option\n    )\n</code></pre>"},{"location":"simulation/#swift2.simulation.swap_model","title":"<code>swap_model(simulation, model_id, what='runoff')</code>","text":"<p>Clone and change a simulation, using another runoff model</p> <p>Clone and change a simulation, using another runoff model</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A swift simulation object</p> required <code>model_id</code> <code>Any</code> <p>the identifier of the new model to use, e.g. 'GR4J'</p> required <code>what</code> <code>Any</code> <p>character identifying the type of structure: 'runoff', 'channel_routing'</p> <code>'runoff'</code> <p>Returns:</p> Type Description <p>A SWIFT simulation object, clone of the simulation but with a new model type in use.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/simulation.py</code> <pre><code>def swap_model(simulation: \"Simulation\", model_id, what=\"runoff\"):\n    \"\"\"\n    Clone and change a simulation, using another runoff model\n\n    Clone and change a simulation, using another runoff model\n\n    Args:\n        simulation (Simulation): A swift simulation object\n        model_id (Any): the identifier of the new model to use, e.g. 'GR4J'\n        what (Any): character identifying the type of structure: 'runoff', 'channel_routing'\n\n    Returns:\n        A SWIFT simulation object, clone of the simulation but with a new model type in use.\n\n    \"\"\"\n    if what == \"runoff\":\n        cloned = swg.SwapRunoffModel_py(simulation, model_id)\n    elif what == \"channel_routing\":\n        cloned = swg.CloneModel_py(simulation)\n        swg.SetChannelRoutingModel_py(cloned, model_id)\n    else:\n        raise ValueError(f\"option not supported: {what}\")\n    return cloned\n</code></pre>"},{"location":"statistics/","title":"Module statistics","text":""},{"location":"statistics/#swift2.statistics.createCompositeObjective","title":"<code>createCompositeObjective(simulation, state_name, observation, yamlstring_statistic, start_date, end_date)</code>","text":"<p>Creates a composite objective calculator</p> <p>Creates a composite objective calculator</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A SWIFT simulation object (i.e. a model runner)</p> required <code>state_name</code> <code>Any</code> <p>The name identifying the model state variable to calibrate against the observation</p> required <code>observation</code> <code>Any</code> <p>an xts</p> required <code>yamlstring_statistic</code> <code>Any</code> <p>a yaml string representing objective functions and weights eg...</p> required <code>start_date</code> <code>Any</code> <p>start date of the period to calculate statistics on</p> required <code>end_date</code> <code>Any</code> <p>end date of the period to calculate statistics on</p> required <p>Returns:</p> Type Description <p>objective evaluator</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/statistics.py</code> <pre><code>def createCompositeObjective(\n    simulation, state_name, observation, yamlstring_statistic, start_date, end_date\n):\n    \"\"\"\n    Creates a composite objective calculator\n\n    Creates a composite objective calculator\n\n    Args:\n        simulation (Simulation): A SWIFT simulation object (i.e. a model runner)\n        state_name (Any): The name identifying the model state variable to calibrate against the observation\n        observation (Any): an xts\n        yamlstring_statistic (Any): a yaml string representing objective functions and weights eg...\n        start_date (Any): start date of the period to calculate statistics on\n        end_date (Any): end date of the period to calculate statistics on\n\n    Returns:\n        objective evaluator\n\n    \"\"\"\n    import xarray as xr\n    from cinterop.timeseries import ts_window\n\n    # if not isinstance(observation, xr.DataArray):\n    #     raise ValueError('observation must be an xts object')\n    # if(ncol(observation) != 1):\n    #     stop('observation must have exactly one series')\n    # }\n    observation = ts_window(observation, start_date, end_date)\n    simple_ts = simplify_time_series(observation)\n    return swg.CreateCompositeObservationObjectiveEvaluator_py(\n        simulation,\n        state_name,\n        simple_ts[TS_INTEROP_VALUES_KEY],\n        simple_ts[TS_INTEROP_GEOM_KEY],\n        yamlstring_statistic,\n    )\n</code></pre>"},{"location":"statistics/#swift2.statistics.create_multisite_objective","title":"<code>create_multisite_objective(simulation, statspec, observations, weights)</code>","text":"<p>Creates an objective that combines multiple statistics</p> <p>Creates an objective that combines multiple statistics. Used for joined, \"whole of catchment\" calibration</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A SWIFT simulation object (i.e. a model runner)</p> required <code>statspec</code> <code>DataFrame</code> <p>dataframe defining the objectives used. See function <code>multi_statistic_definition</code> to help build this dataframe.</p> required <code>observations</code> <code>Sequence[TimeSeriesLike]</code> <p>A list of (time series) observations to calculated the statistics. Must be of same length as the number of rows of statspec.</p> required <code>weights</code> <code>Dict[str, float]</code> <p>numeric vector of weights to ponderate each objective.</p> required <code>Examples</code> <p>todo()</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/statistics.py</code> <pre><code>def create_multisite_objective(\n    simulation: \"Simulation\", \n    statspec: pd.DataFrame,\n    observations: Sequence[TimeSeriesLike],\n    weights: Dict[str, float],\n):\n    \"\"\"\n    Creates an objective that combines multiple statistics\n\n    Creates an objective that combines multiple statistics. Used for joined, \"whole of catchment\" calibration\n\n    Args:\n        simulation (Simulation): A SWIFT simulation object (i.e. a model runner)\n        statspec (pd.DataFrame): dataframe defining the objectives used. See function [`multi_statistic_definition`][swift2.statistics.multi_statistic_definition] to help build this dataframe.\n        observations (Sequence[TimeSeriesLike]): A list of (time series) observations to calculated the statistics. Must be of same length as the number of rows of statspec.\n        weights (Dict[str, float]): numeric vector of weights to ponderate each objective.\n\n        Examples:\n            &gt;&gt;&gt; todo()\n    \"\"\"\n    from swift2.wrap.ffi_interop import marshal\n\n    # stopifnot(is.list(observations))\n    # stopifnot(nrow(statspec) == length(observations))\n    # stopifnot(nrow(statspec) == length(weights))\n    interop_obs = [marshal.as_native_time_series(x) for x in observations]\n    defn = {\n        \"Length\": len(statspec),\n        \"Statistics\": statspec,\n        \"Observations\": interop_obs,\n    }\n    obj = swg.CreateMultisiteObjectiveEvaluator_py(simulation, defn, weights)\n    return swg.WrapObjectiveEvaluatorWila_py(obj, True)\n</code></pre>"},{"location":"statistics/#swift2.statistics.create_objective","title":"<code>create_objective(simulation, state_name, observation, statistic, start_date, end_date)</code>","text":"<p>Creates an objective calculator</p> <p>Parameters:</p> Name Type Description Default <code>simulation</code> <code>Simulation</code> <p>A SWIFT simulation object (i.e. a model runner)</p> required <code>state_name</code> <code>Any</code> <p>The name identifying the model state variable to calibrate against the observation</p> required <code>observation</code> <code>TimeSeriesLike</code> <p>an xts</p> required <code>statistic</code> <code>str</code> <p>statistic identifier, e.g. \"NSE\"</p> required <code>start_date</code> <code>ConvertibleToTimestamp</code> <p>start date of the period to calculate statistics on</p> required <code>end_date</code> <code>ConvertibleToTimestamp</code> <p>end date of the period to calculate statistics on</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/statistics.py</code> <pre><code>def create_objective(\n    simulation: \"Simulation\",\n    state_name: str,\n    observation: TimeSeriesLike,\n    statistic: str,\n    start_date: ConvertibleToTimestamp,\n    end_date: ConvertibleToTimestamp,\n):\n    \"\"\"\n    Creates an objective calculator\n\n    Args:\n        simulation (Simulation): A SWIFT simulation object (i.e. a model runner)\n        state_name (Any): The name identifying the model state variable to calibrate against the observation\n        observation (TimeSeriesLike): an xts\n        statistic (str): statistic identifier, e.g. \"NSE\"\n        start_date (ConvertibleToTimestamp): start date of the period to calculate statistics on\n        end_date (ConvertibleToTimestamp): end date of the period to calculate statistics on\n    \"\"\"\n    from swift2.internal import simplify_time_series\n    from cinterop.timeseries import ts_window, as_timestamp\n\n    start_date = as_timestamp(start_date)\n    end_date = as_timestamp(end_date)\n\n    # if(!is.xts(observation)):\n    #     stop('observation must be an xts object')\n    # }\n    # if(ncol(observation) != 1):\n    #     stop('observation must have exactly one series')\n    # }\n    observation = ts_window(observation, start_date, end_date)\n    simple_ts = simplify_time_series(observation)\n    return swg.CreateSingleObservationObjectiveEvaluatorWila_py(\n        simulation,\n        state_name,\n        simple_ts[TS_INTEROP_VALUES_KEY],\n        simple_ts[TS_INTEROP_GEOM_KEY],\n        statistic,\n    )\n</code></pre>"},{"location":"statistics/#swift2.statistics.get_score","title":"<code>get_score(objective_evaluator, p_set)</code>","text":"<p>Evaluate an objective for a given parameterisation</p> <p>Parameters:</p> Name Type Description Default <code>objective_evaluator</code> <code>ObjectiveEvaluator</code> <p>objective evaluator</p> required <code>p_set</code> <code>HypercubeParameteriser</code> <p>parameteriser</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str,Any]: score(s), and a data frame representation of the input parameters.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/statistics.py</code> <pre><code>def get_score(\n    objective_evaluator: \"ObjectiveEvaluator\", p_set: \"HypercubeParameteriser\"\n) -&gt; Dict[str, Any]:\n    \"\"\"Evaluate an objective for a given parameterisation\n\n    Args:\n        objective_evaluator (ObjectiveEvaluator): objective evaluator\n        p_set (HypercubeParameteriser): parameteriser\n\n    Returns:\n        Dict[str,Any]: score(s), and a data frame representation of the input parameters.\n    \"\"\"\n    #  if (p_set.type_id == \"HYPERCUBE_PTR\"):\n    #    p_set = ToHypercubeWila_py(p_set);\n    #  }\n    #  stopifnot(p_set.type_id=='HYPERCUBE_WILA_PTR')\n    return swc.evaluate_score_wila_pkg(objective_evaluator, p_set)\n</code></pre>"},{"location":"statistics/#swift2.statistics.multi_statistic_definition","title":"<code>multi_statistic_definition(model_var_ids, statistic_ids, objective_ids, objective_names, starts, ends)</code>","text":"<p>Collate information for use in multisite multiobjective definition</p> <p>Collate information for use in multisite multiobjective definition</p> <p>Parameters:</p> Name Type Description Default <code>model_var_ids</code> <code>Any</code> <p>character vector, model state identifiers where statistics are calculated</p> required <code>statistic_ids</code> <code>Any</code> <p>character vector, identifiers for bivariate statistics (e.g. nse, lognse, et.)</p> required <code>objective_ids</code> <code>Any</code> <p>character vector, identifiers for the objectives. Can be the same as modelVarIds.</p> required <code>objective_names</code> <code>Any</code> <p>character vector, display names for the objectives. Can be the same as modelVarIds.</p> required <code>starts</code> <code>Any</code> <p>POSIXct vector of start dates for statistics</p> required <code>ends</code> <code>Any</code> <p>POSIXct vector of end dates for statistics</p> required Source code in <code>.venv/lib/python3.13/site-packages/swift2/statistics.py</code> <pre><code>def multi_statistic_definition(\n    model_var_ids, statistic_ids, objective_ids, objective_names, starts, ends\n):\n    \"\"\"\n    Collate information for use in multisite multiobjective definition\n\n    Collate information for use in multisite multiobjective definition\n\n    Args:\n        model_var_ids (Any): character vector, model state identifiers where statistics are calculated\n        statistic_ids (Any): character vector, identifiers for bivariate statistics (e.g. nse, lognse, et.)\n        objective_ids (Any): character vector, identifiers for the objectives. Can be the same as modelVarIds.\n        objective_names (Any): character vector, display names for the objectives. Can be the same as modelVarIds.\n        starts (Any): POSIXct vector of start dates for statistics\n        ends (Any): POSIXct vector of end dates for statistics\n\n    \"\"\"\n    # stopifnot(is.character(model_var_ids))\n    # stopifnot(is.character(statistic_ids))\n    # stopifnot(is.character(objective_ids))\n    # stopifnot(is.character(objective_names))\n    # stopifnot(is.numeric(starts)) # TODO but not the right check. POSIXct\n    # stopifnot(is.numeric(ends))\n\n    return pd.DataFrame.from_dict(\n        {\n            \"ModelVarId\": model_var_ids,\n            \"StatisticId\": statistic_ids,\n            \"ObjectiveId\": objective_ids,\n            \"ObjectiveName\": objective_names,\n            \"Start\": starts,\n            \"End\": ends,\n        }\n    )\n</code></pre>"},{"location":"system/","title":"Module system","text":""},{"location":"system/#swift2.system.get_last_swift_error","title":"<code>get_last_swift_error()</code>","text":"<p>Retrieve the message for the last known error in SWIFT</p> <p>Retrieve the message for the last known error in SWIFT. Error means here that an exception was thrown by the core SWIFT library. The SWIFT C API intercepts these messages to make them available to users for diagnosis.</p> <p>Returns:</p> Type Description <p>A character, the message for the last known error in SWIFT.</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/system.py</code> <pre><code>def get_last_swift_error():\n    \"\"\"\n    Retrieve the message for the last known error in SWIFT\n\n    Retrieve the message for the last known error in SWIFT. Error means here that an exception was thrown by the core\n    SWIFT library. The SWIFT C API intercepts these messages to make them available to users for diagnosis.\n\n    Returns:\n        A character, the message for the last known error in SWIFT.\n    \"\"\"\n\n    return swg.GetLastStdExceptionMessage_py()\n</code></pre>"},{"location":"system/#swift2.system.runoff_model_ids","title":"<code>runoff_model_ids()</code>","text":"<p>Gets all the names of known runoff models</p> <p>Gets all the names of known runoff models</p> <p>Returns:</p> Type Description <p>character vector, names (identifiers) of runoff models</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/system.py</code> <pre><code>def runoff_model_ids():\n    \"\"\"\n    Gets all the names of known runoff models\n\n    Gets all the names of known runoff models\n\n    Returns:\n        character vector, names (identifiers) of runoff models\n\n    \"\"\"\n    return swg.GetRunoffModelIdentifiers_py()\n</code></pre>"},{"location":"system/#swift2.system.runoff_model_var_ids","title":"<code>runoff_model_var_ids(model_id)</code>","text":"<p>Gets all the names of the variables a runoff model exposes</p> <p>Gets all the names of the variables a runoff model exposes for dynamic query.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>Any</code> <p>character; A recognized model identifier</p> required <p>Returns:</p> Type Description <p>a character vector, the known model variable that can be set/gotten</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/system.py</code> <pre><code>def runoff_model_var_ids(model_id):\n    \"\"\"\n    Gets all the names of the variables a runoff model exposes\n\n    Gets all the names of the variables a runoff model exposes for dynamic query.\n\n    Args:\n        model_id (Any): character; A recognized model identifier\n\n    Returns:\n        a character vector, the known model variable that can be set/gotten\n\n    \"\"\"\n    if model_id not in runoff_model_ids():\n        raise ValueError(\"Unrecognized runoff model identifier: \" + model_id)\n    return swg.GetRunoffModelVarIdentifiers_py(model_id)\n</code></pre>"},{"location":"system/#swift2.system.set_default_max_parallelism_threads","title":"<code>set_default_max_parallelism_threads(n_threads=-1)</code>","text":"<p>Sets the level of thread parallelism to use by default for new objects such as optimisers. May be overwritten for each instance afterwards.</p> <p>Parameters:</p> Name Type Description Default <code>n_threads</code> <code>int</code> <p>number of threads. Positive, or -1 to mean \"as many as available\"</p> <code>-1</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/system.py</code> <pre><code>def set_default_max_parallelism_threads(n_threads: int = -1):\n    \"\"\"Sets the level of thread parallelism to use by default for new objects such as optimisers. May be overwritten for each instance afterwards.\n\n    Args:\n        n_threads (int): number of threads. Positive, or -1 to mean \"as many as available\"\n    \"\"\"\n    swg.SetDefaultMaxThreadsWila_py(n_threads)\n</code></pre>"},{"location":"system/#swift2.system.set_maximum_threads","title":"<code>set_maximum_threads(optimiser, n_threads=-1)</code>","text":"<p>Sets the maximum level of parallelism of an optimizer</p> <p>Sets the maximum level of threading of an optimizer. NOTE: this also modifies a global default for further optimizers, which is a hack for ERRIS, acceptable but still likely to change in the future. It is VERY important to use this function prior to running calibrations on some systems such as clusters, as the default hardware detection may not be appropriate if the cluster node is not dedicated.</p> <p>Parameters:</p> Name Type Description Default <code>optimizer</code> <code>Any</code> <p>an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"OPTIMIZER_PTR\"</p> required <code>n_threads</code> <code>Any</code> <p>integer, maximum number of threads allowed. If -1, the system defaults to using all but one of the CPU cores detected on the hardware.</p> <code>-1</code> Source code in <code>.venv/lib/python3.13/site-packages/swift2/system.py</code> <pre><code>def set_maximum_threads(optimiser, n_threads=-1):\n    \"\"\"\n    Sets the maximum level of parallelism of an optimizer\n\n    Sets the maximum level of threading of an optimizer. NOTE: this also modifies a global default for further optimizers,\n    which is a hack for ERRIS, acceptable but still likely to change in the future.\n    It is VERY important to use this function prior to running calibrations on some systems such as clusters,\n    as the default hardware detection may not be appropriate if the cluster node is not dedicated.\n\n    Args:\n        optimizer (Any): an S4 object 'ExternalObjRef' [package \"cinterop\"] with external pointer type \"OPTIMIZER_PTR\"\n        n_threads (Any): integer, maximum number of threads allowed. If -1, the system defaults to using all but one of the CPU cores detected on the hardware.\n\n    \"\"\"\n    swg.SetMaxThreadsOptimizerWila_py(optimiser, n_threads)\n</code></pre>"},{"location":"tech_notes/","title":"swift-py-doc","text":"<p>This site is to host the documentation for the <code>swift2</code> python package, which is part of a suite of tools for Streamflow Forecasting.</p>"},{"location":"tech_notes/#updating-the-content-of-site","title":"Updating the content of site","text":"<p>These are notes to \"self\"</p>"},{"location":"tech_notes/#copy-doc-files-from-reference-repo","title":"Copy doc files from reference repo","text":"<pre><code>pkg_dir=${HOME}/src/swift/bindings/python/swift2\ndoc_dir=${HOME}/src/swift-py-doc\ndeclare -a fn=(calibrate_multisite.ipynb \\\n  calibrate_subcatchments.ipynb \\\n  calibration_initial_states.ipynb \\\n  ensemble_model_runs.ipynb \\\n  error_correction_four_stages.ipynb \\\n  getting_started.ipynb \\\n  log_likelihood.ipynb \\\n  meta_parameters.ipynb \\\n  muskingum_multilink_calibration.ipynb \\\n  reservoir_geometry.ipynb)\n\ncd ${doc_dir}\n# WARNING: rm -r...\nrm -r docs\ncp ${pkg_dir}/mkdocs.yml ${doc_dir}/\ncp -r ${pkg_dir}/docs ${doc_dir}/\ncp ${pkg_dir}/LICENSE.txt ${doc_dir}/docs/license.md\n\n\n# Iterate through the array 'fn'\nfor f in \"${fn[@]}\"; do\n  file=${pkg_dir}/notebooks/${f}\n  # Check if the file exists\n  if [[ ! -f \"$file\" ]]; then\n    echo \"File '$file' does NOT exist.\"\n  fi\ndone\n# muskingum_multilink_calibration_explanation.ipynb\n\nmkdir -p ${doc_dir}/docs/notebooks\ncd ${doc_dir}/docs/notebooks\nrm *.ipynb\ncp ${pkg_dir}/notebooks/*.png ./\n</code></pre>"},{"location":"tech_notes/#execute-notebooks-in-place","title":"Execute notebooks in-place","text":"<p>This may take a few minutes to run, esp. if run from debug build.</p> <pre><code># kernel_name=hydrofc_release\nkernel_name=hydrofc\n\nfor f in ${fn[@]} ; do\n    echo \"processing $f\";\n    jupyter nbconvert --to notebook --ExecutePreprocessor.kernel_name=${kernel_name} --execute ${pkg_dir}/notebooks/${f} --output-dir=./\ndone\n</code></pre>"},{"location":"tech_notes/#building-the-site","title":"Building the site","text":"<p>May 2025 moving to use <code>uv</code> to manage the python environment.</p> <pre><code>cd $HOME/src/swift-py-doc\nuv venv .venv\n</code></pre> <pre><code>cd $HOME/src/swift-py-doc\n. .venv/bin/activate\nuv pip install \\\n  mkdocs \\\n  mkdocs-material \\\n  mkdocstrings  \\\n  mkdocs-material-extensions \\\n  mkdocs-jupyter \\\n  mkdocstrings-python  \\\n  markdown-callouts \\\n  mkdocs-llmstxt\n# May 2025 I am trying to produce llms.txt files\n</code></pre> <p>To test locally with <code>mkdocs serve</code>:</p> <pre><code>cd ${doc_dir}\nmkdocs serve -w mkdocs.yml -w docs/\n</code></pre> <p>to build and deploy the site:</p> <pre><code>cd ${doc_dir}\nmkdocs build --clean --site-dir _build/html --config-file mkdocs.yml\n</code></pre> <p>then, provided you have an ssh key set up for authentication with <code>github.com</code>:</p> <pre><code>mkdocs gh-deploy --clean --site-dir _build/html --config-file mkdocs.yml\n</code></pre>"},{"location":"tech_notes/#examples-as-markdown","title":"Examples as markdown","text":"<p>We can export the sample notebooks to markdown, with a view to use them as contexts for AI code aids.</p> <p>Note that is important to NOT output to <code>${doc_dir}/docs/notebooks</code>, as it messes up the web site layout (see issue 2)</p> <pre><code>cd ${doc_dir}/docs/notebooks\nout_dir=${doc_dir}/attic/docs/notebooks/\nmkdir -p ${out_dir} \nfor f in ${fn[@]} ; do\n    echo \"processing $f\";\n    jupyter nbconvert --to markdown ./${f} --output-dir=${out_dir} \ndone\n</code></pre>"},{"location":"tech_notes/#resources","title":"Resources","text":"<p>Grateful for examplars for configuring <code>mkdocs</code>, at least as of 2023 or so:</p> <ul> <li>https://github.com/FasterSpeeding/Tanjun/blob/master/mkdocs.yml</li> <li>https://github.com/tiangolo/fastapi/blob/master/docs/en/mkdocs.yml</li> </ul>"},{"location":"utils/","title":"Module utils","text":""},{"location":"utils/#swift2.utils.c","title":"<code>c(*args)</code>","text":"<p>Emulate the R c (concatenate) function, somewhat.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: [description]</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/utils.py</code> <pre><code>def c(*args) -&gt; np.ndarray:\n    \"\"\"Emulate the R c (concatenate) function, somewhat.\n\n    Returns:\n        np.ndarray: [description]\n    \"\"\"\n    return np.array([x for x in args])\n</code></pre>"},{"location":"utils/#swift2.utils.is_common_iterable","title":"<code>is_common_iterable(obj)</code>","text":"<p>True if an object is iterable but not a string (str)</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/utils.py</code> <pre><code>def is_common_iterable(obj: Any) -&gt; bool:\n    \"\"\"True if an object is iterable but not a string (str)\"\"\"\n    if isinstance(obj, str):\n        return False\n    # if isinstance(obj, np.ndarray) and obj.size == 1:\n    #     return False # otherwise likely to get error \"len() of unsized object\"\n    return hasattr(type(obj), \"__iter__\")\n</code></pre>"},{"location":"utils/#swift2.utils.mk_full_data_id","title":"<code>mk_full_data_id(*args)</code>","text":"<p>Create swift IDs (dot separated hierarchical naming scheme)</p> <p>Create swift IDs (dot separated hierarchical naming scheme). Note that the behavior is different than 'paste' for empty characters.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>one or more character vectors.</p> <code>()</code> <p>Examples:</p> <p>TODO</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/utils.py</code> <pre><code>def mk_full_data_id(*args):\n    \"\"\"\n    Create swift IDs (dot separated hierarchical naming scheme)\n\n    Create swift IDs (dot separated hierarchical naming scheme). Note that the behavior is different than 'paste' for empty characters.\n\n    Args:\n        args (Any): one or more character vectors.\n\n    Examples:\n        TODO\n\n    \"\"\"\n    #    &gt;&gt;&gt; # (obsVarname &lt;- mkFullDataId('link','corin_dam','ec','Observed'))\n    #    &gt;&gt;&gt; # subareaFullIds &lt;- mkFullDataId( 'subarea', getSubareaIds(simulation))\n    #    &gt;&gt;&gt; # mkFullDataId(character(0),'corin_dam','ec','Observed')\n    ids = list(args)\n    if len(ids) == 0:\n        return None\n    else:\n        lengths = [len(x) for x in ids if not isinstance(x, str)]\n        if len(lengths) &gt; 0:\n            minl = min(lengths)\n            if minl &lt; 1:\n                return None\n        return paste(*args, sep=\".\")\n</code></pre>"},{"location":"utils/#swift2.utils.paste","title":"<code>paste(*lists, sep=' ', collapse=None)</code>","text":"<p>Port of R paste function</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/utils.py</code> <pre><code>def paste(*lists, sep=\" \", collapse=None):\n    \"\"\"Port of R paste function\"\"\"\n    result = reduce_concat(lists, sep=sep)\n    if collapse is not None:\n        return reduce_concat(result, sep=collapse)\n    return result\n</code></pre>"},{"location":"utils/#swift2.utils.paste0","title":"<code>paste0(*lists, collapse=None)</code>","text":"<p>Port of R paste0 function</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/utils.py</code> <pre><code>def paste0(*lists, collapse=None):\n    \"\"\"Port of R paste0 function\"\"\"\n    return paste(*lists, sep=\"\", collapse=collapse)\n</code></pre>"},{"location":"utils/#swift2.utils.paste_2","title":"<code>paste_2(x, y, sep=' ')</code>","text":"<p>Port of R vectorised paste, for 2 elements</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/utils.py</code> <pre><code>def paste_2(x: VecScalars, y: VecScalars, sep: str = \" \"):\n    \"\"\"Port of R vectorised paste, for 2 elements\"\"\"\n    if is_common_iterable(x):\n        if is_common_iterable(y):\n            return paste_lists(x, y, sep)\n        else:\n            return paste_list_scalar(x, y, sep)\n    else:\n        if is_common_iterable(y):\n            return paste_scalar_list(x, y, sep)\n        else:\n            return paste_scalar_scalar(x, y, sep)\n</code></pre>"},{"location":"utils/#swift2.utils.sort_by","title":"<code>sort_by(x, unsorted_reference, sorted_reference)</code>","text":"<p>Sort one vector according to the known reordering of another</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>values to sort</p> required <code>unsorted_reference</code> <code>Any</code> <p>unique 'keys' corresponding to each element in x</p> required <code>sorted_reference</code> <code>Any</code> <p>set of 'keys', identical as a set to unsorted_reference, but sorted</p> required <p>Returns:</p> Type Description <p>the values in x reordered such that the same reordering of unsorted_reference matches sorted_reference</p> <p>Examples:</p> <p>TODO</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/utils.py</code> <pre><code>def sort_by(x, unsorted_reference, sorted_reference):\n    \"\"\"\n    Sort one vector according to the known reordering of another\n\n    Args:\n        x (Any): values to sort\n        unsorted_reference (Any): unique 'keys' corresponding to each element in x\n        sorted_reference (Any): set of 'keys', identical as a set to unsorted_reference, but sorted\n\n    Returns:\n        the values in x reordered such that the same reordering of unsorted_reference matches sorted_reference\n\n    Examples:\n        TODO\n\n    \"\"\"\n    # &gt;&gt;&gt; # set.seed(12)\n    # &gt;&gt;&gt; # (x = sample(1:5))\n    # &gt;&gt;&gt; # (unsorted_reference = letters[x])\n    # &gt;&gt;&gt; # (sorted_reference = letters[1:5])\n    # &gt;&gt;&gt; # (x[order(match(unsorted_reference,sorted_reference))])\n    # &gt;&gt;&gt; # sortBy(x, unsorted_reference, sorted_reference)\n    assert len(x) == len(unsorted_reference)\n    assert len(sorted_reference) == len(unsorted_reference)\n    assert set(unsorted_reference) == set(sorted_reference)\n    # There may be something more elegant\n    def find_index(shuffled, sorted):\n        if isinstance(shuffled, list):\n            shuffled = np.array(shuffled)\n        s = [np.argwhere(x == shuffled) for x in sorted]\n        for v in s:\n            assert v.shape == (1, 1)\n        return [v[0][0] for v in s]\n\n    # TODO unit test of course:\n    # x = np.array([2, 5, 3, 1, 4])\n    # unsorted_reference = np.array([\"b\",\"e\",\"c\",\"a\",\"d\"])\n    # sorted_reference = np.array([\"a\",\"b\",\"c\",\"d\",\"e\"])\n    # indx = find_index(unsorted_reference, sorted_reference)\n    # [x[i] for i in indx]\n    indx = find_index(unsorted_reference, sorted_reference)\n    return [x[i] for i in indx]\n</code></pre>"},{"location":"utils/#swift2.utils.vpaste","title":"<code>vpaste(root, vars)</code>","text":"<p>vectorised paste for 2 elements; Port of R paste0 in spirit</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>VecScalars</code> <p>left hand side(s) of the paste</p> required <code>vars</code> <code>VecScalars</code> <p>right hand side(s) of the paste</p> required <p>Returns:</p> Type Description <code>Union[str, Sequence[str]]</code> <p>Union[str,Sequence[str]]: pasted scalars</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/utils.py</code> <pre><code>def vpaste(root: VecScalars, vars: VecScalars) -&gt; Union[str, Sequence[str]]:\n    \"\"\"vectorised paste for 2 elements; Port of R paste0 in spirit\n\n    Args:\n        root (VecScalars): left hand side(s) of the paste\n        vars (VecScalars): right hand side(s) of the paste\n\n    Returns:\n        Union[str,Sequence[str]]: pasted scalars\n    \"\"\"\n    return paste_2(root, vars, sep=\"\")\n</code></pre>"},{"location":"vis/","title":"Module vis","text":""},{"location":"vis/#swift2.vis.OptimisationPlots","title":"<code>OptimisationPlots</code>","text":"Source code in <code>.venv/lib/python3.13/site-packages/swift2/vis.py</code> <pre><code>class OptimisationPlots:\n    def __init__(self, optim_geom: MhData) -&gt; None:\n        self._optim_geom = optim_geom\n\n    def parameter_evolution(\n        self,\n        param_name: str,\n        obj_lims: Sequence[float] = None,\n        title: str = \"Evolution of parameter values\",\n        xlab=\"Logged point\",\n        ylab=None,\n        **kwargs\n    ):\n        d = self._optim_geom.bound_fitness(obj_lims)\n        if ylab is None:\n            ylab = param_name\n        ax = d.plot.scatter(\n            x=\"PointNumber\",\n            y=param_name,\n            c=self._optim_geom._fitness,\n            colormap=\"viridis\",\n            **kwargs\n        )\n        if xlab is not None:\n            ax.set_xlabel(xlab)\n        if ylab is not None:\n            ax.set_ylabel(ylab)\n        if title is not None:\n            ax.set_title(title)\n        return ax\n\n    def shuffles(self, x: str, y: str, obj_lims: Sequence[float] = None) -&gt; Any:\n        \"\"\"Facetted bi-parameter scatter plots of the value of a parameter along the optimisation process\n\n        Plot the value of a parameter along the optimisation process.\n        The color scale is the objective score. Useful to check the behavior of the optimisation process.\n\n        Args:\n            x (str): the exact name of one of the model parameters\n            y (str): the exact name of a second model parameter\n            obj_lims (Sequence[float], optional): min/max limits to plot the fitness, for example min 0 for NSE. Defaults to None.\n\n        Returns:\n            sns.FacetGrid: FacetGrid object\n        \"\"\"\n        import matplotlib.pyplot as plt\n\n        d = self._optim_geom.bound_fitness(obj_lims)\n        # matplotlib makes it difficult to use continuous color scales for num values...\n        # https://stackoverflow.com/a/44642014/2752565\n        g = sns.FacetGrid(\n            d,\n            col=self._optim_geom._categories,\n            hue=self._optim_geom._fitness,\n            col_wrap=3,\n        )\n\n        def facet_scatter(x, y, c, **kwargs):\n            \"\"\"Draw scatterplot with point colors from a faceted DataFrame columns.\"\"\"\n            kwargs.pop(\"color\")\n            plt.scatter(x, y, c=c, **kwargs)\n\n        values = d[self._optim_geom._fitness].values\n        vmin, vmax = np.min(values), np.max(values)\n        # cmap = sns.diverging_palette(240, 10, l=65, center=\"light\", as_cmap=True)\n        cmap = sns.color_palette(\n            palette=\"viridis\", n_colors=None, desat=None, as_cmap=True\n        )\n\n        g = g.map(\n            facet_scatter,\n            x,\n            y,\n            self._optim_geom._fitness,\n            s=100,\n            alpha=0.5,\n            vmin=vmin,\n            vmax=vmax,\n            cmap=cmap,\n        )\n\n        # Make space for the colorbar\n        g.fig.subplots_adjust(right=0.92)\n\n        # Define a new Axes where the colorbar will go\n        cax = g.fig.add_axes([0.94, 0.25, 0.02, 0.6])\n\n        # Get a mappable object with the same colormap as the data\n        points = plt.scatter([], [], c=[], vmin=vmin, vmax=vmax, cmap=cmap)\n\n        # Draw the colorbar\n        g.fig.colorbar(points, cax=cax)\n\n        g.fig.set_size_inches(15, 10)  # Sorry, only silly imperial units available\n        # grid.add_legend()\n        return g\n</code></pre>"},{"location":"vis/#swift2.vis.OptimisationPlots.shuffles","title":"<code>shuffles(x, y, obj_lims=None)</code>","text":"<p>Facetted bi-parameter scatter plots of the value of a parameter along the optimisation process</p> <p>Plot the value of a parameter along the optimisation process. The color scale is the objective score. Useful to check the behavior of the optimisation process.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>str</code> <p>the exact name of one of the model parameters</p> required <code>y</code> <code>str</code> <p>the exact name of a second model parameter</p> required <code>obj_lims</code> <code>Sequence[float]</code> <p>min/max limits to plot the fitness, for example min 0 for NSE. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>sns.FacetGrid: FacetGrid object</p> Source code in <code>.venv/lib/python3.13/site-packages/swift2/vis.py</code> <pre><code>def shuffles(self, x: str, y: str, obj_lims: Sequence[float] = None) -&gt; Any:\n    \"\"\"Facetted bi-parameter scatter plots of the value of a parameter along the optimisation process\n\n    Plot the value of a parameter along the optimisation process.\n    The color scale is the objective score. Useful to check the behavior of the optimisation process.\n\n    Args:\n        x (str): the exact name of one of the model parameters\n        y (str): the exact name of a second model parameter\n        obj_lims (Sequence[float], optional): min/max limits to plot the fitness, for example min 0 for NSE. Defaults to None.\n\n    Returns:\n        sns.FacetGrid: FacetGrid object\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    d = self._optim_geom.bound_fitness(obj_lims)\n    # matplotlib makes it difficult to use continuous color scales for num values...\n    # https://stackoverflow.com/a/44642014/2752565\n    g = sns.FacetGrid(\n        d,\n        col=self._optim_geom._categories,\n        hue=self._optim_geom._fitness,\n        col_wrap=3,\n    )\n\n    def facet_scatter(x, y, c, **kwargs):\n        \"\"\"Draw scatterplot with point colors from a faceted DataFrame columns.\"\"\"\n        kwargs.pop(\"color\")\n        plt.scatter(x, y, c=c, **kwargs)\n\n    values = d[self._optim_geom._fitness].values\n    vmin, vmax = np.min(values), np.max(values)\n    # cmap = sns.diverging_palette(240, 10, l=65, center=\"light\", as_cmap=True)\n    cmap = sns.color_palette(\n        palette=\"viridis\", n_colors=None, desat=None, as_cmap=True\n    )\n\n    g = g.map(\n        facet_scatter,\n        x,\n        y,\n        self._optim_geom._fitness,\n        s=100,\n        alpha=0.5,\n        vmin=vmin,\n        vmax=vmax,\n        cmap=cmap,\n    )\n\n    # Make space for the colorbar\n    g.fig.subplots_adjust(right=0.92)\n\n    # Define a new Axes where the colorbar will go\n    cax = g.fig.add_axes([0.94, 0.25, 0.02, 0.6])\n\n    # Get a mappable object with the same colormap as the data\n    points = plt.scatter([], [], c=[], vmin=vmin, vmax=vmax, cmap=cmap)\n\n    # Draw the colorbar\n    g.fig.colorbar(points, cax=cax)\n\n    g.fig.set_size_inches(15, 10)  # Sorry, only silly imperial units available\n    # grid.add_legend()\n    return g\n</code></pre>"},{"location":"notebooks/calibrate_multisite/","title":"Calibration of a catchment using multisite multiobjective composition","text":"In\u00a0[1]: Copied! <pre>from swift2.doc_helper import pkg_versions_info\n\nprint(pkg_versions_info(\"This document was generated from a jupyter notebook\"))\n</pre> from swift2.doc_helper import pkg_versions_info  print(pkg_versions_info(\"This document was generated from a jupyter notebook\")) <pre>This document was generated from a jupyter notebook on 2025-05-16 14:15:13.507046\n    swift2 2.5.1\n    uchronia 2.6.2\n</pre> In\u00a0[2]: Copied! <pre>from swift2.utils import mk_full_data_id\nfrom swift2.classes import CompositeParameteriser, HypercubeParameteriser, Simulation\n# from swift2.wrap.ffi_interop import debug_msd\nimport xarray as xr\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\n</pre> from swift2.utils import mk_full_data_id from swift2.classes import CompositeParameteriser, HypercubeParameteriser, Simulation # from swift2.wrap.ffi_interop import debug_msd import xarray as xr import pandas as pd import numpy as np import xarray as xr In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[3]: Copied! <pre>import swift2.doc_helper as std\n</pre> import swift2.doc_helper as std In\u00a0[4]: Copied! <pre>import seaborn as sns\nimport matplotlib.pyplot as plt\n</pre> import seaborn as sns import matplotlib.pyplot as plt In\u00a0[5]: Copied! <pre>from cinterop.timeseries import TIME_DIMNAME, slice_xr_time_series, pd_series_to_xr_series, slice_xr_time_series, pd_series_to_xr_series\n</pre> from cinterop.timeseries import TIME_DIMNAME, slice_xr_time_series, pd_series_to_xr_series, slice_xr_time_series, pd_series_to_xr_series In\u00a0[6]: Copied! <pre>from cinterop.timeseries import xr_ts_start, xr_ts_end\nimport datetime as dt\n</pre> from cinterop.timeseries import xr_ts_start, xr_ts_end import datetime as dt In\u00a0[7]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[8]: Copied! <pre>model_id = 'GR4J'\nsite_id = 'South_Esk'\n</pre> model_id = 'GR4J' site_id = 'South_Esk' In\u00a0[9]: Copied! <pre>se_climate = std.sample_series(site_id=site_id, var_name='climate')\nse_flows = std.sample_series(site_id=site_id, var_name='flow')\n</pre> se_climate = std.sample_series(site_id=site_id, var_name='climate') se_flows = std.sample_series(site_id=site_id, var_name='flow') In\u00a0[10]: Copied! <pre>se_climate.head(3)\n</pre> se_climate.head(3) Out[10]: subcatchment.1.E subcatchment.1.P subcatchment.10.E subcatchment.10.P subcatchment.11.E subcatchment.11.P subcatchment.12.E subcatchment.12.P subcatchment.13.E subcatchment.13.P ... subcatchment.5.E subcatchment.5.P subcatchment.6.E subcatchment.6.P subcatchment.7.E subcatchment.7.P subcatchment.8.E subcatchment.8.P subcatchment.9.E subcatchment.9.P 2010-11-01 00:00:00 0.3918 0.0 0.4020 0.0000 0.3978 0.0000 0.4266 0.0000 0.3936 0.0000 ... 0.4325 0.0 0.4110 0.0322 0.4247 0.0 0.4377 0.0 0.4337 0.0 2010-11-01 01:00:00 0.4385 0.0 0.4493 0.0207 0.4446 0.0433 0.4763 0.0179 0.4397 0.0555 ... 0.4823 0.0 0.4593 0.0000 0.4746 0.0 0.4892 0.0 0.4841 0.0 2010-11-01 02:00:00 0.4614 0.0 0.4723 0.0000 0.4671 0.0000 0.5002 0.0000 0.4619 0.0000 ... 0.5060 0.0 0.4827 0.0000 0.4987 0.0 0.5143 0.0 0.5084 0.0 <p>3 rows \u00d7 84 columns</p> In\u00a0[11]: Copied! <pre>se_climate.tail(3)\n</pre> se_climate.tail(3) Out[11]: subcatchment.1.E subcatchment.1.P subcatchment.10.E subcatchment.10.P subcatchment.11.E subcatchment.11.P subcatchment.12.E subcatchment.12.P subcatchment.13.E subcatchment.13.P ... subcatchment.5.E subcatchment.5.P subcatchment.6.E subcatchment.6.P subcatchment.7.E subcatchment.7.P subcatchment.8.E subcatchment.8.P subcatchment.9.E subcatchment.9.P 2010-11-20 21:00:00 0.1832 0.0 0.1885 0.0000 0.1865 0.0000 0.2004 0.0 0.1844 0.0 ... 0.2047 0.0 0.1940 0.0 0.1988 0.0 0.2035 0.0 0.2040 0.0 2010-11-20 22:00:00 0.2809 0.0 0.2877 0.1014 0.2849 0.0289 0.3054 0.0 0.2814 0.0 ... 0.3104 0.0 0.2961 0.0 0.3035 0.0 0.3105 0.0 0.3098 0.0 2010-11-20 23:00:00 0.3683 0.0 0.3762 0.2028 0.3727 0.0577 0.3990 0.0 0.3678 0.0 ... 0.4044 0.0 0.3872 0.0 0.3968 0.0 0.4061 0.0 0.4041 0.0 <p>3 rows \u00d7 84 columns</p> In\u00a0[12]: Copied! <pre>simulation = std.sample_catchment_model(site_id=site_id, config_id='catchment')\n# simulation = swap_model(simulation, 'MuskingumNonLinear', 'channel_routing')\nsimulation = simulation.swap_model('LagAndRoute', 'channel_routing')\n</pre> simulation = std.sample_catchment_model(site_id=site_id, config_id='catchment') # simulation = swap_model(simulation, 'MuskingumNonLinear', 'channel_routing') simulation = simulation.swap_model('LagAndRoute', 'channel_routing') <p>The names of the climate series is already set to the climate input identifiers of the model simulation, so setting them as inputs is easy:</p> In\u00a0[13]: Copied! <pre>simulation.play_input(se_climate)\nsimulation.set_simulation_span(xr_ts_start(se_climate), xr_ts_end(se_climate))\nsimulation.set_simulation_time_step('hourly')\n</pre> simulation.play_input(se_climate) simulation.set_simulation_span(xr_ts_start(se_climate), xr_ts_end(se_climate)) simulation.set_simulation_time_step('hourly') <p>Moving on to define the parameters, free or fixed. We will use (for now - may change) the package calibragem, companion to SWIFT.</p> In\u00a0[14]: Copied! <pre>std.configure_hourly_gr4j(simulation)\n</pre> std.configure_hourly_gr4j(simulation) In\u00a0[15]: Copied! <pre>from swift2.utils import c, paste0, rep\nimport swift2.parameteriser as sp\nimport swift2.helpers as hlp\n\n\ndef create_meta_parameteriser(simulation:Simulation, ref_area=250, time_span=3600):  \n    time_span = int(time_span)\n    parameteriser = std.define_gr4j_scaled_parameter(ref_area, time_span)\n  \n    # Let's define _S0_ and _R0_ parameters such that for each GR4J model instance, _S = S0 * x1_ and _R = R0 * x3_\n    p_states = sp.linear_parameteriser(\n                      param_name=c(\"S0\",\"R0\"), \n                      state_name=c(\"S\",\"R\"), \n                      scaling_var_name=c(\"x1\",\"x3\"),\n                      min_p_val=c(0.0,0.0), \n                      max_p_val=c(1.0,1.0), \n                      value=c(0.9,0.9), \n                      selector_type='each subarea')\n  \n    init_parameteriser = p_states.make_state_init_parameteriser()\n    parameteriser = sp.concatenate_parameterisers(parameteriser, init_parameteriser)\n    \n    hlp.lag_and_route_linear_storage_type(simulation)\n    hlp.set_reach_lengths_lag_n_route(simulation)\n\n    lnrp = hlp.parameteriser_lag_and_route()\n    parameteriser = CompositeParameteriser.concatenate(parameteriser, lnrp, strategy='')\n    return parameteriser\n</pre> from swift2.utils import c, paste0, rep import swift2.parameteriser as sp import swift2.helpers as hlp   def create_meta_parameteriser(simulation:Simulation, ref_area=250, time_span=3600):       time_span = int(time_span)     parameteriser = std.define_gr4j_scaled_parameter(ref_area, time_span)        # Let's define _S0_ and _R0_ parameters such that for each GR4J model instance, _S = S0 * x1_ and _R = R0 * x3_     p_states = sp.linear_parameteriser(                       param_name=c(\"S0\",\"R0\"),                        state_name=c(\"S\",\"R\"),                        scaling_var_name=c(\"x1\",\"x3\"),                       min_p_val=c(0.0,0.0),                        max_p_val=c(1.0,1.0),                        value=c(0.9,0.9),                        selector_type='each subarea')        init_parameteriser = p_states.make_state_init_parameteriser()     parameteriser = sp.concatenate_parameterisers(parameteriser, init_parameteriser)          hlp.lag_and_route_linear_storage_type(simulation)     hlp.set_reach_lengths_lag_n_route(simulation)      lnrp = hlp.parameteriser_lag_and_route()     parameteriser = CompositeParameteriser.concatenate(parameteriser, lnrp, strategy='')     return parameteriser   In\u00a0[16]: Copied! <pre>parameteriser = create_meta_parameteriser(simulation)\n</pre> parameteriser = create_meta_parameteriser(simulation) <p>We have built a parameteriser for jointly parameterising:</p> <ul> <li>GR4J parameters in transformed spaces ($log$ and $asinh$)</li> <li>GR4J initial soil moisture store conditions ($S_0$ and $R_0$)</li> <li>A \"lag and route\" streamflow routing scheme in transform space.</li> </ul> <p>There is even more happening there, because on top of GR4J parameter transformation we scale some in proportion to catchment area and time step length. But this is besides the point of this vignette: refer for instance to the vignette about tied parameters to know more about parameter transformation and composition of parameterisers.</p> In\u00a0[17]: Copied! <pre>parameteriser\n</pre> parameteriser Out[17]: <pre>               Name     Value       Min         Max\n0            log_x4  0.305422  0.000000    2.380211\n1            log_x1  0.506690  0.000000    3.778151\n2            log_x3  0.315425  0.000000    3.000000\n3          asinh_x2  2.637752 -3.989327    3.989327\n4                R0  0.900000  0.000000    1.000000\n5                S0  0.900000  0.000000    1.000000\n6             alpha  1.000000  0.001000  100.000000\n7  inverse_velocity  1.000000  0.001000  100.000000</pre> <p>Let us check that we can apply the parameteriser and use its methods.</p> In\u00a0[18]: Copied! <pre>parameteriser.set_parameter_value('asinh_x2', 0)\nparameteriser.apply_sys_config(simulation)\nsimulation.exec_simulation()\n</pre> parameteriser.set_parameter_value('asinh_x2', 0) parameteriser.apply_sys_config(simulation) simulation.exec_simulation() <p>We are now ready to enter the main topic of this vignette, i.e. setting up a weighted multi-objective for calibration purposes.</p> In\u00a0[19]: Copied! <pre>se_flows.head()\n</pre> se_flows.head() Out[19]: 3364 18311 25 181 93044 592002 92020 92091 92106 2010-11-01 00:00:00 1.753 0.755 1.229 11.705 10.65 0.897 0.8 8.51 9.2 2010-11-01 01:00:00 1.755 0.753 1.259 11.656 10.59 0.897 0.8 8.34 9.2 2010-11-01 02:00:00 1.746 0.743 1.280 11.606 10.56 0.897 0.8 8.00 9.2 2010-11-01 03:00:00 1.748 0.752 1.291 11.570 10.44 0.897 0.8 7.96 9.2 2010-11-01 04:00:00 1.735 0.737 1.296 11.528 10.35 0.897 0.8 7.96 9.2 <p>The network of nodes of the simulation is arbitrarily identified with nodes '1' to '43'</p> In\u00a0[20]: Copied! <pre>simulation.describe()[\"nodes\"].keys()\n</pre> simulation.describe()[\"nodes\"].keys() Out[20]: <pre>dict_keys(['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43'])</pre> <p>We \"know\" that we can associate the node identifiers 'node.{i}' with gauge identifiers (note to doc maintainers: manually extracted from legacy swiftv1 NodeLink files)</p> In\u00a0[21]: Copied! <pre>gauges = c( '92106', '592002', '18311', '93044',    '25',   '181')\nnode_ids = paste0('node.', c('7',   '12',   '25',   '30',   '40',   '43'))   \n# names(gauges) = node_ids\n</pre> gauges = c( '92106', '592002', '18311', '93044',    '25',   '181') node_ids = paste0('node.', c('7',   '12',   '25',   '30',   '40',   '43'))    # names(gauges) = node_ids <p>First, let us try the Nash Sutcliffe efficiency, for simplicity (no additional parameters needed). We will set up NSE calculations at two points (nodes) in the catchments. Any model state from a link, node or subarea could be a point for statistics calculation.</p> <p>The function <code>multi_statistic_definition</code> in the module <code>swift2.statistics</code> is used to create multisite multiobjective definitions.</p> In\u00a0[22]: Copied! <pre>import swift2.statistics as ssf\n</pre> import swift2.statistics as ssf In\u00a0[23]: Copied! <pre>ssf.multi_statistic_definition?\n</pre> ssf.multi_statistic_definition? In\u00a0[24]: Copied! <pre>span = simulation.get_simulation_span()\nspan\n</pre> span = simulation.get_simulation_span() span Out[24]: <pre>{'start': datetime.datetime(2010, 11, 1, 0, 0),\n 'end': datetime.datetime(2010, 11, 20, 23, 0),\n 'time step': 'hourly'}</pre> In\u00a0[25]: Copied! <pre>s = span['start']\ne = span['end']\n</pre> s = span['start'] e = span['end'] In\u00a0[26]: Copied! <pre>calibration_points = node_ids[:2]\nmvids = mk_full_data_id(calibration_points, 'OutflowRate')\nmvids\n</pre> calibration_points = node_ids[:2] mvids = mk_full_data_id(calibration_points, 'OutflowRate') mvids Out[26]: <pre>['node.7.OutflowRate', 'node.12.OutflowRate']</pre> In\u00a0[27]: Copied! <pre>statspec = ssf.multi_statistic_definition( \n  model_var_ids = mvids, \n  statistic_ids = rep('nse', 2), \n  objective_ids = calibration_points, \n  objective_names = paste0(\"NSE-\", calibration_points), \n  starts = [s, s + pd.DateOffset(hours=3)],\n  ends =  [e + pd.DateOffset(hours=-4), e + pd.DateOffset(hours=-2)])\n</pre> statspec = ssf.multi_statistic_definition(    model_var_ids = mvids,    statistic_ids = rep('nse', 2),    objective_ids = calibration_points,    objective_names = paste0(\"NSE-\", calibration_points),    starts = [s, s + pd.DateOffset(hours=3)],   ends =  [e + pd.DateOffset(hours=-4), e + pd.DateOffset(hours=-2)]) <p>We now have our set of statistics defined:</p> In\u00a0[28]: Copied! <pre>statspec\n</pre> statspec Out[28]: ModelVarId StatisticId ObjectiveId ObjectiveName Start End 0 node.7.OutflowRate nse node.7 NSE-node.7 2010-11-01 00:00:00 2010-11-20 19:00:00 1 node.12.OutflowRate nse node.12 NSE-node.12 2010-11-01 03:00:00 2010-11-20 21:00:00 <p>To create a multisite objective evaluator we need to use the <code>create_multisite_objective</code> method of the <code>simulation</code> object. We have out statistics defined. The method requires observations and weights to give to combine statistics to a single objective.</p> In\u00a0[29]: Copied! <pre>simulation.create_multisite_objective?\n</pre> simulation.create_multisite_objective? In\u00a0[30]: Copied! <pre>observations = [\n  se_flows[gauges[0]],\n  se_flows[gauges[1]]\n]\n</pre> observations = [   se_flows[gauges[0]],   se_flows[gauges[1]] ] In\u00a0[31]: Copied! <pre>w = {calibration_points[0]: 1.0, calibration_points[1]: 2.0} # weights (internally normalised to a total of 1.0)\nw\n</pre> w = {calibration_points[0]: 1.0, calibration_points[1]: 2.0} # weights (internally normalised to a total of 1.0) w Out[31]: <pre>{'node.7': 1.0, 'node.12': 2.0}</pre> In\u00a0[32]: Copied! <pre>moe = simulation.create_multisite_objective(statspec, observations, w)\nmoe.get_score(parameteriser)\n</pre> moe = simulation.create_multisite_objective(statspec, observations, w) moe.get_score(parameteriser) Out[32]: <pre>{'scores': {'MultisiteObjectives': 290.33738106858823},\n 'sysconfig':                Name     Value       Min         Max\n 0            log_x4  0.305422  0.000000    2.380211\n 1            log_x1  0.506690  0.000000    3.778151\n 2            log_x3  0.315425  0.000000    3.000000\n 3          asinh_x2  0.000000 -3.989327    3.989327\n 4                R0  0.900000  0.000000    1.000000\n 5                S0  0.900000  0.000000    1.000000\n 6             alpha  1.000000  0.001000  100.000000\n 7  inverse_velocity  1.000000  0.001000  100.000000}</pre> <p>We can get the value of each objective. The two NSE scores below are negative. Note above that the composite objective is positive, i.e. the opposite of the weighted average. This is because the composite objective is always minimisable (as of writing anyway this is a design choice.)</p> In\u00a0[33]: Copied! <pre>moe.get_scores(parameteriser)\n</pre> moe.get_scores(parameteriser) Out[33]: <pre>{'node.12': np.float64(-347.3329926657439),\n 'node.7': np.float64(-176.3461578742768)}</pre> In\u00a0[34]: Copied! <pre>statspec = ssf.multi_statistic_definition(  \n  model_var_ids = mvids, \n  statistic_ids = rep('log-likelihood', 2), \n  objective_ids=calibration_points, \n  objective_names = paste0(\"LL-\", calibration_points), \n  starts = rep(span['start'], 2), \n  ends = rep(span['end'], 2) )\n\nstatspec\n</pre> statspec = ssf.multi_statistic_definition(     model_var_ids = mvids,    statistic_ids = rep('log-likelihood', 2),    objective_ids=calibration_points,    objective_names = paste0(\"LL-\", calibration_points),    starts = rep(span['start'], 2),    ends = rep(span['end'], 2) )  statspec Out[34]: ModelVarId StatisticId ObjectiveId ObjectiveName Start End 0 node.7.OutflowRate log-likelihood node.7 LL-node.7 2010-11-01 2010-11-20 23:00:00 1 node.12.OutflowRate log-likelihood node.12 LL-node.12 2010-11-01 2010-11-20 23:00:00 <p>But while we can create the calculator, we cannot evaluate it against the sole hydrologic parameters defined in the previous section</p> In\u00a0[35]: Copied! <pre>obj = simulation.create_multisite_objective(statspec, observations, w)\n### This cannot work if the statistic is the log-likelihood:\n# obj.get_scores(fp)\n</pre> obj = simulation.create_multisite_objective(statspec, observations, w) ### This cannot work if the statistic is the log-likelihood: # obj.get_scores(fp) <p>If we try to do the above we would end up with an error message 'Mandatory key expected in the dictionary but not found: b'</p> <p>For this to work we need to include parameters</p> In\u00a0[36]: Copied! <pre>maxobs = np.max(observations[0].values) # NOTE: np.nan??\ncensor_threshold = 0.01\ncensopt = 0.0\ncalc_m_and_s = 1.0 # i.e. TRUE\n\n#\t\tconst string LogLikelihoodKeys::KeyAugmentSimulation = \"augment_simulation\";\n#\t\tconst string LogLikelihoodKeys::KeyExcludeAtTMinusOne = \"exclude_t_min_one\";\n#\t\tconst string LogLikelihoodKeys::KeyCalculateModelledMAndS = \"calc_mod_m_s\";\n#\t\tconst string LogLikelihoodKeys::KeyMParMod = \"m_par_mod\";\n#\t\tconst string LogLikelihoodKeys::KeySParMod = \"s_par_mod\";\n\np = sp.create_parameteriser('no apply')\n# Note: exampleParameterizer is also available\np.add_to_hypercube( \n          pd.DataFrame.from_dict( dict(Name=c('b','m','s','a','maxobs','ct', 'censopt', 'calc_mod_m_s'),\n          Min   = c(-30, 0, 1,    -30, maxobs, censor_threshold, censopt, calc_m_and_s),\n          Max   = c(0,   0, 1000, 1, maxobs, censor_threshold, censopt, calc_m_and_s),\n          Value = c(-7,  0, 100,  -10, maxobs, censor_threshold, censopt, calc_m_and_s)) ))\n\np.as_dataframe()\n</pre> maxobs = np.max(observations[0].values) # NOTE: np.nan?? censor_threshold = 0.01 censopt = 0.0 calc_m_and_s = 1.0 # i.e. TRUE  #\t\tconst string LogLikelihoodKeys::KeyAugmentSimulation = \"augment_simulation\"; #\t\tconst string LogLikelihoodKeys::KeyExcludeAtTMinusOne = \"exclude_t_min_one\"; #\t\tconst string LogLikelihoodKeys::KeyCalculateModelledMAndS = \"calc_mod_m_s\"; #\t\tconst string LogLikelihoodKeys::KeyMParMod = \"m_par_mod\"; #\t\tconst string LogLikelihoodKeys::KeySParMod = \"s_par_mod\";  p = sp.create_parameteriser('no apply') # Note: exampleParameterizer is also available p.add_to_hypercube(            pd.DataFrame.from_dict( dict(Name=c('b','m','s','a','maxobs','ct', 'censopt', 'calc_mod_m_s'),           Min   = c(-30, 0, 1,    -30, maxobs, censor_threshold, censopt, calc_m_and_s),           Max   = c(0,   0, 1000, 1, maxobs, censor_threshold, censopt, calc_m_and_s),           Value = c(-7,  0, 100,  -10, maxobs, censor_threshold, censopt, calc_m_and_s)) ))  p.as_dataframe() Out[36]: Name Value Min Max 0 b -7.00 -30.00 0.00 1 m 0.00 0.00 0.00 2 s 100.00 1.00 1000.00 3 a -10.00 -30.00 1.00 4 maxobs 22.00 22.00 22.00 5 ct 0.01 0.01 0.01 6 censopt 0.00 0.00 0.00 7 calc_mod_m_s 1.00 1.00 1.00 In\u00a0[37]: Copied! <pre>func_parameterisers = [p, p.clone()] # for the two calib points, NSE has no param here\ncatchment_pzer = parameteriser\nfp = sp.create_multisite_obj_parameteriser(func_parameterisers, calibration_points, prefixes=paste0(calibration_points, '.'), mix_func_parameteriser=None, hydro_parameteriser=catchment_pzer)\nfp.as_dataframe()\n</pre> func_parameterisers = [p, p.clone()] # for the two calib points, NSE has no param here catchment_pzer = parameteriser fp = sp.create_multisite_obj_parameteriser(func_parameterisers, calibration_points, prefixes=paste0(calibration_points, '.'), mix_func_parameteriser=None, hydro_parameteriser=catchment_pzer) fp.as_dataframe() Out[37]: Name Value Min Max 0 log_x4 0.305422 0.000000 2.380211 1 log_x1 0.506690 0.000000 3.778151 2 log_x3 0.315425 0.000000 3.000000 3 asinh_x2 0.000000 -3.989327 3.989327 4 R0 0.900000 0.000000 1.000000 5 S0 0.900000 0.000000 1.000000 6 alpha 1.000000 0.001000 100.000000 7 inverse_velocity 1.000000 0.001000 100.000000 8 node.7.b -7.000000 -30.000000 0.000000 9 node.7.m 0.000000 0.000000 0.000000 10 node.7.s 100.000000 1.000000 1000.000000 11 node.7.a -10.000000 -30.000000 1.000000 12 node.7.maxobs 22.000000 22.000000 22.000000 13 node.7.ct 0.010000 0.010000 0.010000 14 node.7.censopt 0.000000 0.000000 0.000000 15 node.7.calc_mod_m_s 1.000000 1.000000 1.000000 16 node.12.b -7.000000 -30.000000 0.000000 17 node.12.m 0.000000 0.000000 0.000000 18 node.12.s 100.000000 1.000000 1000.000000 19 node.12.a -10.000000 -30.000000 1.000000 20 node.12.maxobs 22.000000 22.000000 22.000000 21 node.12.ct 0.010000 0.010000 0.010000 22 node.12.censopt 0.000000 0.000000 0.000000 23 node.12.calc_mod_m_s 1.000000 1.000000 1.000000 In\u00a0[38]: Copied! <pre>moe = obj\n</pre> moe = obj <p>To get the overall weighted multiobjective score (for which lower is better)</p> In\u00a0[39]: Copied! <pre>moe.get_score(fp)\n</pre> moe.get_score(fp) Out[39]: <pre>{'scores': {'MultisiteObjectives': 45093.298747974426},\n 'sysconfig':                     Name       Value        Min          Max\n 0                 log_x4    0.305422   0.000000     2.380211\n 1                 log_x1    0.506690   0.000000     3.778151\n 2                 log_x3    0.315425   0.000000     3.000000\n 3               asinh_x2    0.000000  -3.989327     3.989327\n 4                     R0    0.900000   0.000000     1.000000\n 5                     S0    0.900000   0.000000     1.000000\n 6                  alpha    1.000000   0.001000   100.000000\n 7       inverse_velocity    1.000000   0.001000   100.000000\n 8               node.7.b   -7.000000 -30.000000     0.000000\n 9               node.7.m    0.000000   0.000000     0.000000\n 10              node.7.s  100.000000   1.000000  1000.000000\n 11              node.7.a  -10.000000 -30.000000     1.000000\n 12         node.7.maxobs   22.000000  22.000000    22.000000\n 13             node.7.ct    0.010000   0.010000     0.010000\n 14        node.7.censopt    0.000000   0.000000     0.000000\n 15   node.7.calc_mod_m_s    1.000000   1.000000     1.000000\n 16             node.12.b   -7.000000 -30.000000     0.000000\n 17             node.12.m    0.000000   0.000000     0.000000\n 18             node.12.s  100.000000   1.000000  1000.000000\n 19             node.12.a  -10.000000 -30.000000     1.000000\n 20        node.12.maxobs   22.000000  22.000000    22.000000\n 21            node.12.ct    0.010000   0.010000     0.010000\n 22       node.12.censopt    0.000000   0.000000     0.000000\n 23  node.12.calc_mod_m_s    1.000000   1.000000     1.000000}</pre> <p>To get each individual log-likelihood scores for each gauge:</p> In\u00a0[40]: Copied! <pre>moe.get_scores(fp)\n</pre> moe.get_scores(fp) Out[40]: <pre>{'node.12': np.float64(-44776.75651455558),\n 'node.7': np.float64(-45726.383214812144)}</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/calibrate_multisite/#calibration-of-a-catchment-using-multisite-multiobjective-composition","title":"Calibration of a catchment using multisite multiobjective composition\u00b6","text":""},{"location":"notebooks/calibrate_multisite/#about-this-document","title":"About this document\u00b6","text":""},{"location":"notebooks/calibrate_multisite/#use-case","title":"Use case\u00b6","text":"<p>This vignette demonstrates how one can calibrate a catchment using multiple gauging points available within this catchment. This only covers the definition of the calibration, not the execution. The sample data in the package is a small subset of hourly data to keep things (data size, execution time) small.</p> <p>This is a joint calibration weighing multiple objectives, possibly sourced from different modelling objects in the semi-distributed structure, thus a whole-of-catchment calibration technique. A staged, cascading calibration is supported and described in another vignette.</p>"},{"location":"notebooks/calibrate_multisite/#data","title":"Data\u00b6","text":"<p>The sample data that comes with the package contains a model definition for the South Esk catchment, including a short subset of the climate and flow record data.</p> <p></p>"},{"location":"notebooks/calibrate_multisite/#base-model-creation","title":"Base model creation\u00b6","text":""},{"location":"notebooks/calibrate_multisite/#parameterisation","title":"Parameterisation\u00b6","text":"<p>We define a function creating a realistic feasible parameter space. The parameteriser is relatively sophisticated, but this is not the main purpose of this vignette, so we do not describe the process about defining and creating parameterisers in gread details.</p>"},{"location":"notebooks/calibrate_multisite/#defining-weighting-multi-objectives","title":"Defining weighting multi-objectives\u00b6","text":"<p>The sample gauge data flow contains gauge identifiers as column headers</p>"},{"location":"notebooks/calibrate_multisite/#log-likelihood-multiple-objective","title":"log-likelihood multiple objective\u00b6","text":"<p>Now, let's move on to use log-likelihood instead of NSE. This adds one level of complexity compared to the above. Besides calibrating the hydrologic parameters of GR4J and flow routing, with the Log-Likelihood we introduce a set of parameters $(a, b, m, s, ...)$ for each calibration point. The statistic definition is similar and still straightforward</p>"},{"location":"notebooks/calibrate_subcatchments/","title":"Cascaded calibration of subcatchments defined by multiple gauges","text":"In\u00a0[1]: Copied! <pre>from swift2.doc_helper import pkg_versions_info\n\nprint(pkg_versions_info(\"This document was generated from a jupyter notebook\"))\n</pre> from swift2.doc_helper import pkg_versions_info  print(pkg_versions_info(\"This document was generated from a jupyter notebook\")) <pre>This document was generated from a jupyter notebook on 2025-05-16 14:15:17.341877\n    swift2 2.5.1\n    uchronia 2.6.2\n</pre> In\u00a0[2]: Copied! <pre>import datetime as dt\nfrom collections import OrderedDict\n\nimport numpy as np\n</pre> import datetime as dt from collections import OrderedDict  import numpy as np In\u00a0[3]: Copied! <pre>import swift2.doc_helper as std\nimport swift2.parameteriser as sp\n</pre> import swift2.doc_helper as std import swift2.parameteriser as sp In\u00a0[4]: Copied! <pre>from cinterop.timeseries import xr_ts_end, xr_ts_start\nfrom swift2.classes import CompositeParameteriser, ObjectiveEvaluator, Simulation\nfrom swift2.const import CATCHMENT_FLOWRATE_VARID\nfrom swift2.vis import plot_two_series\n</pre> from cinterop.timeseries import xr_ts_end, xr_ts_start from swift2.classes import CompositeParameteriser, ObjectiveEvaluator, Simulation from swift2.const import CATCHMENT_FLOWRATE_VARID from swift2.vis import plot_two_series In\u00a0[5]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[6]: Copied! <pre>model_id = 'GR4J'\nsite_id = 'South_Esk'\nsimulation = std.sample_catchment_model(site_id=site_id, config_id='catchment')\nsimulation = simulation.swap_model('LagAndRoute', 'channel_routing')\n</pre> model_id = 'GR4J' site_id = 'South_Esk' simulation = std.sample_catchment_model(site_id=site_id, config_id='catchment') simulation = simulation.swap_model('LagAndRoute', 'channel_routing') <p>A visual of the catchment structure (note: may not render yet through GitHub)</p> In\u00a0[7]: Copied! <pre># DiagrammeR(getCatchmentDotGraph(simulation))\n# TODO...\n# https://towardsdatascience.com/visualizing-networks-in-python-d70f4cbeb259\n# https://medium.com/@ludvig.hult/drawing-graphs-with-python-in-2019-bdd42bf9d5db\n</pre> # DiagrammeR(getCatchmentDotGraph(simulation)) # TODO... # https://towardsdatascience.com/visualizing-networks-in-python-d70f4cbeb259 # https://medium.com/@ludvig.hult/drawing-graphs-with-python-in-2019-bdd42bf9d5db In\u00a0[8]: Copied! <pre>se_climate = std.sample_series(site_id=site_id, var_name='climate')\nse_flows = std.sample_series(site_id=site_id, var_name='flow')\n</pre> se_climate = std.sample_series(site_id=site_id, var_name='climate') se_flows = std.sample_series(site_id=site_id, var_name='flow') In\u00a0[9]: Copied! <pre># se_climate[\"subcatchment.5.P\"].plot()\n</pre> # se_climate[\"subcatchment.5.P\"].plot() <p>The names of the climate series is already set to the climate input identifiers of the model simulation, so setting them as inputs is easy:</p> In\u00a0[10]: Copied! <pre>se_climate.head(3)\n</pre> se_climate.head(3) Out[10]: subcatchment.1.E subcatchment.1.P subcatchment.10.E subcatchment.10.P subcatchment.11.E subcatchment.11.P subcatchment.12.E subcatchment.12.P subcatchment.13.E subcatchment.13.P ... subcatchment.5.E subcatchment.5.P subcatchment.6.E subcatchment.6.P subcatchment.7.E subcatchment.7.P subcatchment.8.E subcatchment.8.P subcatchment.9.E subcatchment.9.P 2010-11-01 00:00:00 0.3918 0.0 0.4020 0.0000 0.3978 0.0000 0.4266 0.0000 0.3936 0.0000 ... 0.4325 0.0 0.4110 0.0322 0.4247 0.0 0.4377 0.0 0.4337 0.0 2010-11-01 01:00:00 0.4385 0.0 0.4493 0.0207 0.4446 0.0433 0.4763 0.0179 0.4397 0.0555 ... 0.4823 0.0 0.4593 0.0000 0.4746 0.0 0.4892 0.0 0.4841 0.0 2010-11-01 02:00:00 0.4614 0.0 0.4723 0.0000 0.4671 0.0000 0.5002 0.0000 0.4619 0.0000 ... 0.5060 0.0 0.4827 0.0000 0.4987 0.0 0.5143 0.0 0.5084 0.0 <p>3 rows \u00d7 84 columns</p> In\u00a0[11]: Copied! <pre>simulation.play_input(se_climate)\nsimulation.set_simulation_span(xr_ts_start(se_climate), xr_ts_end(se_climate))\nsimulation.set_simulation_time_step('hourly')\n</pre> simulation.play_input(se_climate) simulation.set_simulation_span(xr_ts_start(se_climate), xr_ts_end(se_climate)) simulation.set_simulation_time_step('hourly') <p>The <code>doc_helper</code> submodule has helper functions to configure the gr4j model to such that it is fit to run on hourly data:</p> In\u00a0[12]: Copied! <pre>std.configure_hourly_gr4j(simulation)\n</pre> std.configure_hourly_gr4j(simulation) In\u00a0[13]: Copied! <pre>import swift2.helpers as hlp\nimport swift2.parameteriser as sp\nfrom swift2.utils import as_xarray_series, c, paste0, rep\n\n\ndef create_meta_parameteriser(simulation:Simulation, ref_area=250, time_span=3600):  \n    time_span = int(time_span)\n    parameteriser = std.define_gr4j_scaled_parameter(ref_area, time_span)\n  \n    # Let's define _S0_ and _R0_ parameters such that for each GR4J model instance, _S = S0 * x1_ and _R = R0 * x3_\n    p_states = sp.linear_parameteriser(\n                      param_name=c(\"S0\",\"R0\"), \n                      state_name=c(\"S\",\"R\"), \n                      scaling_var_name=c(\"x1\",\"x3\"),\n                      min_p_val=c(0.0,0.0), \n                      max_p_val=c(1.0,1.0), \n                      value=c(0.9,0.9), \n                      selector_type='each subarea')\n  \n    init_parameteriser = p_states.make_state_init_parameteriser()\n    parameteriser = sp.concatenate_parameterisers(parameteriser, init_parameteriser)\n    \n    hlp.lag_and_route_linear_storage_type(simulation)\n    hlp.set_reach_lengths_lag_n_route(simulation)\n\n    lnrp = hlp.parameteriser_lag_and_route()\n    parameteriser = CompositeParameteriser.concatenate(parameteriser, lnrp, strategy='')\n    return parameteriser\n</pre>  import swift2.helpers as hlp import swift2.parameteriser as sp from swift2.utils import as_xarray_series, c, paste0, rep   def create_meta_parameteriser(simulation:Simulation, ref_area=250, time_span=3600):       time_span = int(time_span)     parameteriser = std.define_gr4j_scaled_parameter(ref_area, time_span)        # Let's define _S0_ and _R0_ parameters such that for each GR4J model instance, _S = S0 * x1_ and _R = R0 * x3_     p_states = sp.linear_parameteriser(                       param_name=c(\"S0\",\"R0\"),                        state_name=c(\"S\",\"R\"),                        scaling_var_name=c(\"x1\",\"x3\"),                       min_p_val=c(0.0,0.0),                        max_p_val=c(1.0,1.0),                        value=c(0.9,0.9),                        selector_type='each subarea')        init_parameteriser = p_states.make_state_init_parameteriser()     parameteriser = sp.concatenate_parameterisers(parameteriser, init_parameteriser)          hlp.lag_and_route_linear_storage_type(simulation)     hlp.set_reach_lengths_lag_n_route(simulation)      lnrp = hlp.parameteriser_lag_and_route()     parameteriser = CompositeParameteriser.concatenate(parameteriser, lnrp, strategy='')     return parameteriser In\u00a0[14]: Copied! <pre>parameteriser = create_meta_parameteriser(simulation)\nparameteriser.as_dataframe()\n</pre> parameteriser = create_meta_parameteriser(simulation) parameteriser.as_dataframe() Out[14]: Name Value Min Max 0 log_x4 0.305422 0.000000 2.380211 1 log_x1 0.506690 0.000000 3.778151 2 log_x3 0.315425 0.000000 3.000000 3 asinh_x2 2.637752 -3.989327 3.989327 4 R0 0.900000 0.000000 1.000000 5 S0 0.900000 0.000000 1.000000 6 alpha 1.000000 0.001000 100.000000 7 inverse_velocity 1.000000 0.001000 100.000000 <p>Now, checking that a default parameter set works structurally on the simulation:</p> In\u00a0[15]: Copied! <pre>parameteriser.set_parameter_value('asinh_x2', 0)\nparameteriser.apply_sys_config(simulation)\nsimulation.exec_simulation()\n</pre> parameteriser.set_parameter_value('asinh_x2', 0) parameteriser.apply_sys_config(simulation) simulation.exec_simulation() <p>We are now ready to enter the main topic of this vignette, subsetting the catchment into subcatchments for calibration purposes.</p> In\u00a0[16]: Copied! <pre>gauges = c( '92106', '592002', '18311', '93044',    '25',   '181')\nnode_ids = paste0('node.', c('7',   '12',   '25',   '30',   '40',   '43'))\nnode_gauges = OrderedDict([(node_ids[i], gauges[i]) for i in range(len(gauges))])\n# names(gauges) = node_ids\n</pre> gauges = c( '92106', '592002', '18311', '93044',    '25',   '181') node_ids = paste0('node.', c('7',   '12',   '25',   '30',   '40',   '43')) node_gauges = OrderedDict([(node_ids[i], gauges[i]) for i in range(len(gauges))]) # names(gauges) = node_ids In\u00a0[17]: Copied! <pre>simulation.get_variable_ids(node_ids[0])\n</pre> simulation.get_variable_ids(node_ids[0]) Out[17]: <pre>['node.7.InflowRate',\n 'node.7.InflowVolume',\n 'node.7.AdditionalInflowRate',\n 'node.7.AbstractionDemandRate',\n 'node.7.AbstractionSuppliedRate',\n 'node.7.OutflowRate',\n 'node.7.OutflowVolume']</pre> In\u00a0[18]: Copied! <pre>simulation.record_state(paste0(node_ids, \".OutflowRate\"))\n</pre> simulation.record_state(paste0(node_ids, \".OutflowRate\")) In\u00a0[19]: Copied! <pre>simulation.exec_simulation()\n</pre> simulation.exec_simulation() In\u00a0[20]: Copied! <pre>modelled = simulation.get_all_recorded()\n</pre> modelled = simulation.get_all_recorded() In\u00a0[21]: Copied! <pre>modelled\n</pre> modelled Out[21]: <pre>&lt;xarray.DataArray (variable_identifiers: 6, ensemble: 1, time: 480)&gt; Size: 23kB\narray([[[11.80066449,  7.44947703, 18.42497666, ...,  0.28179863,\n          0.27663744,  0.27165243]],\n\n       [[11.19512081,  6.66918055, 12.49597281, ...,  0.38460207,\n          0.38065825,  0.37679025]],\n\n       [[ 6.83285487, 10.68999615, 17.44945727, ...,  2.26019515,\n          2.22860765,  2.19794827]],\n\n       [[11.86391178, 12.88237054, 11.40568098, ...,  0.13346021,\n          0.13235124,  0.13125882]],\n\n       [[19.862354  , 11.83475444,  8.23442729, ...,  3.61385335,\n          3.55119926,  3.49124398]],\n\n       [[20.9016399 , 23.51593328, 28.95913953, ...,  0.43200931,\n          0.42719557,  0.42247987]]], shape=(6, 1, 480))\nCoordinates:\n  * ensemble              (ensemble) int64 8B 0\n  * time                  (time) datetime64[ns] 4kB 2010-11-01 ... 2010-11-20...\n  * variable_identifiers  (variable_identifiers) object 48B 'node.12.OutflowR...</pre>xarray.DataArray<ul><li>variable_identifiers: 6</li><li>ensemble: 1</li><li>time: 480</li></ul><ul><li>11.8 7.449 18.42 11.78 8.579 ... 0.4419 0.4369 0.432 0.4272 0.4225<pre>array([[[11.80066449,  7.44947703, 18.42497666, ...,  0.28179863,\n          0.27663744,  0.27165243]],\n\n       [[11.19512081,  6.66918055, 12.49597281, ...,  0.38460207,\n          0.38065825,  0.37679025]],\n\n       [[ 6.83285487, 10.68999615, 17.44945727, ...,  2.26019515,\n          2.22860765,  2.19794827]],\n\n       [[11.86391178, 12.88237054, 11.40568098, ...,  0.13346021,\n          0.13235124,  0.13125882]],\n\n       [[19.862354  , 11.83475444,  8.23442729, ...,  3.61385335,\n          3.55119926,  3.49124398]],\n\n       [[20.9016399 , 23.51593328, 28.95913953, ...,  0.43200931,\n          0.42719557,  0.42247987]]], shape=(6, 1, 480))</pre></li><li>Coordinates: (3)<ul><li>ensemble(ensemble)int640<pre>array([0])</pre></li><li>time(time)datetime64[ns]2010-11-01 ... 2010-11-20T23:00:00<pre>array(['2010-11-01T00:00:00.000000000', '2010-11-01T01:00:00.000000000',\n       '2010-11-01T02:00:00.000000000', ..., '2010-11-20T21:00:00.000000000',\n       '2010-11-20T22:00:00.000000000', '2010-11-20T23:00:00.000000000'],\n      shape=(480,), dtype='datetime64[ns]')</pre></li><li>variable_identifiers(variable_identifiers)object'node.12.OutflowRate' ... 'node....<pre>array(['node.12.OutflowRate', 'node.25.OutflowRate', 'node.30.OutflowRate',\n       'node.40.OutflowRate', 'node.43.OutflowRate', 'node.7.OutflowRate'],\n      dtype=object)</pre></li></ul></li><li>Indexes: (3)<ul><li>ensemblePandasIndex<pre>PandasIndex(Index([0], dtype='int64', name='ensemble'))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2010-11-01 00:00:00', '2010-11-01 01:00:00',\n               '2010-11-01 02:00:00', '2010-11-01 03:00:00',\n               '2010-11-01 04:00:00', '2010-11-01 05:00:00',\n               '2010-11-01 06:00:00', '2010-11-01 07:00:00',\n               '2010-11-01 08:00:00', '2010-11-01 09:00:00',\n               ...\n               '2010-11-20 14:00:00', '2010-11-20 15:00:00',\n               '2010-11-20 16:00:00', '2010-11-20 17:00:00',\n               '2010-11-20 18:00:00', '2010-11-20 19:00:00',\n               '2010-11-20 20:00:00', '2010-11-20 21:00:00',\n               '2010-11-20 22:00:00', '2010-11-20 23:00:00'],\n              dtype='datetime64[ns]', name='time', length=480, freq='h'))</pre></li><li>variable_identifiersPandasIndex<pre>PandasIndex(Index(['node.12.OutflowRate', 'node.25.OutflowRate', 'node.30.OutflowRate',\n       'node.40.OutflowRate', 'node.43.OutflowRate', 'node.7.OutflowRate'],\n      dtype='object', name='variable_identifiers'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[22]: Copied! <pre>modelled.sel(variable_identifiers='node.7.OutflowRate').plot()\n</pre> modelled.sel(variable_identifiers='node.7.OutflowRate').plot() Out[22]: <pre>[&lt;matplotlib.lines.Line2D at 0x7fe5bf6eb450&gt;]</pre> In\u00a0[23]: Copied! <pre>se_flows[gauges[3]].plot()\n</pre> se_flows[gauges[3]].plot() Out[23]: <pre>&lt;Axes: &gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[24]: Copied! <pre>split_element_ids = node_ids\nsub_cats = simulation.split_to_subcatchments(split_element_ids)\nsub_cats\n</pre> split_element_ids = node_ids sub_cats = simulation.split_to_subcatchments(split_element_ids) sub_cats Out[24]: <pre>OrderedDict([('node.40',\n              Simulation wrapper for a CFFI pointer handle to a native pointer of type id \"MODEL_SIMULATION_PTR\"),\n             ('node.25',\n              Simulation wrapper for a CFFI pointer handle to a native pointer of type id \"MODEL_SIMULATION_PTR\"),\n             ('node.12',\n              Simulation wrapper for a CFFI pointer handle to a native pointer of type id \"MODEL_SIMULATION_PTR\"),\n             ('node.7',\n              Simulation wrapper for a CFFI pointer handle to a native pointer of type id \"MODEL_SIMULATION_PTR\"),\n             ('node.30',\n              Simulation wrapper for a CFFI pointer handle to a native pointer of type id \"MODEL_SIMULATION_PTR\"),\n             ('node.43',\n              Simulation wrapper for a CFFI pointer handle to a native pointer of type id \"MODEL_SIMULATION_PTR\")])</pre> <p>The resulting list of subcatchment simulations is already ordered in an upstream to downstream order by SWIFT.</p> <p>If we are to set up the first step of the sequential calibration:</p> In\u00a0[25]: Copied! <pre>sub_cats['node.40'].describe()\n</pre> sub_cats['node.40'].describe() Out[25]: <pre>{'subareas': {'37': 'Subarea_37', '38': 'Subarea_38', '39': 'Subarea_39'},\n 'nodes': {'40': 'Node_40', '39': 'Node_39', '38': 'Node_38', '37': 'Node_37'},\n 'links': {'39': 'Subarea_39', '38': 'Subarea_38', '37': 'Subarea_37'}}</pre> In\u00a0[26]: Copied! <pre>def first(d:OrderedDict):\n    return list(sub_cats.items())[0]  \n</pre> def first(d:OrderedDict):     return list(sub_cats.items())[0]   In\u00a0[27]: Copied! <pre>element_id = first(sub_cats)[0]\nelement_id\n</pre> element_id = first(sub_cats)[0] element_id Out[27]: <pre>'node.40'</pre> In\u00a0[28]: Copied! <pre>gaugeId = node_gauges[element_id]\ngaugeId\n</pre> gaugeId = node_gauges[element_id] gaugeId Out[28]: <pre>np.str_('25')</pre> In\u00a0[29]: Copied! <pre>gauge_flow = se_flows[[gaugeId]]\ngauge_flow.head()\n</pre> gauge_flow = se_flows[[gaugeId]] gauge_flow.head() Out[29]: 25 2010-11-01 00:00:00 1.229 2010-11-01 01:00:00 1.259 2010-11-01 02:00:00 1.280 2010-11-01 03:00:00 1.291 2010-11-01 04:00:00 1.296 In\u00a0[30]: Copied! <pre>sc = sub_cats[element_id]\nsc\n</pre> sc = sub_cats[element_id] sc Out[30]: <pre>Simulation wrapper for a CFFI pointer handle to a native pointer of type id \"MODEL_SIMULATION_PTR\"</pre> In\u00a0[31]: Copied! <pre>parameteriser.apply_sys_config(sc)\nvar_id = CATCHMENT_FLOWRATE_VARID\nsc.record_state(var_id)\n</pre> parameteriser.apply_sys_config(sc) var_id = CATCHMENT_FLOWRATE_VARID sc.record_state(var_id) In\u00a0[32]: Copied! <pre># DiagrammeR(getCatchmentDotGraph(sc))\n</pre> # DiagrammeR(getCatchmentDotGraph(sc)) <p>Let's view the default, uncalibrated output</p> In\u00a0[33]: Copied! <pre>simulation.get_simulation_span()\n</pre> simulation.get_simulation_span() Out[33]: <pre>{'start': datetime.datetime(2010, 11, 1, 0, 0),\n 'end': datetime.datetime(2010, 11, 20, 23, 0),\n 'time step': 'hourly'}</pre> In\u00a0[34]: Copied! <pre>def plot_obs_vs_calc(obs, calc, ylab=\"streamflow (m3/s)\"):\n    plot_two_series(obs, calc, start_time = xr_ts_start(obs), end_time = xr_ts_end(obs))\n</pre> def plot_obs_vs_calc(obs, calc, ylab=\"streamflow (m3/s)\"):     plot_two_series(obs, calc, start_time = xr_ts_start(obs), end_time = xr_ts_end(obs)) In\u00a0[35]: Copied! <pre>gauge_flow = as_xarray_series(gauge_flow)\n</pre> gauge_flow = as_xarray_series(gauge_flow) In\u00a0[36]: Copied! <pre>sc.exec_simulation()\nplot_obs_vs_calc(gauge_flow, sc.get_recorded(var_id))\n</pre> sc.exec_simulation() plot_obs_vs_calc(gauge_flow, sc.get_recorded(var_id)) <p>Now, setting up an objective (NSE) and optimiser:</p> In\u00a0[37]: Copied! <pre>objectiveId = 'NSE'\nobjective = sc.create_objective(var_id, gauge_flow, objectiveId, xr_ts_start(se_flows), xr_ts_end(se_flows))\nscore = objective.get_score(parameteriser)  \n</pre> objectiveId = 'NSE' objective = sc.create_objective(var_id, gauge_flow, objectiveId, xr_ts_start(se_flows), xr_ts_end(se_flows)) score = objective.get_score(parameteriser)   In\u00a0[38]: Copied! <pre># termination = getMarginalTermination( tolerance = 1e-04, cutoff_no_improvement = 30, max_hours = 2/60) \ntermination = sp.create_sce_termination_wila('relative standard deviation', c('0.05','0.0167'))\nsce_params = sp.get_default_sce_parameters()\nparams = parameteriser.as_dataframe()\n</pre> # termination = getMarginalTermination( tolerance = 1e-04, cutoff_no_improvement = 30, max_hours = 2/60)  termination = sp.create_sce_termination_wila('relative standard deviation', c('0.05','0.0167')) sce_params = sp.get_default_sce_parameters() params = parameteriser.as_dataframe() In\u00a0[39]: Copied! <pre>np.count_nonzero(abs(params.Max-params.Min)&gt;0)\n</pre> np.count_nonzero(abs(params.Max-params.Min)&gt;0) Out[39]: <pre>8</pre> In\u00a0[40]: Copied! <pre>npars = np.count_nonzero(abs(params.Max-params.Min)&gt;0)\nsce_params = std.sce_parameter(npars)\noptimiser = objective.create_sce_optim_swift(termination_criterion = termination, population_initialiser = parameteriser,sce_params = sce_params)\ncalib_logger = optimiser.set_calibration_logger(\"dummy\")\n</pre> npars = np.count_nonzero(abs(params.Max-params.Min)&gt;0) sce_params = std.sce_parameter(npars) optimiser = objective.create_sce_optim_swift(termination_criterion = termination, population_initialiser = parameteriser,sce_params = sce_params) calib_logger = optimiser.set_calibration_logger(\"dummy\") In\u00a0[41]: Copied! <pre>%%time\ncalib_results = optimiser.execute_optimisation()\n</pre> %%time calib_results = optimiser.execute_optimisation() <pre>CPU times: user 4min 15s, sys: 58.6 ms, total: 4min 15s\nWall time: 37.6 s\n</pre> <p>And the resulting hydrograph follows. The NSE score is decent, but the magnitude of the peak is not well represented. We used a uniform value for the routing parameters; having a scaling based on link properties may be a line of enquiry.</p> In\u00a0[42]: Copied! <pre>sorted_results = calib_results.sort_by_score('NSE')\nd = sorted_results.as_dataframe()\nd.head()\n</pre> sorted_results = calib_results.sort_by_score('NSE') d = sorted_results.as_dataframe() d.head() Out[42]: NSE log_x4 log_x1 log_x3 asinh_x2 R0 S0 alpha inverse_velocity 0 0.494486 2.083412 0.817456 0.543006 0.201668 0.486912 0.566229 52.931056 57.135610 1 0.494270 2.088946 0.877532 0.480031 0.212400 0.436573 0.525331 53.521435 53.435698 2 0.494118 2.078820 0.853538 0.527632 0.234605 0.474694 0.510408 48.404811 55.239899 3 0.493718 2.084039 0.874168 0.521461 0.239327 0.483183 0.534643 52.075063 50.367980 4 0.493551 2.093115 0.853368 0.481468 0.214864 0.509028 0.536058 53.395207 55.080122 In\u00a0[43]: Copied! <pre>d.tail()\n</pre> d.tail() Out[43]: NSE log_x4 log_x1 log_x3 asinh_x2 R0 S0 alpha inverse_velocity 165 0.482992 2.079494 0.812588 0.494737 0.140989 0.497908 0.522849 46.473800 54.568243 166 0.482560 2.062943 0.781697 0.596623 0.220231 0.527801 0.552285 54.745652 67.971298 167 0.482497 2.106522 0.829144 0.412829 0.138130 0.530156 0.593584 52.202333 60.017567 168 0.482294 2.081617 0.908696 0.424188 0.211116 0.516536 0.477412 54.026519 48.048843 169 0.482252 2.086505 0.738809 0.564237 0.093866 0.515100 0.493760 54.961603 53.276150 In\u00a0[44]: Copied! <pre>p = sorted_results.get_parameters_at_index(1)\np\n</pre> p = sorted_results.get_parameters_at_index(1) p Out[44]: <pre>               Name      Value       Min         Max\n0            log_x4   2.083412  0.000000    2.380211\n1            log_x1   0.817456  0.000000    3.778151\n2            log_x3   0.543006  0.000000    3.000000\n3          asinh_x2   0.201668 -3.989327    3.989327\n4                R0   0.486912  0.000000    1.000000\n5                S0   0.566229  0.000000    1.000000\n6             alpha  52.931056  0.001000  100.000000\n7  inverse_velocity  57.135610  0.001000  100.000000</pre> In\u00a0[45]: Copied! <pre>p.apply_sys_config(sc)\nsc.exec_simulation()\nplot_obs_vs_calc(gauge_flow, sc.get_recorded(var_id))\n</pre> p.apply_sys_config(sc) sc.exec_simulation() plot_obs_vs_calc(gauge_flow, sc.get_recorded(var_id)) <p>We can create a subcatchment parameteriser, such that when applied to the whole of the South Esk, only the states of the subareas, links and nodes of the subcatchment are potentially affected.</p> In\u00a0[46]: Copied! <pre>sp = p.subcatchment_parameteriser(sc)\nsp.apply_sys_config(simulation)\nsimulation.get_state_value(paste0('subarea.', np.arange(34,stop=41), '.x2'))\n# saIds = get_subarea_ids(simulation)\n</pre> sp = p.subcatchment_parameteriser(sc) sp.apply_sys_config(simulation) simulation.get_state_value(paste0('subarea.', np.arange(34,stop=41), '.x2')) # saIds = get_subarea_ids(simulation) Out[46]: <pre>{'subarea.34.x2': 0.0,\n 'subarea.35.x2': 0.0,\n 'subarea.36.x2': 0.0,\n 'subarea.37.x2': 0.13603542953576564,\n 'subarea.38.x2': 0.13603542953576564,\n 'subarea.39.x2': 0.13603542953576564,\n 'subarea.40.x2': 0.0}</pre> In\u00a0[47]: Copied! <pre># TODO\n# spFile = tempfile()\n# SaveParameterizer_R(sp, spFile)\n# # Following fails 2020-06, see https://jira.csiro.au/browse/WIRADA-631 \n# # sp2 = LoadParameterizer_R(spFile)\n\n# if(file.exists(spFile)) { file.remove(spFile) }\n</pre> # TODO # spFile = tempfile() # SaveParameterizer_R(sp, spFile) # # Following fails 2020-06, see https://jira.csiro.au/browse/WIRADA-631  # # sp2 = LoadParameterizer_R(spFile)  # if(file.exists(spFile)) { file.remove(spFile) } In\u00a0[48]: remove_cell Copied! <pre>p = sorted_results.get_parameters_at_index(1)\np.as_dataframe()\n</pre> p = sorted_results.get_parameters_at_index(1) p.as_dataframe() Out[48]: Name Value Min Max 0 log_x4 2.083412 0.000000 2.380211 1 log_x1 0.817456 0.000000 3.778151 2 log_x3 0.543006 0.000000 3.000000 3 asinh_x2 0.201668 -3.989327 3.989327 4 R0 0.486912 0.000000 1.000000 5 S0 0.566229 0.000000 1.000000 6 alpha 52.931056 0.001000 100.000000 7 inverse_velocity 57.135610 0.001000 100.000000 In\u00a0[49]: remove_cell Copied! <pre># swoop(sc, p, param_name, from, to, num=10, var_id) {\n#   if(missing(from)) { from = GetParameterMinValue_R(p, param_name)}\n#   if(missing(to))   { to = GetParameterMaxValue_R(p, param_name)}\n#   oat(sc, p, param_name, from=from, to=to, num=num, var_id) \n# }\n\n# testp(sim, p, ...) {\n#   q = CloneHypercubeParameterizer_R(p)\n#   execSimulation(sim)\n#   params = list(...)\n#   for(pname in names(params)) {set_parameter_value(q, pname, params[[pname]])}\n#   plot_obs_vs_calc(gaugeFlow, getRecorded(sim, var_id))\n# }\n\n# flows = swoop(sc, p, 'log_x4', var_id=var_id)\n\n# flows = swoop('log_x1')\n# flows = swoop('Alpha')\n# flows = merge(flows, gaugeFlow)\n# zoo::plot.zoo(flows, plot.type='single')\n# col=c('orange', 'black','blue','red')\n\n# f(...) {\n# params = list(...)\n# params\n# set_parameter_value(p, names(params), as.numeric(params))\n# applySysConfig(p, sc)\n# execSimulation(sc)\n# plot_obs_vs_calc(gaugeFlow, getRecorded(sc, var_id))\n# }\n</pre> # swoop(sc, p, param_name, from, to, num=10, var_id) { #   if(missing(from)) { from = GetParameterMinValue_R(p, param_name)} #   if(missing(to))   { to = GetParameterMaxValue_R(p, param_name)} #   oat(sc, p, param_name, from=from, to=to, num=num, var_id)  # }  # testp(sim, p, ...) { #   q = CloneHypercubeParameterizer_R(p) #   execSimulation(sim) #   params = list(...) #   for(pname in names(params)) {set_parameter_value(q, pname, params[[pname]])} #   plot_obs_vs_calc(gaugeFlow, getRecorded(sim, var_id)) # }  # flows = swoop(sc, p, 'log_x4', var_id=var_id)  # flows = swoop('log_x1') # flows = swoop('Alpha') # flows = merge(flows, gaugeFlow) # zoo::plot.zoo(flows, plot.type='single') # col=c('orange', 'black','blue','red')  # f(...) { # params = list(...) # params # set_parameter_value(p, names(params), as.numeric(params)) # applySysConfig(p, sc) # execSimulation(sc) # plot_obs_vs_calc(gaugeFlow, getRecorded(sc, var_id)) # } In\u00a0[50]: Copied! <pre>gauges = c( '92106', '592002', '18311', '93044',    '25',   '181')\nnode_ids = paste0('node.', c('7',   '12',   '25',   '30',   '40',   '43'))\nnode_gauges = OrderedDict([(node_ids[i], gauges[i]) for i in range(len(gauges))])\n# names(gauges) = node_ids\n</pre> gauges = c( '92106', '592002', '18311', '93044',    '25',   '181') node_ids = paste0('node.', c('7',   '12',   '25',   '30',   '40',   '43')) node_gauges = OrderedDict([(node_ids[i], gauges[i]) for i in range(len(gauges))]) # names(gauges) = node_ids In\u00a0[51]: Copied! <pre>calibNodes = paste0('node.', [\"7\",\"12\"])\n</pre> calibNodes = paste0('node.', [\"7\",\"12\"])   In\u00a0[52]: Copied! <pre>element_id = first(sub_cats)[0]\nelement_id\n</pre> element_id = first(sub_cats)[0] element_id Out[52]: <pre>'node.40'</pre> In\u00a0[53]: Copied! <pre>gaugeId = [node_gauges[k] for k in calibNodes]\ngauge_flow = se_flows[gaugeId]\n</pre> gaugeId = [node_gauges[k] for k in calibNodes] gauge_flow = se_flows[gaugeId] In\u00a0[54]: Copied! <pre>sc = sub_cats[element_id]\nparameteriser.apply_sys_config(sc)\n\nvar_id = paste0(calibNodes, '.OutflowRate')\nsimulation.record_state(var_id)\n</pre> sc = sub_cats[element_id] parameteriser.apply_sys_config(sc)  var_id = paste0(calibNodes, '.OutflowRate') simulation.record_state(var_id) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[55]: Copied! <pre>objectiveId = 'NSE'\n\ndef create_obj_station(i:int):\n    obs = as_xarray_series(gauge_flow[[gaugeId[i]]])\n    return simulation.create_objective(var_id[i], obs, objectiveId, xr_ts_start(se_flows), xr_ts_end(se_flows))\n\nobjectives = [create_obj_station(i) for i in [0,1]]\n\nco = ObjectiveEvaluator.create_composite_objective(objectives, [1.0,1.0], var_id[:2])\n</pre> objectiveId = 'NSE'  def create_obj_station(i:int):     obs = as_xarray_series(gauge_flow[[gaugeId[i]]])     return simulation.create_objective(var_id[i], obs, objectiveId, xr_ts_start(se_flows), xr_ts_end(se_flows))  objectives = [create_obj_station(i) for i in [0,1]]  co = ObjectiveEvaluator.create_composite_objective(objectives, [1.0,1.0], var_id[:2]) In\u00a0[56]: Copied! <pre>score = co.get_score(parameteriser) \n# scoresAsDataFrame(score)\n</pre> score = co.get_score(parameteriser)  # scoresAsDataFrame(score) In\u00a0[57]: Copied! <pre>score\n</pre> score Out[57]: <pre>{'scores': {'NSE:1.000000,NSE:1.000000': -255.57587357245515},\n 'sysconfig':                Name     Value       Min         Max\n 0            log_x4  0.305422  0.000000    2.380211\n 1            log_x1  0.506690  0.000000    3.778151\n 2            log_x3  0.315425  0.000000    3.000000\n 3          asinh_x2  0.000000 -3.989327    3.989327\n 4                R0  0.900000  0.000000    1.000000\n 5                S0  0.900000  0.000000    1.000000\n 6             alpha  1.000000  0.001000  100.000000\n 7  inverse_velocity  1.000000  0.001000  100.000000}</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/calibrate_subcatchments/#cascaded-calibration-of-subcatchments-defined-by-multiple-gauges","title":"Cascaded calibration of subcatchments defined by multiple gauges\u00b6","text":""},{"location":"notebooks/calibrate_subcatchments/#use-case","title":"Use case\u00b6","text":"<p>2021-01: this vignette works structurally, but is confined to overly short (and possibly difficult) data to keep runtime low</p> <p>This vignette demonstrates how one can calibrate a catchment using multiple gauging points available within this catchment. Instead of setting up a whole-of-catchment calibration definition, it makes sense, at least in a system where subareas above a gauge points do not have a behavior dependent on other catchment processes (meaning mostly, no managed reservoirs). SWIFT offers capabilities to calibrate such subcatchments sequentially, feeding the input flow of upstream and already calibrated subcatchments to other subcatchments, thus cutting down on the complexity and runtime of the overall catchment calibration.</p>"},{"location":"notebooks/calibrate_subcatchments/#data","title":"Data\u00b6","text":"<p>The sample data that comes with the package contains a model definition for the South Esk catchment, including a short subset of the climate and flow record data.</p>"},{"location":"notebooks/calibrate_subcatchments/#parameterisation","title":"Parameterisation\u00b6","text":"<p>We define a function creating a realistic feasible parameter space. This is not the main object of this vignette, so we do not describe in details.</p>"},{"location":"notebooks/calibrate_subcatchments/#splitting-the-catchment-in-subcatchments","title":"Splitting the catchment in subcatchments\u00b6","text":"<p>The sample gauge data flow contains identifiers that are of course distinct from the network node identifiers. We create a map between them (note - this information used to be in the NodeLink file in swiftv1), and we use these node as splitting points to derive subcatchments</p>"},{"location":"notebooks/calibrate_subcatchments/#test-running-and-recording-streamflows","title":"Test running and recording streamflows\u00b6","text":""},{"location":"notebooks/calibrate_subcatchments/#whole-of-catchment-calibration-combining-point-gauges","title":"Whole of catchment calibration combining point gauges\u00b6","text":""},{"location":"notebooks/calibration_initial_states/","title":"Calibration with initial model memory states as parameters","text":"In\u00a0[1]: Copied! <pre>from swift2.doc_helper import pkg_versions_info\n\nprint(pkg_versions_info(\"This document was generated from a jupyter notebook\"))\n\n#\n</pre> from swift2.doc_helper import pkg_versions_info  print(pkg_versions_info(\"This document was generated from a jupyter notebook\"))  # <pre>This document was generated from a jupyter notebook on 2025-05-16 14:15:59.680048\n    swift2 2.5.1\n    uchronia 2.6.2\n</pre> In\u00a0[2]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport swift2.doc_helper as std\nimport swift2.parameteriser as sp\nimport swift2.system as ssy\n</pre> import numpy as np import pandas as pd import swift2.doc_helper as std import swift2.parameteriser as sp import swift2.system as ssy In\u00a0[3]: Copied! <pre>from cinterop.timeseries import xr_ts_end, xr_ts_start\nfrom swift2.classes import CompositeParameteriser\nfrom swift2.utils import mk_full_data_id\n</pre> from cinterop.timeseries import xr_ts_end, xr_ts_start from swift2.classes import CompositeParameteriser from swift2.utils import mk_full_data_id In\u00a0[4]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[5]: Copied! <pre>model_id = 'GR4J'\nsimul_start=pd.Timestamp('1990-11-01')\nsimul_end=pd.Timestamp('1992-12-31')\nms = std.create_subarea_simulation(data_id='MMH', simul_start=simul_start, simul_end=simul_end, \n\tmodel_id=model_id, tstep='daily', varname_rain='P', varname_pet='E')\n</pre> model_id = 'GR4J' simul_start=pd.Timestamp('1990-11-01') simul_end=pd.Timestamp('1992-12-31') ms = std.create_subarea_simulation(data_id='MMH', simul_start=simul_start, simul_end=simul_end,  \tmodel_id=model_id, tstep='daily', varname_rain='P', varname_pet='E') <p>We define a few model state identifiers, and set them to be recorded to time series.</p> In\u00a0[6]: Copied! <pre>gr4jModelVars = ssy.runoff_model_var_ids(model_id)\nprint(gr4jModelVars)\n</pre> gr4jModelVars = ssy.runoff_model_var_ids(model_id) print(gr4jModelVars) <pre>['P', 'E', 'En', 'LAI', 'runoff', 'S', 'R', 'TWS', 'Eactual', 'Ps', 'Es', 'Pr', 'ech1', 'ech2', 'Perc', 'alpha', 'k', 'x1', 'x2', 'x3', 'x4', 'UHExponent', 'PercFactor']\n</pre> In\u00a0[7]: Copied! <pre>element_id = 'subarea.Subarea'\ndef mk_varid(short_id):\n    return mk_full_data_id(element_id, short_id)\n\nrunoff_id = mk_varid('runoff')\ns_store_id = mk_varid('S')\nr_store_id = mk_varid('R')\nms.record_state([runoff_id, s_store_id, r_store_id])\n</pre> element_id = 'subarea.Subarea' def mk_varid(short_id):     return mk_full_data_id(element_id, short_id)  runoff_id = mk_varid('runoff') s_store_id = mk_varid('S') r_store_id = mk_varid('R') ms.record_state([runoff_id, s_store_id, r_store_id]) <p>We'll set up a short runtime span, so that we illustrate the state initialisation feature.</p> In\u00a0[8]: Copied! <pre>obs_runoff = std.sample_series('MMH', 'flow') #actually, this is a time series of runoff depth, not streamflow rate\nobs_runoff[obs_runoff &lt; -1] = np.nan\ns = simul_start\nw = s\n# e = s + pd.DateOffset(days=90)\ne = simul_end\nms.set_simulation_span(s, e)\n</pre> obs_runoff = std.sample_series('MMH', 'flow') #actually, this is a time series of runoff depth, not streamflow rate obs_runoff[obs_runoff &lt; -1] = np.nan s = simul_start w = s # e = s + pd.DateOffset(days=90) e = simul_end ms.set_simulation_span(s, e) <p>Let's apply some default model parameters to the model:</p> In\u00a0[9]: Copied! <pre>pspec_gr4j = std.get_free_params(model_id)\npspec_gr4j['Name'] = mk_varid(pspec_gr4j['Name'])\n# TODO : a print function for native parameterisers.\np = sp.create_parameteriser('Generic', pspec_gr4j)\np\n</pre> pspec_gr4j = std.get_free_params(model_id) pspec_gr4j['Name'] = mk_varid(pspec_gr4j['Name']) # TODO : a print function for native parameterisers. p = sp.create_parameteriser('Generic', pspec_gr4j) p Out[9]: <pre>                 Name       Value   Min     Max\n0  subarea.Subarea.x1  650.488000   1.0  3000.0\n1  subarea.Subarea.x2   -0.280648 -27.0    27.0\n2  subarea.Subarea.x3    7.891230   1.0   660.0\n3  subarea.Subarea.x4   18.917200   1.0   240.0</pre> In\u00a0[10]: Copied! <pre>p.apply_sys_config(ms)\n</pre> p.apply_sys_config(ms) <p>We get a time series of S if we run it at this point; the starting value is zero.</p> In\u00a0[11]: Copied! <pre>import matplotlib.pyplot as plt\n\nms.exec_simulation()\ntts = ms.get_recorded(s_store_id)\ntts = tts.squeeze(drop=True)\ng = tts.plot.line(add_legend=True, figsize=(16,8))\nplt.title('GR4J S store. No state initializer');\n</pre> import matplotlib.pyplot as plt  ms.exec_simulation() tts = ms.get_recorded(s_store_id) tts = tts.squeeze(drop=True) g = tts.plot.line(add_legend=True, figsize=(16,8)) plt.title('GR4J S store. No state initializer'); In\u00a0[12]: Copied! <pre>from swift2.utils import as_xarray_series\n</pre> from swift2.utils import as_xarray_series In\u00a0[13]: Copied! <pre>from swift2.vis import plot_two_series\n</pre> from swift2.vis import plot_two_series In\u00a0[14]: Copied! <pre>calc_runoff = ms.get_recorded(runoff_id).squeeze(drop=True)\nplot_two_series(obs_runoff, calc_runoff, start_time = xr_ts_start(calc_runoff), end_time = xr_ts_end(calc_runoff), names=['observed','modelled'], xlab=\"time\", ylab=\"runoff (mm)\")\n</pre> calc_runoff = ms.get_recorded(runoff_id).squeeze(drop=True) plot_two_series(obs_runoff, calc_runoff, start_time = xr_ts_start(calc_runoff), end_time = xr_ts_end(calc_runoff), names=['observed','modelled'], xlab=\"time\", ylab=\"runoff (mm)\") <p>Let's define S0 and R0 parameters such that for each GR4J model instance, S = S0 * x1 and R = R0 * x3</p> In\u00a0[15]: Copied! <pre>from swift2.utils import c\n\np_states = sp.linear_parameteriser(\n                      c(\"S0\",\"R0\"), \n                      c(\"S\",\"R\"), \n                      c(\"x1\",\"x3\"),\n                      c(0.0,0.0), \n                      c(0.6,0.6), \n                      c(0.4,0.4), \n                      'each subarea')\n</pre> from swift2.utils import c  p_states = sp.linear_parameteriser(                       c(\"S0\",\"R0\"),                        c(\"S\",\"R\"),                        c(\"x1\",\"x3\"),                       c(0.0,0.0),                        c(0.6,0.6),                        c(0.4,0.4),                        'each subarea') <p>If one applies this parameteriser pState to the system, the the S store is set to the expected value relative to x1.</p> In\u00a0[16]: Copied! <pre>p_states.apply_sys_config(ms)\nms.get_state_value(s_store_id)\n</pre> p_states.apply_sys_config(ms) ms.get_state_value(s_store_id) Out[16]: <pre>{'subarea.Subarea.S': 260.19520000000006}</pre> <p>However this is not enough to define a parameteriser as an initial state. If executing the simulation, the time series of S still starts at zero, because the resetting the model overrides the state S:</p> In\u00a0[17]: Copied! <pre>ms.exec_simulation()\ntts = ms.get_recorded(s_store_id)\ntts = tts.squeeze(drop=True)\ng = tts.plot.line(add_legend=True, figsize=(16,8))\nplt.title('GR4J S store; incomplete store initialization');\n</pre> ms.exec_simulation() tts = ms.get_recorded(s_store_id) tts = tts.squeeze(drop=True) g = tts.plot.line(add_legend=True, figsize=(16,8)) plt.title('GR4J S store; incomplete store initialization'); <p>You need to define a new parameteriser, that makes sure that the model is reset to the expected initial value.</p> In\u00a0[18]: Copied! <pre>init_parameteriser = p_states.make_state_init_parameteriser()\ninit_parameteriser.apply_sys_config(ms)\n</pre> init_parameteriser = p_states.make_state_init_parameteriser() init_parameteriser.apply_sys_config(ms) In\u00a0[19]: Copied! <pre>ms.exec_simulation()\ntts = ms.get_recorded(s_store_id)\ntts = tts.squeeze(drop=True)\ng = tts.plot.line(add_legend=True, figsize=(16,8))\nplt.title('GR4J S store, with a proper state initializer');\n</pre> ms.exec_simulation() tts = ms.get_recorded(s_store_id) tts = tts.squeeze(drop=True) g = tts.plot.line(add_legend=True, figsize=(16,8)) plt.title('GR4J S store, with a proper state initializer'); In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[20]: Copied! <pre>calc_runoff = ms.get_recorded(runoff_id).squeeze(drop=True)\nplot_two_series(obs_runoff, calc_runoff, start_time = xr_ts_start(calc_runoff), end_time = xr_ts_end(calc_runoff), names=['observed','modelled'], xlab=\"time\", ylab=\"runoff (mm)\")\n</pre> calc_runoff = ms.get_recorded(runoff_id).squeeze(drop=True) plot_two_series(obs_runoff, calc_runoff, start_time = xr_ts_start(calc_runoff), end_time = xr_ts_end(calc_runoff), names=['observed','modelled'], xlab=\"time\", ylab=\"runoff (mm)\") <p>There is logic in keeping the two previous steps in defining a parameteriser as separate, hence this present vignette emphasizes the importance of these two steps.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[21]: Copied! <pre>p_composite = CompositeParameteriser.concatenate(p, init_parameteriser)\nprint(p_composite)\n</pre> p_composite = CompositeParameteriser.concatenate(p, init_parameteriser) print(p_composite) <pre>                 Name       Value   Min     Max\n0  subarea.Subarea.x1  650.488000   1.0  3000.0\n1  subarea.Subarea.x2   -0.280648 -27.0    27.0\n2  subarea.Subarea.x3    7.891230   1.0   660.0\n3  subarea.Subarea.x4   18.917200   1.0   240.0\n4                  R0    0.400000   0.0     0.6\n5                  S0    0.400000   0.0     0.6\n</pre> In\u00a0[22]: Copied! <pre>objective = ms.create_objective(runoff_id, obs_runoff, 'NSE', w, e)\nscore = objective.get_score(p_composite)\nprint(score)\n</pre> objective = ms.create_objective(runoff_id, obs_runoff, 'NSE', w, e) score = objective.get_score(p_composite) print(score) <pre>{'scores': {'NSE': -0.03575597073595449}, 'sysconfig':                  Name       Value   Min     Max\n0  subarea.Subarea.x1  650.488000   1.0  3000.0\n1  subarea.Subarea.x2   -0.280648 -27.0    27.0\n2  subarea.Subarea.x3    7.891230   1.0   660.0\n3  subarea.Subarea.x4   18.917200   1.0   240.0\n4                  R0    0.400000   0.0     0.6\n5                  S0    0.400000   0.0     0.6}\n</pre> In\u00a0[23]: Copied! <pre>optim = objective.create_sce_optim_swift(population_initialiser=p)\n</pre> optim = objective.create_sce_optim_swift(population_initialiser=p) In\u00a0[24]: Copied! <pre>%%time\nresults = optim.execute_optimisation()\n</pre> %%time results = optim.execute_optimisation() <pre>CPU times: user 36.2 s, sys: 15.7 ms, total: 36.2 s\nWall time: 9.49 s\n</pre> In\u00a0[25]: Copied! <pre>results.get_best_score('NSE', convert_to_py=True)\n</pre> results.get_best_score('NSE', convert_to_py=True) Out[25]: <pre>{'scores': {'NSE': 0.5625971076046495},\n 'sysconfig':                  Name       Value   Min     Max\n 0  subarea.Subarea.x1  580.276219   1.0  3000.0\n 1  subarea.Subarea.x2  -13.355840 -27.0    27.0\n 2  subarea.Subarea.x3  584.391889   1.0   660.0\n 3  subarea.Subarea.x4    1.178550   1.0   240.0}</pre> In\u00a0[26]: Copied! <pre>s = results.get_best_score('NSE')\n</pre> s = results.get_best_score('NSE') In\u00a0[27]: Copied! <pre>s.apply_sys_config(ms)\nms.exec_simulation()\n</pre> s.apply_sys_config(ms) ms.exec_simulation() In\u00a0[28]: Copied! <pre>calc_runoff = ms.get_recorded(runoff_id).squeeze(drop=True)\nplot_two_series(obs_runoff, calc_runoff, start_time = xr_ts_start(calc_runoff), end_time = xr_ts_end(calc_runoff), names=['observed','modelled'], xlab=\"time\", ylab=\"runoff (mm)\")\n</pre> calc_runoff = ms.get_recorded(runoff_id).squeeze(drop=True) plot_two_series(obs_runoff, calc_runoff, start_time = xr_ts_start(calc_runoff), end_time = xr_ts_end(calc_runoff), names=['observed','modelled'], xlab=\"time\", ylab=\"runoff (mm)\") In\u00a0[29]: Copied! <pre>optim = objective.create_sce_optim_swift(population_initialiser=p_composite)\n</pre> optim = objective.create_sce_optim_swift(population_initialiser=p_composite) In\u00a0[30]: Copied! <pre>%%time\nresults = optim.execute_optimisation()\n</pre> %%time results = optim.execute_optimisation() <pre>CPU times: user 36.4 s, sys: 12.1 ms, total: 36.4 s\nWall time: 9.87 s\n</pre> In\u00a0[31]: Copied! <pre>results.get_best_score('NSE', convert_to_py=True)\n</pre> results.get_best_score('NSE', convert_to_py=True) Out[31]: <pre>{'scores': {'NSE': 0.526419566545028},\n 'sysconfig':                  Name       Value   Min     Max\n 0  subarea.Subarea.x1  354.567580   1.0  3000.0\n 1  subarea.Subarea.x2  -18.721008 -27.0    27.0\n 2  subarea.Subarea.x3  646.923623   1.0   660.0\n 3  subarea.Subarea.x4    1.709377   1.0   240.0\n 4                  R0    0.251199   0.0     0.6\n 5                  S0    0.454895   0.0     0.6}</pre> In\u00a0[32]: Copied! <pre>s = results.get_best_score('NSE')\n</pre> s = results.get_best_score('NSE') In\u00a0[33]: Copied! <pre>s.apply_sys_config(ms)\nms.exec_simulation()\n</pre> s.apply_sys_config(ms) ms.exec_simulation() In\u00a0[34]: Copied! <pre>calc_runoff = ms.get_recorded(runoff_id).squeeze(drop=True)\nplot_two_series(obs_runoff, calc_runoff, start_time = xr_ts_start(calc_runoff), end_time = xr_ts_end(calc_runoff), names=['observed','modelled'], xlab=\"time\", ylab=\"runoff (mm)\")\n</pre> calc_runoff = ms.get_recorded(runoff_id).squeeze(drop=True) plot_two_series(obs_runoff, calc_runoff, start_time = xr_ts_start(calc_runoff), end_time = xr_ts_end(calc_runoff), names=['observed','modelled'], xlab=\"time\", ylab=\"runoff (mm)\") In\u00a0[35]: Copied! <pre>obs_runoff.plot()\n</pre> obs_runoff.plot() Out[35]: <pre>&lt;Axes: &gt;</pre> In\u00a0[36]: Copied! <pre>ms.get_played_varnames()\n</pre> ms.get_played_varnames() Out[36]: <pre>['subarea.Subarea.E', 'subarea.Subarea.P']</pre> In\u00a0[37]: Copied! <pre>x = ms.get_played('subarea.Subarea.P').squeeze(drop=True).to_series()\n</pre> x = ms.get_played('subarea.Subarea.P').squeeze(drop=True).to_series() In\u00a0[38]: Copied! <pre>rainfall_mth = x.resample(\"M\").sum()\nrunoff_mth = obs_runoff[slice(x.index[0], x.index[-1])].resample(\"M\").sum()\n</pre> rainfall_mth = x.resample(\"M\").sum() runoff_mth = obs_runoff[slice(x.index[0], x.index[-1])].resample(\"M\").sum() <pre>/tmp/ipykernel_184804/2429096889.py:1: FutureWarning: 'M' is deprecated and will be removed in a future version, please use 'ME' instead.\n  rainfall_mth = x.resample(\"M\").sum()\n/tmp/ipykernel_184804/2429096889.py:2: FutureWarning: 'M' is deprecated and will be removed in a future version, please use 'ME' instead.\n  runoff_mth = obs_runoff[slice(x.index[0], x.index[-1])].resample(\"M\").sum()\n</pre> In\u00a0[39]: Copied! <pre>plot_two_series(rainfall_mth, runoff_mth)\n</pre> plot_two_series(rainfall_mth, runoff_mth) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/calibration_initial_states/#calibration-with-initial-model-memory-states-as-parameters","title":"Calibration with initial model memory states as parameters\u00b6","text":""},{"location":"notebooks/calibration_initial_states/#about-this-document","title":"About this document\u00b6","text":""},{"location":"notebooks/calibration_initial_states/#essentials-of-setting-up-a-calibration-of-initial-states","title":"Essentials of setting up a calibration of initial states\u00b6","text":"<p>This vignette will illustrate how to define two meta-parameters, S0 and R0, controlling the initial level of stores in the GR4J model, as fraction of the store capacities.</p> <p>We'll load a simple catchment with one subarea only; the feature applies equally to catchment with multiple sub-areas</p>"},{"location":"notebooks/calibration_initial_states/#calibration","title":"Calibration\u00b6","text":"<p>Once you have defined this state initialisation parameteriser using <code>{r eval=FALSE} makeStateInitParameterizer</code>, you can define a calibration objective the usual way. This vignette does not include calibration steps; please refer to other vignettes.</p>"},{"location":"notebooks/ensemble_model_runs/","title":"Ensemble SWIFT model runs","text":"In\u00a0[1]: Copied! <pre>from swift2.doc_helper import pkg_versions_info\n\nprint(pkg_versions_info(\"This document was generated from a jupyter notebook\"))\n</pre> from swift2.doc_helper import pkg_versions_info  print(pkg_versions_info(\"This document was generated from a jupyter notebook\")) <pre>This document was generated from a jupyter notebook on 2025-05-16 14:16:24.081190\n    swift2 2.5.1\n    uchronia 2.6.2\n</pre> In\u00a0[2]: Copied! <pre>import os\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nimport swift2.doc_helper as std\nimport swift2.parameteriser as sp\nimport swift2.play_record as spr\nimport uchronia.sample_data as usd\nimport xarray as xr\n\nfrom swift2.const import CATCHMENT_FLOWRATE_VARID\nfrom swift2.simulation import get_subarea_ids\nfrom swift2.utils import mk_full_data_id, paste0\nfrom uchronia.data_set import datasets_summaries, get_dataset_ids\n</pre> import os  import matplotlib.pyplot as plt import numpy as np import pandas as pd  import swift2.doc_helper as std import swift2.parameteriser as sp import swift2.play_record as spr import uchronia.sample_data as usd import xarray as xr  from swift2.const import CATCHMENT_FLOWRATE_VARID from swift2.simulation import get_subarea_ids from swift2.utils import mk_full_data_id, paste0 from uchronia.data_set import datasets_summaries, get_dataset_ids In\u00a0[3]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[4]: Copied! <pre>runoff_model='GR4J'\n</pre> runoff_model='GR4J' In\u00a0[5]: Copied! <pre>node_ids=paste0('n', [i+1 for i in range(6)])\nlink_ids = paste0('lnk', [i+1 for i in range(5)])\nnode_names = paste0(node_ids, '_name')\nlink_names = paste0(link_ids, '_name')\nfrom_node = paste0('n', [2,5,4,3,1])\nto_node = paste0('n', [6,2,2,4,4])\nareas_km2 = np.array([1.2, 2.3, 4.4, 2.2, 1.5])\n</pre> node_ids=paste0('n', [i+1 for i in range(6)]) link_ids = paste0('lnk', [i+1 for i in range(5)]) node_names = paste0(node_ids, '_name') link_names = paste0(link_ids, '_name') from_node = paste0('n', [2,5,4,3,1]) to_node = paste0('n', [6,2,2,4,4]) areas_km2 = np.array([1.2, 2.3, 4.4, 2.2, 1.5]) In\u00a0[6]: Copied! <pre>simulation = std.create_catchment(node_ids, node_names, link_ids, link_names, from_node, to_node, runoff_model, areas_km2)\n</pre> simulation = std.create_catchment(node_ids, node_names, link_ids, link_names, from_node, to_node, runoff_model, areas_km2) In\u00a0[7]: Copied! <pre>simulation.describe()\n</pre> simulation.describe() Out[7]: <pre>{'subareas': {'lnk1': 'lnk1_name',\n  'lnk2': 'lnk2_name',\n  'lnk3': 'lnk3_name',\n  'lnk4': 'lnk4_name',\n  'lnk5': 'lnk5_name'},\n 'nodes': {'n1': 'n1_name',\n  'n2': 'n2_name',\n  'n3': 'n3_name',\n  'n4': 'n4_name',\n  'n5': 'n5_name',\n  'n6': 'n6_name'},\n 'links': {'lnk1': 'lnk1_name',\n  'lnk2': 'lnk2_name',\n  'lnk3': 'lnk3_name',\n  'lnk4': 'lnk4_name',\n  'lnk5': 'lnk5_name'}}</pre> In\u00a0[8]: Copied! <pre>if not 'SWIFT_TEST_DIR' in os.environ:\n    os.environ['SWIFT_TEST_DIR'] = os.path.expanduser('~/data/documentation') \n</pre> if not 'SWIFT_TEST_DIR' in os.environ:     os.environ['SWIFT_TEST_DIR'] = os.path.expanduser('~/data/documentation')  In\u00a0[9]: Copied! <pre>doc_data_path = usd.sample_data_dir()\ndata_path = os.path.join(doc_data_path, 'UpperMurray')\n</pre> doc_data_path = usd.sample_data_dir() data_path = os.path.join(doc_data_path, 'UpperMurray') In\u00a0[10]: Copied! <pre>data_library = usd.sample_time_series_library('upper murray')\n</pre> data_library = usd.sample_time_series_library('upper murray') In\u00a0[11]: Copied! <pre>data_library\n</pre> data_library Out[11]: <pre>CFFI pointer handle to a native pointer of type id \"ENSEMBLE_DATA_SET_PTR\"</pre> In\u00a0[12]: Copied! <pre>data_ids = data_library.get_dataset_ids()\ndata_ids\n</pre> data_ids = data_library.get_dataset_ids() data_ids Out[12]: <pre>['pet_fcast_ens', 'pet_obs', 'rain_obs', 'rain_fcast_ens']</pre> In\u00a0[13]: Copied! <pre>data_library.datasets_summaries()\n</pre> data_library.datasets_summaries() Out[13]: <pre>{'pet_fcast_ens': 'variable name: pet_der, identifier: 1, start: 1989-12-31T00:00:00, end: 2012-12-30T00:00:00, time length: 8401, time step: daily',\n 'pet_obs': 'variable name: pet_der, identifier: 1, start: 1988-12-31T00:00:00, end: 2012-12-30T00:00:00, time length: 8766, time step: daily',\n 'rain_obs': 'variable name: rain_der, identifier: 1, start: 1989-12-31T13:00:00, end: 2012-10-31T12:00:00, time length: 200160, time step: hourly',\n 'rain_fcast_ens': 'variable name: rain_fcast_ens, identifier: 1, index: 0, start: 2010-08-01T21:00:00, end: 2010-08-06T21:00:00, time length: 5, time step: &lt;not yet supported&gt;'}</pre> <p>The sample catchment structure is obviously not the real \"Upper Murray\". For the sake of a didactic example, let's set the same inputs across all the subareas.</p> In\u00a0[14]: Copied! <pre>rain_obs = data_library.get_dataset('rain_obs').to_xarray()\n</pre> rain_obs = data_library.get_dataset('rain_obs').to_xarray() In\u00a0[15]: Copied! <pre>print(rain_obs)\n</pre> print(rain_obs) <pre>&lt;xarray.DataArray (ensemble: 1, time: 200160)&gt; Size: 2MB\narray([[-9999., -9999., -9999., ..., -9999., -9999., -9999.]],\n      shape=(1, 200160))\nCoordinates:\n  * ensemble  (ensemble) int64 8B 0\n  * time      (time) datetime64[ns] 2MB 1989-12-31T14:00:00 ... 2012-10-31T13...\n</pre> In\u00a0[16]: Copied! <pre>rain_obs = rain_obs.where(rain_obs &gt;= 0)\n</pre> rain_obs = rain_obs.where(rain_obs &gt;= 0) In\u00a0[17]: Copied! <pre>rain_obs.time[:-10].values\n</pre> rain_obs.time[:-10].values Out[17]: <pre>array(['1989-12-31T14:00:00.000000000', '1989-12-31T15:00:00.000000000',\n       '1989-12-31T16:00:00.000000000', ...,\n       '2012-10-31T01:00:00.000000000', '2012-10-31T02:00:00.000000000',\n       '2012-10-31T03:00:00.000000000'],\n      shape=(200150,), dtype='datetime64[ns]')</pre> <p>Note that the rainfall is hourly, but the pet is daily. This will matter later for the simulation</p> In\u00a0[18]: Copied! <pre>pet_obs = data_library.get_dataset('pet_obs').to_xarray()\npet_obs.time[:-10]\n</pre> pet_obs = data_library.get_dataset('pet_obs').to_xarray() pet_obs.time[:-10] Out[18]: <pre>&lt;xarray.DataArray 'time' (time: 8756)&gt; Size: 70kB\narray(['1989-01-01T00:00:00.000000000', '1989-01-02T00:00:00.000000000',\n       '1989-01-03T00:00:00.000000000', ..., '2012-12-19T00:00:00.000000000',\n       '2012-12-20T00:00:00.000000000', '2012-12-21T00:00:00.000000000'],\n      shape=(8756,), dtype='datetime64[ns]')\nCoordinates:\n  * time     (time) datetime64[ns] 70kB 1989-01-01 1989-01-02 ... 2012-12-21</pre>xarray.DataArray'time'<ul><li>time: 8756</li></ul><ul><li>1989-01-01 1989-01-02 1989-01-03 ... 2012-12-19 2012-12-20 2012-12-21<pre>array(['1989-01-01T00:00:00.000000000', '1989-01-02T00:00:00.000000000',\n       '1989-01-03T00:00:00.000000000', ..., '2012-12-19T00:00:00.000000000',\n       '2012-12-20T00:00:00.000000000', '2012-12-21T00:00:00.000000000'],\n      shape=(8756,), dtype='datetime64[ns]')</pre></li><li>Coordinates: (1)<ul><li>time(time)datetime64[ns]1989-01-01 ... 2012-12-21<pre>array(['1989-01-01T00:00:00.000000000', '1989-01-02T00:00:00.000000000',\n       '1989-01-03T00:00:00.000000000', ..., '2012-12-19T00:00:00.000000000',\n       '2012-12-20T00:00:00.000000000', '2012-12-21T00:00:00.000000000'],\n      shape=(8756,), dtype='datetime64[ns]')</pre></li></ul></li><li>Indexes: (1)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['1989-01-01', '1989-01-02', '1989-01-03', '1989-01-04',\n               '1989-01-05', '1989-01-06', '1989-01-07', '1989-01-08',\n               '1989-01-09', '1989-01-10',\n               ...\n               '2012-12-12', '2012-12-13', '2012-12-14', '2012-12-15',\n               '2012-12-16', '2012-12-17', '2012-12-18', '2012-12-19',\n               '2012-12-20', '2012-12-21'],\n              dtype='datetime64[ns]', name='time', length=8756, freq='D'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[19]: Copied! <pre>simulation.play_inputs?\n</pre> simulation.play_inputs? <p><code>play_inputs</code> can accept vectorised arguments, which is handy for cases like the following:</p> <p>For each precipitation model input, use the same time series 'rain_obs' from the data library.</p> In\u00a0[20]: Copied! <pre>precip_ids = mk_full_data_id( 'subarea', get_subarea_ids(simulation), 'P')\nevapIds = mk_full_data_id( 'subarea', get_subarea_ids(simulation), 'E')\nprecip_ids, evapIds\n</pre> precip_ids = mk_full_data_id( 'subarea', get_subarea_ids(simulation), 'P') evapIds = mk_full_data_id( 'subarea', get_subarea_ids(simulation), 'E') precip_ids, evapIds Out[20]: <pre>(['subarea.lnk1.P',\n  'subarea.lnk2.P',\n  'subarea.lnk3.P',\n  'subarea.lnk4.P',\n  'subarea.lnk5.P'],\n ['subarea.lnk1.E',\n  'subarea.lnk2.E',\n  'subarea.lnk3.E',\n  'subarea.lnk4.E',\n  'subarea.lnk5.E'])</pre> In\u00a0[21]: Copied! <pre>def _rep(x): return np.repeat(x, len(precip_ids))\nsimulation.play_inputs(data_library, precip_ids, _rep('rain_obs'), _rep(''))\n</pre> def _rep(x): return np.repeat(x, len(precip_ids)) simulation.play_inputs(data_library, precip_ids, _rep('rain_obs'), _rep('')) <p>We noted that the pet_obs is a daily series, not hourly as per . <code>swift2</code> can disaggregate on the fly, using the 'daily_to_hourly' method when assigning inputs to the simulation. This saves a lot of tedium!</p> In\u00a0[22]: Copied! <pre>simulation.play_inputs(data_library, evapIds, _rep('pet_obs'), _rep('daily_to_hourly'))\n# And the flow rate we will record\noutflow_id = CATCHMENT_FLOWRATE_VARID\n</pre> simulation.play_inputs(data_library, evapIds, _rep('pet_obs'), _rep('daily_to_hourly')) # And the flow rate we will record outflow_id = CATCHMENT_FLOWRATE_VARID <p>Given the information from the input data, let's define a suitable simulation time span. We have define an ensemble simulation where we will do a warmup simulation on a single input (no \"ensemble\") for 3 years or so, then five days of an ensemble simulation.</p> In\u00a0[23]: Copied! <pre>from cinterop.timeseries import as_timestamp\n \ns = as_timestamp('2007-01-01')\ne = as_timestamp('2010-08-01 20')\ns_hot = as_timestamp('2010-08-01 21')\ne_hot = as_timestamp('2010-08-05 21')\n</pre> from cinterop.timeseries import as_timestamp   s = as_timestamp('2007-01-01') e = as_timestamp('2010-08-01 20') s_hot = as_timestamp('2010-08-01 21') e_hot = as_timestamp('2010-08-05 21') In\u00a0[24]: Copied! <pre>simulation.set_simulation_span(start=s, end=e_hot)\nsimulation.record_state(outflow_id)\nsimulation.exec_simulation()\nbaseline = simulation.get_recorded(outflow_id)\n</pre> simulation.set_simulation_span(start=s, end=e_hot) simulation.record_state(outflow_id) simulation.exec_simulation() baseline = simulation.get_recorded(outflow_id) In\u00a0[25]: Copied! <pre>baseline = baseline.squeeze(drop=True).sel(time = slice(s_hot, e_hot))\n</pre> baseline = baseline.squeeze(drop=True).sel(time = slice(s_hot, e_hot)) In\u00a0[26]: Copied! <pre>baseline.plot(figsize=(10,5))\nplt.title(\"streamflow with long term simulation, slice to the end of the series\")\n</pre> baseline.plot(figsize=(10,5)) plt.title(\"streamflow with long term simulation, slice to the end of the series\") Out[26]: <pre>Text(0.5, 1.0, 'streamflow with long term simulation, slice to the end of the series')</pre> In\u00a0[27]: Copied! <pre>simulation.set_simulation_span(start=s, end=e)\nsimulation.exec_simulation()\nsnapshot = simulation.snapshot_state()\n</pre> simulation.set_simulation_span(start=s, end=e) simulation.exec_simulation() snapshot = simulation.snapshot_state() <p>We can execute a simulation over the new time span, but requesting model states to NOT be reset. If we compare with a simulation where, as per default, the states are reset before the first time step, we notice a difference:</p> In\u00a0[28]: Copied! <pre>simulation.set_simulation_span(start=s_hot, end=e_hot)\nsimulation.exec_simulation(reset_initial_states = False)\nnoReset = simulation.get_recorded(outflow_id)\nsimulation.exec_simulation(reset_initial_states = True)\nwithReset = simulation.get_recorded(outflow_id)\n</pre> simulation.set_simulation_span(start=s_hot, end=e_hot) simulation.exec_simulation(reset_initial_states = False) noReset = simulation.get_recorded(outflow_id) simulation.exec_simulation(reset_initial_states = True) withReset = simulation.get_recorded(outflow_id) In\u00a0[29]: Copied! <pre>noReset = noReset.squeeze(drop=True)\n\nx = xr.concat([noReset,withReset], dim=pd.Index(['no reset','reset'], name='scenario')).squeeze(drop=True)\n</pre> noReset = noReset.squeeze(drop=True)  x = xr.concat([noReset,withReset], dim=pd.Index(['no reset','reset'], name='scenario')).squeeze(drop=True) In\u00a0[30]: Copied! <pre>fig, ax = plt.subplots(figsize=(10,5))\nax.plot(x.time.values, x.sel(scenario='no reset'), linewidth=2, label='No reset')\nax.plot(x.time.values, x.sel(scenario='reset'), linewidth=2, label='Reset')\nax.legend()\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(10,5)) ax.plot(x.time.values, x.sel(scenario='no reset'), linewidth=2, label='No reset') ax.plot(x.time.values, x.sel(scenario='reset'), linewidth=2, label='Reset') ax.legend() plt.show() <p>The simulation hot-started and run with no reset is like the previous long simulation baseline. If we reset the states to zero, we even have ho streamflow yet produced over these 5 days...</p> <p>Now let'd ready the simulation to do ensemble forecasts. We define a list <code>inputMap</code> such that keys are the names of ensemble forecast time series found in <code>data_library</code> and the values is one or more of the model properties found in the simulation. In this instance we use the same series for all model precipitation inputs in <code>precip_ids</code></p> In\u00a0[31]: Copied! <pre>simulation.reset_model_states()\nsimulation.set_states(snapshot)\n</pre> simulation.reset_model_states() simulation.set_states(snapshot) In\u00a0[32]: Copied! <pre>inputMap = {'rain_fcast_ens':precip_ids}\n</pre> inputMap = {'rain_fcast_ens':precip_ids} In\u00a0[33]: Copied! <pre>ems = simulation.create_ensemble_forecast_simulation(\n    data_library, \n    start=s_hot, \n    end=e_hot, \n    input_map=inputMap, \n    lead_time=(24*2+23), \n    ensemble_size=100, \n    n_time_steps_between_forecasts=24)\n</pre> ems = simulation.create_ensemble_forecast_simulation(     data_library,      start=s_hot,      end=e_hot,      input_map=inputMap,      lead_time=(24*2+23),      ensemble_size=100,      n_time_steps_between_forecasts=24) In\u00a0[34]: Copied! <pre>ems\n</pre> ems Out[34]: <pre>CFFI pointer handle to a native pointer of type id \"ENSEMBLE_FORECAST_SIMULATION_PTR\"</pre> <p><code>ems</code> is an ensemble forecast simulation object, which is an augmentation of the <code>Simulation</code> object that deals with non-ensemble simulation. It is very important to note that whenever possible, the object methods are named identically, just that the time series in and out of the simulations are of higher dimension.</p> In\u00a0[35]: Copied! <pre>ems.get_simulation_span()\n</pre> ems.get_simulation_span() Out[35]: <pre>{'start': datetime.datetime(2010, 8, 1, 21, 0),\n 'end': datetime.datetime(2010, 8, 4, 21, 0),\n 'time step': 'hourly'}</pre> In\u00a0[36]: Copied! <pre>ems.record_state(outflow_id)\nems.exec_simulation()\nforecasts = ems.get_recorded_ensemble_forecast(outflow_id)\n</pre> ems.record_state(outflow_id) ems.exec_simulation() forecasts = ems.get_recorded_ensemble_forecast(outflow_id) In\u00a0[37]: Copied! <pre>type(forecasts)\n</pre> type(forecasts) Out[37]: <pre>uchronia.classes.EnsembleForecastTimeSeries</pre> <p>We have four forecast issue times:</p> In\u00a0[38]: Copied! <pre>forecasts.time_index()\n</pre> forecasts.time_index() Out[38]: <pre>DatetimeIndex(['2010-08-01 21:00:00', '2010-08-02 21:00:00',\n               '2010-08-03 21:00:00', '2010-08-04 21:00:00'],\n              dtype='datetime64[ns]', freq='D')</pre> <p>We can retrieve the first forecast issues at '2010-08-01 21:00:00' by indexing</p> In\u00a0[39]: Copied! <pre>flow_forecasts = forecasts[0]\n</pre> flow_forecasts = forecasts[0] In\u00a0[40]: Copied! <pre>flow_forecasts\n</pre> flow_forecasts Out[40]: <pre>&lt;xarray.DataArray (ensemble: 100, time: 71)&gt; Size: 57kB\narray([[0.8898914 , 0.97225084, 1.05916427, ..., 0.76254716, 0.6787237 ,\n        0.6702664 ],\n       [0.63547795, 0.62744525, 0.61985413, ..., 0.47899561, 0.48934704,\n        0.49825249],\n       [0.62397353, 0.61255692, 0.60179053, ..., 0.41359509, 0.4271383 ,\n        0.43487164],\n       ...,\n       [0.61988133, 0.6072754 , 0.59540094, ..., 0.48367713, 0.47991112,\n        0.47624805],\n       [0.61967395, 0.60698496, 0.59505003, ..., 0.46636062, 0.46183589,\n        0.45746333],\n       [0.61967228, 0.60698117, 0.59504373, ..., 0.34924574, 0.34735597,\n        0.34549876]], shape=(100, 71))\nCoordinates:\n  * ensemble  (ensemble) int64 800B 0 1 2 3 4 5 6 7 ... 92 93 94 95 96 97 98 99\n  * time      (time) datetime64[ns] 568B 2010-08-01T22:00:00 ... 2010-08-04T2...</pre>xarray.DataArray<ul><li>ensemble: 100</li><li>time: 71</li></ul><ul><li>0.8899 0.9723 1.059 1.522 1.817 ... 0.3531 0.3512 0.3492 0.3474 0.3455<pre>array([[0.8898914 , 0.97225084, 1.05916427, ..., 0.76254716, 0.6787237 ,\n        0.6702664 ],\n       [0.63547795, 0.62744525, 0.61985413, ..., 0.47899561, 0.48934704,\n        0.49825249],\n       [0.62397353, 0.61255692, 0.60179053, ..., 0.41359509, 0.4271383 ,\n        0.43487164],\n       ...,\n       [0.61988133, 0.6072754 , 0.59540094, ..., 0.48367713, 0.47991112,\n        0.47624805],\n       [0.61967395, 0.60698496, 0.59505003, ..., 0.46636062, 0.46183589,\n        0.45746333],\n       [0.61967228, 0.60698117, 0.59504373, ..., 0.34924574, 0.34735597,\n        0.34549876]], shape=(100, 71))</pre></li><li>Coordinates: (2)<ul><li>ensemble(ensemble)int640 1 2 3 4 5 6 ... 94 95 96 97 98 99<pre>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,\n       36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\n       54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,\n       72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n       90, 91, 92, 93, 94, 95, 96, 97, 98, 99])</pre></li><li>time(time)datetime64[ns]2010-08-01T22:00:00 ... 2010-08-...<pre>array(['2010-08-01T22:00:00.000000000', '2010-08-01T23:00:00.000000000',\n       '2010-08-02T00:00:00.000000000', '2010-08-02T01:00:00.000000000',\n       '2010-08-02T02:00:00.000000000', '2010-08-02T03:00:00.000000000',\n       '2010-08-02T04:00:00.000000000', '2010-08-02T05:00:00.000000000',\n       '2010-08-02T06:00:00.000000000', '2010-08-02T07:00:00.000000000',\n       '2010-08-02T08:00:00.000000000', '2010-08-02T09:00:00.000000000',\n       '2010-08-02T10:00:00.000000000', '2010-08-02T11:00:00.000000000',\n       '2010-08-02T12:00:00.000000000', '2010-08-02T13:00:00.000000000',\n       '2010-08-02T14:00:00.000000000', '2010-08-02T15:00:00.000000000',\n       '2010-08-02T16:00:00.000000000', '2010-08-02T17:00:00.000000000',\n       '2010-08-02T18:00:00.000000000', '2010-08-02T19:00:00.000000000',\n       '2010-08-02T20:00:00.000000000', '2010-08-02T21:00:00.000000000',\n       '2010-08-02T22:00:00.000000000', '2010-08-02T23:00:00.000000000',\n       '2010-08-03T00:00:00.000000000', '2010-08-03T01:00:00.000000000',\n       '2010-08-03T02:00:00.000000000', '2010-08-03T03:00:00.000000000',\n       '2010-08-03T04:00:00.000000000', '2010-08-03T05:00:00.000000000',\n       '2010-08-03T06:00:00.000000000', '2010-08-03T07:00:00.000000000',\n       '2010-08-03T08:00:00.000000000', '2010-08-03T09:00:00.000000000',\n       '2010-08-03T10:00:00.000000000', '2010-08-03T11:00:00.000000000',\n       '2010-08-03T12:00:00.000000000', '2010-08-03T13:00:00.000000000',\n       '2010-08-03T14:00:00.000000000', '2010-08-03T15:00:00.000000000',\n       '2010-08-03T16:00:00.000000000', '2010-08-03T17:00:00.000000000',\n       '2010-08-03T18:00:00.000000000', '2010-08-03T19:00:00.000000000',\n       '2010-08-03T20:00:00.000000000', '2010-08-03T21:00:00.000000000',\n       '2010-08-03T22:00:00.000000000', '2010-08-03T23:00:00.000000000',\n       '2010-08-04T00:00:00.000000000', '2010-08-04T01:00:00.000000000',\n       '2010-08-04T02:00:00.000000000', '2010-08-04T03:00:00.000000000',\n       '2010-08-04T04:00:00.000000000', '2010-08-04T05:00:00.000000000',\n       '2010-08-04T06:00:00.000000000', '2010-08-04T07:00:00.000000000',\n       '2010-08-04T08:00:00.000000000', '2010-08-04T09:00:00.000000000',\n       '2010-08-04T10:00:00.000000000', '2010-08-04T11:00:00.000000000',\n       '2010-08-04T12:00:00.000000000', '2010-08-04T13:00:00.000000000',\n       '2010-08-04T14:00:00.000000000', '2010-08-04T15:00:00.000000000',\n       '2010-08-04T16:00:00.000000000', '2010-08-04T17:00:00.000000000',\n       '2010-08-04T18:00:00.000000000', '2010-08-04T19:00:00.000000000',\n       '2010-08-04T20:00:00.000000000'], dtype='datetime64[ns]')</pre></li></ul></li><li>Indexes: (2)<ul><li>ensemblePandasIndex<pre>PandasIndex(Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,\n       36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\n       54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,\n       72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n       90, 91, 92, 93, 94, 95, 96, 97, 98, 99],\n      dtype='int64', name='ensemble'))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2010-08-01 22:00:00', '2010-08-01 23:00:00',\n               '2010-08-02 00:00:00', '2010-08-02 01:00:00',\n               '2010-08-02 02:00:00', '2010-08-02 03:00:00',\n               '2010-08-02 04:00:00', '2010-08-02 05:00:00',\n               '2010-08-02 06:00:00', '2010-08-02 07:00:00',\n               '2010-08-02 08:00:00', '2010-08-02 09:00:00',\n               '2010-08-02 10:00:00', '2010-08-02 11:00:00',\n               '2010-08-02 12:00:00', '2010-08-02 13:00:00',\n               '2010-08-02 14:00:00', '2010-08-02 15:00:00',\n               '2010-08-02 16:00:00', '2010-08-02 17:00:00',\n               '2010-08-02 18:00:00', '2010-08-02 19:00:00',\n               '2010-08-02 20:00:00', '2010-08-02 21:00:00',\n               '2010-08-02 22:00:00', '2010-08-02 23:00:00',\n               '2010-08-03 00:00:00', '2010-08-03 01:00:00',\n               '2010-08-03 02:00:00', '2010-08-03 03:00:00',\n               '2010-08-03 04:00:00', '2010-08-03 05:00:00',\n               '2010-08-03 06:00:00', '2010-08-03 07:00:00',\n               '2010-08-03 08:00:00', '2010-08-03 09:00:00',\n               '2010-08-03 10:00:00', '2010-08-03 11:00:00',\n               '2010-08-03 12:00:00', '2010-08-03 13:00:00',\n               '2010-08-03 14:00:00', '2010-08-03 15:00:00',\n               '2010-08-03 16:00:00', '2010-08-03 17:00:00',\n               '2010-08-03 18:00:00', '2010-08-03 19:00:00',\n               '2010-08-03 20:00:00', '2010-08-03 21:00:00',\n               '2010-08-03 22:00:00', '2010-08-03 23:00:00',\n               '2010-08-04 00:00:00', '2010-08-04 01:00:00',\n               '2010-08-04 02:00:00', '2010-08-04 03:00:00',\n               '2010-08-04 04:00:00', '2010-08-04 05:00:00',\n               '2010-08-04 06:00:00', '2010-08-04 07:00:00',\n               '2010-08-04 08:00:00', '2010-08-04 09:00:00',\n               '2010-08-04 10:00:00', '2010-08-04 11:00:00',\n               '2010-08-04 12:00:00', '2010-08-04 13:00:00',\n               '2010-08-04 14:00:00', '2010-08-04 15:00:00',\n               '2010-08-04 16:00:00', '2010-08-04 17:00:00',\n               '2010-08-04 18:00:00', '2010-08-04 19:00:00',\n               '2010-08-04 20:00:00'],\n              dtype='datetime64[ns]', name='time', freq='h'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[41]: Copied! <pre>def plot_ensemble_forecast(flow_forecasts, issue_date):\n    q = flow_forecasts.quantile([0.05, .25, .5, .75, 0.95], 'ensemble')\n    fig, ax = plt.subplots(figsize=(10,5))\n    ax.fill_between(q.time.values, q.sel(quantile=0.05), q.sel(quantile=0.95), alpha=0.3, label='Perc. 50-95')\n    ax.fill_between(q.time.values, q.sel(quantile=0.25), q.sel(quantile=.75), alpha=0.5, label='Perc. 25-75')\n    ax._get_lines.get_next_color()  # Hack to get different line\n    ax.plot(q.time.values, q.sel(quantile=.5), linewidth=2, label='Median')\n    ax.legend()\n    dd = pd.Timestamp(issue_date).strftime('%Y-%m-%dT%H')\n    plt.title(f\"Ensemble forecast streamflow {dd}\")\n    plt.ylabel(\"Streamflow (m3/s)\")\n    plt.show()\n</pre> def plot_ensemble_forecast(flow_forecasts, issue_date):     q = flow_forecasts.quantile([0.05, .25, .5, .75, 0.95], 'ensemble')     fig, ax = plt.subplots(figsize=(10,5))     ax.fill_between(q.time.values, q.sel(quantile=0.05), q.sel(quantile=0.95), alpha=0.3, label='Perc. 50-95')     ax.fill_between(q.time.values, q.sel(quantile=0.25), q.sel(quantile=.75), alpha=0.5, label='Perc. 25-75')     ax._get_lines.get_next_color()  # Hack to get different line     ax.plot(q.time.values, q.sel(quantile=.5), linewidth=2, label='Median')     ax.legend()     dd = pd.Timestamp(issue_date).strftime('%Y-%m-%dT%H')     plt.title(f\"Ensemble forecast streamflow {dd}\")     plt.ylabel(\"Streamflow (m3/s)\")     plt.show() In\u00a0[42]: Copied! <pre>issue_dates = forecasts.time_index().values\n</pre> issue_dates = forecasts.time_index().values In\u00a0[43]: Copied! <pre>plot_ensemble_forecast(forecasts[0], issue_dates[0])\n</pre> plot_ensemble_forecast(forecasts[0], issue_dates[0]) In\u00a0[44]: Copied! <pre>plot_ensemble_forecast(forecasts[1], issue_dates[1])\n</pre> plot_ensemble_forecast(forecasts[1], issue_dates[1]) In\u00a0[45]: Copied! <pre>plot_ensemble_forecast(forecasts[2], issue_dates[2])\n</pre> plot_ensemble_forecast(forecasts[2], issue_dates[2]) In\u00a0[46]: Copied! <pre>plot_ensemble_forecast(forecasts[3], issue_dates[3])\n</pre> plot_ensemble_forecast(forecasts[3], issue_dates[3]) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/ensemble_model_runs/#ensemble-swift-model-runs","title":"Ensemble SWIFT model runs\u00b6","text":""},{"location":"notebooks/ensemble_model_runs/#about-this-document","title":"About this document\u00b6","text":""},{"location":"notebooks/ensemble_model_runs/#imports","title":"Imports\u00b6","text":""},{"location":"notebooks/ensemble_model_runs/#synthetic-catchment","title":"Synthetic catchment\u00b6","text":"<p>Let's create a test catchment with a few subareas. Since we will work in a simulation mode, not calibration, we can afford a fairly arbitrary structure.</p> <p>A catchment structure can be captured with a set of items about subareas, links and nodes, and the connectivity of links and nodes</p>"},{"location":"notebooks/ensemble_model_runs/#input-data-management","title":"Input data management\u00b6","text":"<p>Working with ensemble time series is complicated.</p> <p>The package <code>uchronia</code> includes facilities to access time series from a \"library\", akin to what you would do to manage books. This hides a lot of the lower level code for reading and writing file. To an extent, the python package <code>xarray</code> overlaps with the features of these <code>uchronia</code> data libraries, but do not fully supersede them.</p> <p>Let's load a predefined data library with data for the Upper Murray river.</p>"},{"location":"notebooks/ensemble_model_runs/#setting-simulation-inputs-by-reading-from-a-data-library","title":"Setting simulation inputs by reading from a data library\u00b6","text":"<p>swift simulations have a <code>play_inputs</code> (with an s) method designed to retrieve inputs from a library.</p>"},{"location":"notebooks/ensemble_model_runs/#warmup-the-simulation-to-get-hot-states","title":"Warmup the simulation to get 'hot' states\u00b6","text":"<p>First, before demonstrating ensemble forecasting simulations, let's demonstrate how we can get a snapshot of the model states at a point in time and restore it later on, hot-starting further simulation.</p> <p>We deliberately get into details here to illustrate how to capture states, and run simulation without or without state reset.</p>"},{"location":"notebooks/ensemble_model_runs/#ensemble-forecasts","title":"Ensemble forecasts\u00b6","text":""},{"location":"notebooks/ensemble_model_runs/#visualisation","title":"Visualisation\u00b6","text":"<p>Let's visualise each of these successive ensemble forecasts. We define a function to determine and visualise the quantiles:</p>"},{"location":"notebooks/ensemble_model_runs/#appendix","title":"Appendix\u00b6","text":""},{"location":"notebooks/ensemble_model_runs/#data-library-sample-definition","title":"Data library sample definition\u00b6","text":"<p>The sample data library used in this vignette is defined by a YAML file defining where time series (or ensemble time series) are on disk in netcdf files. Note that one series can be in several netCDF files, and conversely it is possible to define multiple series (e.g. per station) in one file.</p> <pre>pet_fcast_ens:\n  Type: single\n  Id: pet_fcast_ens\n  Storage:\n    Type: single_nc_file\n    File: ./Fct_Data/Upper_Murray_pet_clim_1990_2010.nc\n    Identifier: 1\n    Var: pet_der\npet_obs:\n  Type: single\n  Id: pet_obs\n  Storage:\n    Type: single_nc_file\n    File: ./Obs_data/Upper_Murray_pet_24h_89_2012.nc\n    Identifier: 1\n    Var: pet_der\nrain_obs:\n  Type: single\n  Id: rain_obs\n  Storage:\n    Type: single_nc_file\n    File: ./Obs_data/Upper_Murray_rain_1hr.nc\n    Identifier: 1\n    Var: rain_der\nrain_fcast_ens:\n  Type: ts_ensemble_ts\n  Id: rain_fcast_ens\n  # The following 6 values are placeholders - may not yet be used by time series library\n  TimeStep: 24:00:00\n  Start: 2010-08-01T21:00:00\n  Length: 5\n  EnsembleSize: 1000\n  EnsembleLength: 240\n  EnsembleTimeStep: 01:00:00\n  Storage:\n    Type: multiple_nc_files_filename_date_pattern\n    File: ./Fct_Data/Upper_Murray_F1_1_{0}21_shuffle.nc\n    Var: rain_fcast_ens\n    Identifier: 1\n    Index: 0\n</pre>"},{"location":"notebooks/error_correction_four_stages/","title":"Error correction models - ERRIS","text":"In\u00a0[1]: Copied! <pre>from swift2.doc_helper import pkg_versions_info\n\nprint(pkg_versions_info(\"This document was generated from a jupyter notebook\"))\n</pre> from swift2.doc_helper import pkg_versions_info  print(pkg_versions_info(\"This document was generated from a jupyter notebook\")) <pre>This document was generated from a jupyter notebook on 2025-05-16 14:16:28.450990\n    swift2 2.5.1\n    uchronia 2.6.2\n</pre> <p>Li, Ming; Wang, QJ; Bennett, James; Robertson, David. Error reduction and representation in stages (ERRIS) in hydrological modelling for ensemble streamflow forecasting. Hydrology and Earth System Sciences. 2016; 20:3561-3579. https://doi.org/10.5194/hess-20-3561-2016 </p> In\u00a0[2]: Copied! <pre>import datetime as dt\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n</pre> import datetime as dt  import matplotlib.pyplot as plt import numpy as np import pandas as pd In\u00a0[3]: Copied! <pre>import seaborn as sns\n</pre> import seaborn as sns In\u00a0[4]: Copied! <pre>import swift2\nimport swift2.wrap.swift_wrap_custom as swc\n</pre> import swift2 import swift2.wrap.swift_wrap_custom as swc In\u00a0[5]: Copied! <pre># Only temporary, under construction...\nimport swift2.wrap.swift_wrap_generated as swg\nimport xarray as xr\n</pre> # Only temporary, under construction... import swift2.wrap.swift_wrap_generated as swg import xarray as xr In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[6]: Copied! <pre>from cinterop.timeseries import (\n    TIME_DIMNAME,\n    pd_series_to_xr_series,\n    slice_xr_time_series,\n    xr_ts_end,\n    xr_ts_start,\n)\n</pre> from cinterop.timeseries import (     TIME_DIMNAME,     pd_series_to_xr_series,     slice_xr_time_series,     xr_ts_end,     xr_ts_start, ) In\u00a0[7]: Copied! <pre>from swift2.doc_helper import *\n\n# from swift2.prototypes import extractOptimizationLog\nfrom swift2.model_definitions import *\nfrom swift2.parameteriser import *\nfrom swift2.play_record import *\nfrom swift2.simulation import *\nfrom swift2.statistics import *\nfrom swift2.system import *\nfrom swift2.utils import *\nfrom swift2.vis import OptimisationPlots\nfrom uchronia.time_series import get_item, mk_date\n</pre> from swift2.doc_helper import *  # from swift2.prototypes import extractOptimizationLog from swift2.model_definitions import * from swift2.parameteriser import * from swift2.play_record import * from swift2.simulation import * from swift2.statistics import * from swift2.system import * from swift2.utils import * from swift2.vis import OptimisationPlots from uchronia.time_series import get_item, mk_date In\u00a0[8]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[9]: Copied! <pre>catchmentStructure = sample_catchment_model(site_id= \"Adelaide\", config_id=\"catchment\")\n\nhydromodel = \"GR4J\";\nchannel_routing = 'MuskingumNonLinear';\nhydroModelRainfallId = 'P'\nhydroModelEvapId = 'E'\n\nfrom swift2.classes import HypercubeParameteriser, Parameteriser, Simulation\n</pre> catchmentStructure = sample_catchment_model(site_id= \"Adelaide\", config_id=\"catchment\")  hydromodel = \"GR4J\"; channel_routing = 'MuskingumNonLinear'; hydroModelRainfallId = 'P' hydroModelEvapId = 'E'  from swift2.classes import HypercubeParameteriser, Parameteriser, Simulation In\u00a0[10]: Copied! <pre># set models\ninsimulation = swap_model(catchmentStructure, model_id= hydromodel ,what = \"runoff\")\nsimulation:Simulation = swap_model(insimulation, model_id = channel_routing ,what = \"channel_routing\")\n\nsaId = get_subarea_ids(simulation)\n</pre> # set models insimulation = swap_model(catchmentStructure, model_id= hydromodel ,what = \"runoff\") simulation:Simulation = swap_model(insimulation, model_id = channel_routing ,what = \"channel_routing\")  saId = get_subarea_ids(simulation) In\u00a0[11]: Copied! <pre>saId = saId[0] # HACK: need to test robustness to different time series passed to player functions\n\nprecipTs = sample_series(site_id = \"Adelaide\", var_name= \"rain\")\nevapTs = sample_series(site_id = \"Adelaide\", var_name = \"evap\")\nflowRateTs = sample_series(site_id = \"Adelaide\", var_name = \"flow\")\n\nplay_input(simulation, precipTs, mk_full_data_id('subarea', saId, hydroModelRainfallId))\nplay_input(simulation, evapTs, mk_full_data_id('subarea', saId, hydroModelEvapId))\nconfigure_hourly_gr4j(simulation)\nset_simulation_time_step(simulation, 'hourly')\n\n# Small time interval only, to reduce runtimes in this vignette\nsimstart = mk_date(2010,12,1)  \nsimend = mk_date(2011,6,30,23)  \nsimwarmup = simstart\n\nset_simulation_span(simulation, simstart, simend)\n</pre> saId = saId[0] # HACK: need to test robustness to different time series passed to player functions  precipTs = sample_series(site_id = \"Adelaide\", var_name= \"rain\") evapTs = sample_series(site_id = \"Adelaide\", var_name = \"evap\") flowRateTs = sample_series(site_id = \"Adelaide\", var_name = \"flow\")  play_input(simulation, precipTs, mk_full_data_id('subarea', saId, hydroModelRainfallId)) play_input(simulation, evapTs, mk_full_data_id('subarea', saId, hydroModelEvapId)) configure_hourly_gr4j(simulation) set_simulation_time_step(simulation, 'hourly')  # Small time interval only, to reduce runtimes in this vignette simstart = mk_date(2010,12,1)   simend = mk_date(2011,6,30,23)   simwarmup = simstart  set_simulation_span(simulation, simstart, simend) In\u00a0[12]: Copied! <pre>flowRateTs\n</pre> flowRateTs Out[12]: <pre>2007-01-01 00:00:00      NaN\n2007-01-01 01:00:00      NaN\n2007-01-01 02:00:00      NaN\n2007-01-01 03:00:00      NaN\n2007-01-01 04:00:00      NaN\n                       ...  \n2014-12-04 17:00:00    0.435\n2014-12-04 18:00:00    0.424\n2014-12-04 19:00:00    0.414\n2014-12-04 20:00:00    0.405\n2014-12-04 21:00:00    0.397\nLength: 69478, dtype: float64</pre> In\u00a0[13]: Copied! <pre>get_state_value(simulation, \"subarea.1.areaKm2\")\n# getCatchmentStructure(simulation)\n</pre> get_state_value(simulation, \"subarea.1.areaKm2\") # getCatchmentStructure(simulation) Out[13]: <pre>{'subarea.1.areaKm2': 638.0}</pre> In\u00a0[14]: Copied! <pre>get_state_value(catchmentStructure, \"subarea.1.areaKm2\")\n</pre> get_state_value(catchmentStructure, \"subarea.1.areaKm2\") Out[14]: <pre>{'subarea.1.areaKm2': 638.0}</pre> In\u00a0[15]: Copied! <pre>def templateHydroParameterizer(simulation):\n    return define_parameteriser_gr4j_muskingum(ref_area=250.0,\n        time_span=3600,\n        simulation=simulation,\n        objfun=\"NSE\",\n        delta_t=1.0,\n        param_name_k='Alpha')\n\nnodeId = 'node.2'\nflowId = mk_full_data_id(nodeId, 'OutflowRate')\n\nrecord_state(simulation, flowId)\n</pre> def templateHydroParameterizer(simulation):     return define_parameteriser_gr4j_muskingum(ref_area=250.0,         time_span=3600,         simulation=simulation,         objfun=\"NSE\",         delta_t=1.0,         param_name_k='Alpha')  nodeId = 'node.2' flowId = mk_full_data_id(nodeId, 'OutflowRate')  record_state(simulation, flowId) <p>We use pre-calibrated hydrologic parameters (reproducible with doc/error_correction_doc_preparation.r in this package structure)</p> In\u00a0[16]: Copied! <pre>p = templateHydroParameterizer(simulation)\nset_min_parameter_value(p, 'R0', 0.0)\nset_max_parameter_value(p, 'R0', 1.0)\nset_min_parameter_value(p, 'S0', 0.0)\nset_max_parameter_value(p, 'S0', 1.0)\nset_parameter_value( p, 'log_x4', 1.017730e+00)\nset_parameter_value( p, 'log_x1', 2.071974e+00\t)\nset_parameter_value( p, 'log_x3', 1.797909e+00\t)\nset_parameter_value( p, 'asinh_x2', -1.653842e+00)\t\nset_parameter_value( p, 'R0', 2.201930e-11\t)\nset_parameter_value( p, 'S0', 3.104968e-11\t)\nset_parameter_value( p, 'X', 6.595537e-03\t) # Gotcha: needs to be set before alpha is changed.\nset_parameter_value( p, 'Alpha', 6.670534e-01\t)\np.as_dataframe()\n\n    \nsViz = mk_date(2010,12,1)\neViz = mk_date(2011,4,30,23)\n\ndef one_wet_season(tts):\n    from cinterop.timeseries import ts_window\n    return ts_window(tts, from_date=sViz, to_date=eViz) \n\ndef plot_obs_vs_calc(obs, calc, ylab=\"flow (m3/s)\"):\n    from swift2.vis import plot_two_series\n    obs = as_xarray_series(one_wet_season(obs))\n    calc = one_wet_season(calc)\n    plot_two_series(obs, calc, start_time= xr_ts_start(obs), end_time= xr_ts_end(obs))\n</pre> p = templateHydroParameterizer(simulation) set_min_parameter_value(p, 'R0', 0.0) set_max_parameter_value(p, 'R0', 1.0) set_min_parameter_value(p, 'S0', 0.0) set_max_parameter_value(p, 'S0', 1.0) set_parameter_value( p, 'log_x4', 1.017730e+00) set_parameter_value( p, 'log_x1', 2.071974e+00\t) set_parameter_value( p, 'log_x3', 1.797909e+00\t) set_parameter_value( p, 'asinh_x2', -1.653842e+00)\t set_parameter_value( p, 'R0', 2.201930e-11\t) set_parameter_value( p, 'S0', 3.104968e-11\t) set_parameter_value( p, 'X', 6.595537e-03\t) # Gotcha: needs to be set before alpha is changed. set_parameter_value( p, 'Alpha', 6.670534e-01\t) p.as_dataframe()       sViz = mk_date(2010,12,1) eViz = mk_date(2011,4,30,23)  def one_wet_season(tts):     from cinterop.timeseries import ts_window     return ts_window(tts, from_date=sViz, to_date=eViz)   def plot_obs_vs_calc(obs, calc, ylab=\"flow (m3/s)\"):     from swift2.vis import plot_two_series     obs = as_xarray_series(one_wet_season(obs))     calc = one_wet_season(calc)     plot_two_series(obs, calc, start_time= xr_ts_start(obs), end_time= xr_ts_end(obs)) In\u00a0[17]: Copied! <pre>p.apply_sys_config(simulation)\n</pre> p.apply_sys_config(simulation) In\u00a0[18]: Copied! <pre>simulation.exec_simulation()\n</pre> simulation.exec_simulation() In\u00a0[19]: Copied! <pre>plot_obs_vs_calc(flowRateTs, simulation.get_recorded(flowId))\n</pre> plot_obs_vs_calc(flowRateTs, simulation.get_recorded(flowId)) In\u00a0[20]: Copied! <pre>flowRateTs\n</pre> flowRateTs Out[20]: <pre>2007-01-01 00:00:00      NaN\n2007-01-01 01:00:00      NaN\n2007-01-01 02:00:00      NaN\n2007-01-01 03:00:00      NaN\n2007-01-01 04:00:00      NaN\n                       ...  \n2014-12-04 17:00:00    0.435\n2014-12-04 18:00:00    0.424\n2014-12-04 19:00:00    0.414\n2014-12-04 20:00:00    0.405\n2014-12-04 21:00:00    0.397\nLength: 69478, dtype: float64</pre> In\u00a0[21]: Copied! <pre>simulation.get_node_ids(), simulation.get_node_names()\n</pre> simulation.get_node_ids(), simulation.get_node_names() Out[21]: <pre>(['2', '1'], ['Outlet', 'Node_1'])</pre> In\u00a0[22]: Copied! <pre>errorModelElementId = 'node.2';\nsimulation.set_error_correction_model('ERRIS', errorModelElementId, length=-1, seed=0)\n\nflowRateTsGapped = flowRateTs\n</pre> errorModelElementId = 'node.2'; simulation.set_error_correction_model('ERRIS', errorModelElementId, length=-1, seed=0)  flowRateTsGapped = flowRateTs In\u00a0[23]: Copied! <pre>flowRateTsGapped['2011-02'] = np.nan\n\n# plot(flowRateTsGapped)\n\nplay_input(simulation,flowRateTsGapped,var_ids=mk_full_data_id(errorModelElementId,\"ec\",\"Observation\"))\n</pre> flowRateTsGapped['2011-02'] = np.nan  # plot(flowRateTsGapped)  play_input(simulation,flowRateTsGapped,var_ids=mk_full_data_id(errorModelElementId,\"ec\",\"Observation\")) <p>Now, prepare a model with error correction, and set up for generation</p> In\u00a0[24]: Copied! <pre>from swift2.prototypes import *\n\necs = simulation.clone()\n\necs.set_state_value(mk_full_data_id(nodeId,\"ec\",\"Generating\"),False)\nupdatedFlowVarID = mk_full_data_id(nodeId,\"ec\",\"Updated\")\ninputFlowVarID = mk_full_data_id(nodeId,\"ec\",\"Input\")\necs.record_state(var_ids=c(updatedFlowVarID, inputFlowVarID))\n</pre> from swift2.prototypes import *  ecs = simulation.clone()  ecs.set_state_value(mk_full_data_id(nodeId,\"ec\",\"Generating\"),False) updatedFlowVarID = mk_full_data_id(nodeId,\"ec\",\"Updated\") inputFlowVarID = mk_full_data_id(nodeId,\"ec\",\"Input\") ecs.record_state(var_ids=c(updatedFlowVarID, inputFlowVarID)) In\u00a0[25]: Copied! <pre>#termination = getMaxRuntimeTermination(0.005)\ntermination = create_sce_termination_wila('relative standard deviation', c('0.05','0.0167'))\n</pre> #termination = getMaxRuntimeTermination(0.005) termination = create_sce_termination_wila('relative standard deviation', c('0.05','0.0167')) <p>We could set up a four-stages estimation in one go, but we will instead work in each stages for didactic purposes.</p> In\u00a0[26]: Copied! <pre>%%time \ncensOpt = 0.0\nestimator = create_erris_parameter_estimator (simulation, flowRateTs, errorModelElementId,\n                                            estimation_start = simstart, estimation_end=simend, cens_thr=0.0, cens_opt=censOpt,\n                                            termination_condition=termination, restriction_on=True, weighted_least_square=False)\n\nstageOnePset = swg.CalibrateERRISStageOne_py(estimator)\nprint(stageOnePset.as_dataframe())\n</pre> %%time  censOpt = 0.0 estimator = create_erris_parameter_estimator (simulation, flowRateTs, errorModelElementId,                                             estimation_start = simstart, estimation_end=simend, cens_thr=0.0, cens_opt=censOpt,                                             termination_condition=termination, restriction_on=True, weighted_least_square=False)  stageOnePset = swg.CalibrateERRISStageOne_py(estimator) print(stageOnePset.as_dataframe()) <pre>              Name        Value     Min     Max\n0          Epsilon    -7.972797   -20.0     0.0\n1           Lambda    -0.935233   -30.0     5.0\n2                D     0.000000     0.0     0.0\n3               Mu     0.000000     0.0     0.0\n4              Rho     0.000000     0.0     0.0\n5   Sigma1_Falling     0.000000     0.0     0.0\n6    Sigma1_Rising     0.000000     0.0     0.0\n7   Sigma2_Falling     0.000000     0.0     0.0\n8    Sigma2_Rising     0.000000     0.0     0.0\n9   Weight_Falling     1.000000     1.0     1.0\n10   Weight_Rising     1.000000     1.0     1.0\n11         CensThr     0.000000     0.0     0.0\n12         CensOpt     0.000000     0.0     0.0\n13          MaxObs  1126.300000  1126.3  1126.3\nCPU times: user 3.13 s, sys: 11 \u03bcs, total: 3.13 s\nWall time: 3.13 s\n</pre> In\u00a0[27]: Copied! <pre>%%time \nswg.SetERRISVerboseCalibration_py(estimator, True)\nstageTwoPset = swg.CalibrateERRISStageTwo_py(estimator, stageOnePset)\nprint(stageTwoPset.as_dataframe())\n</pre> %%time  swg.SetERRISVerboseCalibration_py(estimator, True) stageTwoPset = swg.CalibrateERRISStageTwo_py(estimator, stageOnePset) print(stageTwoPset.as_dataframe()) <pre>              Name        Value          Min          Max\n0                D     0.747785     0.000000     2.000000\n1               Mu    -1.648841  -100.000000   100.000000\n2    Sigma1_Rising     0.349269    -6.907755     6.907755\n3          CensOpt     0.000000     0.000000     0.000000\n4          CensThr     0.000000     0.000000     0.000000\n5          Epsilon    -7.972797    -7.972797    -7.972797\n6           Lambda    -0.935233    -0.935233    -0.935233\n7           MaxObs  1126.300000  1126.300000  1126.300000\n8              Rho     0.000000     0.000000     0.000000\n9   Sigma1_Falling     0.000000     0.000000     0.000000\n10  Sigma2_Falling     0.000000     0.000000     0.000000\n11   Sigma2_Rising     0.000000     0.000000     0.000000\n12  Weight_Falling     1.000000     1.000000     1.000000\n13   Weight_Rising     1.000000     1.000000     1.000000\nCPU times: user 8.53 s, sys: 234 \u03bcs, total: 8.53 s\nWall time: 8.53 s\n</pre> In\u00a0[28]: Copied! <pre>def mkEcIds(p:HypercubeParameteriser) -&gt; HypercubeParameteriser:\n    df = p.as_dataframe()\n    df.Name = mk_full_data_id(nodeId, 'ec', df.Name)\n    return create_parameteriser('Generic',df)\n\nmkEcIds(stageTwoPset).apply_sys_config(ecs)\necs.exec_simulation()\nplot_obs_vs_calc(flowRateTsGapped, ecs.get_recorded(updatedFlowVarID))\n</pre> def mkEcIds(p:HypercubeParameteriser) -&gt; HypercubeParameteriser:     df = p.as_dataframe()     df.Name = mk_full_data_id(nodeId, 'ec', df.Name)     return create_parameteriser('Generic',df)  mkEcIds(stageTwoPset).apply_sys_config(ecs) ecs.exec_simulation() plot_obs_vs_calc(flowRateTsGapped, ecs.get_recorded(updatedFlowVarID)) <p>A helper function to process the calibration log:</p> In\u00a0[29]: Copied! <pre># def prepOptimLog(estimator, fitness_name = \"Log.likelihood\"):\n#     optimLog = getLoggerContent(estimator)\n#     # head(optimLog)\n#     # optimLog$PointNumber = 1:nrow(optimLog)   \n#     logMh = mkOptimLog(optimLog, fitness = fitness_name, messages = \"Message\", categories = \"Category\") \n#     geom_ops = mhplot::subset_by_message(logMh)\n#     d = list(data=logMh, geom_ops=geom_ops)\n# }\n</pre> # def prepOptimLog(estimator, fitness_name = \"Log.likelihood\"): #     optimLog = getLoggerContent(estimator) #     # head(optimLog) #     # optimLog$PointNumber = 1:nrow(optimLog)    #     logMh = mkOptimLog(optimLog, fitness = fitness_name, messages = \"Message\", categories = \"Category\")  #     geom_ops = mhplot::subset_by_message(logMh) #     d = list(data=logMh, geom_ops=geom_ops) # } In\u00a0[30]: Copied! <pre>type(estimator), str(estimator)\n</pre> type(estimator), str(estimator) Out[30]: <pre>(swift2.classes.ErrisStagedCalibration,\n 'CFFI pointer handle to a native pointer of type id \"ERRIS_STAGED_CALIBRATION_PTR\"')</pre> In\u00a0[31]: Copied! <pre>opt_log = estimator.extract_optimisation_log(fitness_name = \"Log-likelihood\")\n</pre> opt_log = estimator.extract_optimisation_log(fitness_name = \"Log-likelihood\") In\u00a0[32]: Copied! <pre>geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*') \n</pre> geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*')  In\u00a0[33]: Copied! <pre>def get_max_ll(): return np.max(geom_ops._data[\"Log-likelihood\"])\n</pre> def get_max_ll(): return np.max(geom_ops._data[\"Log-likelihood\"]) In\u00a0[34]: Copied! <pre>v = OptimisationPlots(geom_ops)\ng = v.parameter_evolution('Sigma1_Rising', c(0, get_max_ll()))\nplt.gcf().set_size_inches(10,8)\n</pre> v = OptimisationPlots(geom_ops) g = v.parameter_evolution('Sigma1_Rising', c(0, get_max_ll())) plt.gcf().set_size_inches(10,8) In\u00a0[35]: Copied! <pre>%%time\nstageThreePset = swg.CalibrateERRISStageThree_py(estimator, stageTwoPset)\nprint(stageThreePset.as_dataframe())\n</pre> %%time stageThreePset = swg.CalibrateERRISStageThree_py(estimator, stageTwoPset) print(stageThreePset.as_dataframe()) <pre>              Name        Value          Min          Max\n0              Rho     0.977261     0.000000     1.000000\n1    Sigma1_Rising    -1.613140    -6.907755     6.907755\n2          CensOpt     0.000000     0.000000     0.000000\n3          CensThr     0.000000     0.000000     0.000000\n4                D     0.747785     0.747785     0.747785\n5          Epsilon    -7.972797    -7.972797    -7.972797\n6           Lambda    -0.935233    -0.935233    -0.935233\n7           MaxObs  1126.300000  1126.300000  1126.300000\n8               Mu    -1.648841    -1.648841    -1.648841\n9   Sigma1_Falling     0.000000     0.000000     0.000000\n10  Sigma2_Falling     0.000000     0.000000     0.000000\n11   Sigma2_Rising     0.000000     0.000000     0.000000\n12  Weight_Falling     1.000000     1.000000     1.000000\n13   Weight_Rising     1.000000     1.000000     1.000000\nCPU times: user 2.01 s, sys: 0 ns, total: 2.01 s\nWall time: 2.01 s\n</pre> In\u00a0[36]: Copied! <pre>opt_log = estimator.extract_optimisation_log(fitness_name = \"Log-likelihood\")\n</pre> opt_log = estimator.extract_optimisation_log(fitness_name = \"Log-likelihood\") In\u00a0[37]: Copied! <pre>geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*') \n</pre> geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*')  In\u00a0[38]: Copied! <pre>v = OptimisationPlots(geom_ops)\ng = v.parameter_evolution('Rho', c(0, get_max_ll()))\nplt.gcf().set_size_inches(10,8)\n</pre> v = OptimisationPlots(geom_ops) g = v.parameter_evolution('Rho', c(0, get_max_ll())) plt.gcf().set_size_inches(10,8) In\u00a0[39]: Copied! <pre>%%time\nstageThreePsetMS = swg.CalibrateERRISStageThreeMS_py(estimator, stageThreePset)\nprint(stageThreePsetMS.as_dataframe())\n</pre> %%time stageThreePsetMS = swg.CalibrateERRISStageThreeMS_py(estimator, stageThreePset) print(stageThreePsetMS.as_dataframe()) <pre>              Name        Value          Min          Max\n0              Rho     0.977261     0.000000     1.000000\n1    Sigma1_Rising    -1.613140    -6.907755     6.907755\n2          CensOpt     0.000000     0.000000     0.000000\n3          CensThr     0.000000     0.000000     0.000000\n4                D     0.747785     0.747785     0.747785\n5          Epsilon    -7.972797    -7.972797    -7.972797\n6           Lambda    -0.935233    -0.935233    -0.935233\n7           MaxObs  1126.300000  1126.300000  1126.300000\n8               Mu    -1.648841    -1.648841    -1.648841\n9   Sigma1_Falling     0.000000     0.000000     0.000000\n10  Sigma2_Falling     0.000000     0.000000     0.000000\n11   Sigma2_Rising     0.000000     0.000000     0.000000\n12  Weight_Falling     1.000000     1.000000     1.000000\n13   Weight_Rising     1.000000     1.000000     1.000000\n14          MNoise    -0.802462  -100.000000   100.000000\n15          SNoise     1.948928   -10.000000    10.000000\nCPU times: user 533 ms, sys: 14 \u03bcs, total: 533 ms\nWall time: 532 ms\n</pre> In\u00a0[40]: Copied! <pre>mkEcIds(stageThreePsetMS).apply_sys_config(ecs)\necs.exec_simulation()\nplot_obs_vs_calc(flowRateTsGapped, ecs.get_recorded(updatedFlowVarID))\n</pre> mkEcIds(stageThreePsetMS).apply_sys_config(ecs) ecs.exec_simulation() plot_obs_vs_calc(flowRateTsGapped, ecs.get_recorded(updatedFlowVarID)) In\u00a0[41]: Copied! <pre>%%time\nstageFourPsetRising = swg.CalibrateERRISStageFour_py(estimator, stageThreePsetMS, useRising = True)\nprint(stageFourPsetRising.as_dataframe())\n</pre> %%time stageFourPsetRising = swg.CalibrateERRISStageFour_py(estimator, stageThreePsetMS, useRising = True) print(stageFourPsetRising.as_dataframe()) <pre>              Name        Value          Min          Max\n0    Sigma1_Rising    -1.725378    -6.907755     6.907755\n1    Sigma2_Rising     0.086763    -6.907755     6.907755\n2    Weight_Rising     0.853421     0.500000     1.000000\n3          CensOpt     0.000000     0.000000     0.000000\n4          CensThr     0.000000     0.000000     0.000000\n5                D     0.747785     0.747785     0.747785\n6          Epsilon    -7.972797    -7.972797    -7.972797\n7           Lambda    -0.935233    -0.935233    -0.935233\n8           MaxObs  1126.300000  1126.300000  1126.300000\n9               Mu    -1.648841    -1.648841    -1.648841\n10             Rho     0.977261     0.977261     0.977261\n11  Sigma1_Falling     0.000000     0.000000     0.000000\n12  Sigma2_Falling     0.000000     0.000000     0.000000\n13  Weight_Falling     1.000000     1.000000     1.000000\nCPU times: user 2.25 s, sys: 26 \u03bcs, total: 2.25 s\nWall time: 2.25 s\n</pre> In\u00a0[42]: Copied! <pre>opt_log = estimator.extract_optimisation_log(fitness_name = \"Log-likelihood\")\n</pre> opt_log = estimator.extract_optimisation_log(fitness_name = \"Log-likelihood\") In\u00a0[43]: Copied! <pre>geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*') \n</pre> geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*')  In\u00a0[44]: Copied! <pre>v = OptimisationPlots(geom_ops)\ng = v.parameter_evolution('Weight_Rising', c(0, get_max_ll()))\nplt.gcf().set_size_inches(10,8)\n</pre> v = OptimisationPlots(geom_ops) g = v.parameter_evolution('Weight_Rising', c(0, get_max_ll())) plt.gcf().set_size_inches(10,8) In\u00a0[45]: Copied! <pre>mkEcIds(stageFourPsetRising).apply_sys_config(ecs)\necs.exec_simulation()\nplot_obs_vs_calc(flowRateTsGapped, ecs.get_recorded(updatedFlowVarID))\n</pre> mkEcIds(stageFourPsetRising).apply_sys_config(ecs) ecs.exec_simulation() plot_obs_vs_calc(flowRateTsGapped, ecs.get_recorded(updatedFlowVarID)) In\u00a0[46]: Copied! <pre>%%time\nstageFourPsetFalling = swg.CalibrateERRISStageFour_py(estimator, stageThreePsetMS, useRising = False)\nprint(stageFourPsetFalling.as_dataframe())\n</pre> %%time stageFourPsetFalling = swg.CalibrateERRISStageFour_py(estimator, stageThreePsetMS, useRising = False) print(stageFourPsetFalling.as_dataframe()) <pre>              Name        Value          Min          Max\n0    Sigma1_Rising    -3.675723    -6.907755     6.907755\n1    Sigma2_Rising    -1.198708    -6.907755     6.907755\n2    Weight_Rising     0.794993     0.500000     1.000000\n3          CensOpt     0.000000     0.000000     0.000000\n4          CensThr     0.000000     0.000000     0.000000\n5                D     0.747785     0.747785     0.747785\n6          Epsilon    -7.972797    -7.972797    -7.972797\n7           Lambda    -0.935233    -0.935233    -0.935233\n8           MaxObs  1126.300000  1126.300000  1126.300000\n9               Mu    -1.648841    -1.648841    -1.648841\n10             Rho     0.977261     0.977261     0.977261\n11  Sigma1_Falling     0.000000     0.000000     0.000000\n12  Sigma2_Falling     0.000000     0.000000     0.000000\n13  Weight_Falling     1.000000     1.000000     1.000000\nCPU times: user 27.6 s, sys: 12.1 ms, total: 27.6 s\nWall time: 27.6 s\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[47]: Copied! <pre>opt_log = estimator.extract_optimisation_log(fitness_name = \"Log-likelihood\")\n</pre> opt_log = estimator.extract_optimisation_log(fitness_name = \"Log-likelihood\") In\u00a0[48]: Copied! <pre>geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*') \n</pre> geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*')  In\u00a0[49]: Copied! <pre>v = OptimisationPlots(geom_ops)\ng = v.parameter_evolution('Weight_Rising', c(0, get_max_ll()))\nplt.gcf().set_size_inches(10,8)\n</pre> v = OptimisationPlots(geom_ops) g = v.parameter_evolution('Weight_Rising', c(0, get_max_ll())) plt.gcf().set_size_inches(10,8) In\u00a0[50]: Copied! <pre>finalPset = swg.ConcatenateERRISStagesParameters_py(estimator, hydroParams = create_parameteriser(), stage1_result =  stageOnePset, stage2_result = stageTwoPset, \n                                   stage3_result = stageThreePsetMS, stage4a_result = stageFourPsetRising, stage4b_result = stageFourPsetFalling, toLongParameterName = False)\n\nprint(finalPset.as_dataframe())\n</pre> finalPset = swg.ConcatenateERRISStagesParameters_py(estimator, hydroParams = create_parameteriser(), stage1_result =  stageOnePset, stage2_result = stageTwoPset,                                     stage3_result = stageThreePsetMS, stage4a_result = stageFourPsetRising, stage4b_result = stageFourPsetFalling, toLongParameterName = False)  print(finalPset.as_dataframe()) <pre>              Name        Value          Min          Max\n0          CensThr     0.000000     0.000000     0.000000\n1          CensOpt     0.000000     0.000000     0.000000\n2           MNoise    -0.802462  -100.000000   100.000000\n3           SNoise     1.948928   -10.000000    10.000000\n4           Lambda    -0.935233    -0.935233    -0.935233\n5          Epsilon    -7.972797    -7.972797    -7.972797\n6               Mu    -1.648841    -1.648841    -1.648841\n7                D     0.747785     0.747785     0.747785\n8              Rho     0.977261     0.977261     0.977261\n9           MaxObs  1126.300000  1126.300000  1126.300000\n10   Sigma1_Rising    -1.725378    -6.907755     6.907755\n11   Sigma2_Rising     0.086763    -6.907755     6.907755\n12   Weight_Rising     0.853421     0.500000     1.000000\n13  Sigma1_Falling    -3.675723    -6.907755     6.907755\n14  Sigma2_Falling    -1.198708    -6.907755     6.907755\n15  Weight_Falling     0.794993     0.500000     1.000000\n</pre> In\u00a0[51]: Copied! <pre>%%time\n\ncensOpt = 0.0\ntermination = create_sce_termination_wila('relative standard deviation', c('0.05','0.0167'))\n\ndummyDate = simstart\n\nfrom swift2.prototypes import estimate_erris_parameters\n\npsetFullEstimate = estimate_erris_parameters(simulation, flowRateTs, errorModelElementId,\n  warmup_start=dummyDate, warmup_end=dummyDate, warmup=False, estimation_start = simstart, estimation_end=simend, cens_thr=0.0,\n cens_opt = censOpt, exclusion_start=dummyDate, exclusion_end=dummyDate, exclusion=False, termination_condition = termination,\n  hydro_params = None, erris_params = None, restriction_on = True,\n  weighted_least_square = False)\n\nprint(psetFullEstimate.as_dataframe())\n</pre> %%time  censOpt = 0.0 termination = create_sce_termination_wila('relative standard deviation', c('0.05','0.0167'))  dummyDate = simstart  from swift2.prototypes import estimate_erris_parameters  psetFullEstimate = estimate_erris_parameters(simulation, flowRateTs, errorModelElementId,   warmup_start=dummyDate, warmup_end=dummyDate, warmup=False, estimation_start = simstart, estimation_end=simend, cens_thr=0.0,  cens_opt = censOpt, exclusion_start=dummyDate, exclusion_end=dummyDate, exclusion=False, termination_condition = termination,   hydro_params = None, erris_params = None, restriction_on = True,   weighted_least_square = False)  print(psetFullEstimate.as_dataframe()) <pre>                        Name        Value          Min          Max\n0          node.2.ec.CensThr     0.000000     0.000000     0.000000\n1          node.2.ec.CensOpt     0.000000     0.000000     0.000000\n2           node.2.ec.MNoise    -0.802462  -100.000000   100.000000\n3           node.2.ec.SNoise     1.948928   -10.000000    10.000000\n4           node.2.ec.Lambda    -0.935233    -0.935233    -0.935233\n5          node.2.ec.Epsilon    -7.972797    -7.972797    -7.972797\n6               node.2.ec.Mu    -1.648841    -1.648841    -1.648841\n7                node.2.ec.D     0.747785     0.747785     0.747785\n8              node.2.ec.Rho     0.977261     0.977261     0.977261\n9           node.2.ec.MaxObs  1126.300000  1126.300000  1126.300000\n10   node.2.ec.Sigma1_Rising    -1.725378    -6.907755     6.907755\n11   node.2.ec.Sigma2_Rising     0.086763    -6.907755     6.907755\n12   node.2.ec.Weight_Rising     0.853421     0.500000     1.000000\n13  node.2.ec.Sigma1_Falling    -3.675723    -6.907755     6.907755\n14  node.2.ec.Sigma2_Falling    -1.198708    -6.907755     6.907755\n15  node.2.ec.Weight_Falling     0.794993     0.500000     1.000000\nCPU times: user 44.1 s, sys: 12 ms, total: 44.1 s\nWall time: 44.1 s\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/error_correction_four_stages/#error-correction-models-erris","title":"Error correction models - ERRIS\u00b6","text":""},{"location":"notebooks/error_correction_four_stages/#about-this-document","title":"About this document\u00b6","text":""},{"location":"notebooks/error_correction_four_stages/#calibrating-erris","title":"Calibrating ERRIS\u00b6","text":""},{"location":"notebooks/error_correction_four_stages/#model-structure","title":"Model structure\u00b6","text":"<p>We use sample hourly data from the Adelaide catchment this catchment in the Northern Territory, TBC. The catchment model set up is not the key point of this vignette so we do not comment on that section:</p>"},{"location":"notebooks/error_correction_four_stages/#set-up-the-error-correction-model","title":"Set up the error correction model\u00b6","text":""},{"location":"notebooks/error_correction_four_stages/#erris-calibration-in-stages","title":"ERRIS calibration in stages\u00b6","text":""},{"location":"notebooks/error_correction_four_stages/#stage-2","title":"Stage 2\u00b6","text":"<p>Stage two can be logged:</p>"},{"location":"notebooks/error_correction_four_stages/#stage-3","title":"Stage 3\u00b6","text":""},{"location":"notebooks/error_correction_four_stages/#stage-3a-generating-and-fitting-m-and-s-if-free","title":"Stage 3a, generating and fitting M and S if free\u00b6","text":""},{"location":"notebooks/error_correction_four_stages/#stage-4-rising-limb","title":"Stage 4, rising limb\u00b6","text":""},{"location":"notebooks/error_correction_four_stages/#stage-4-falling-limbs","title":"Stage 4, falling limbs\u00b6","text":""},{"location":"notebooks/error_correction_four_stages/#final-consolidated-parameter-set","title":"Final consolidated parameter set\u00b6","text":""},{"location":"notebooks/error_correction_four_stages/#legacy-call","title":"Legacy call\u00b6","text":"<p>Check that the previous \"one stop shop\" call gives the same results.</p>"},{"location":"notebooks/getting_started/","title":"Getting started with the swift python package","text":"In\u00a0[1]: Copied! <pre>from swift2.doc_helper import pkg_versions_info\n\nprint(pkg_versions_info(\"This document was generated from a jupyter notebook\"))\n</pre> from swift2.doc_helper import pkg_versions_info  print(pkg_versions_info(\"This document was generated from a jupyter notebook\")) <pre>This document was generated from a jupyter notebook on 2025-05-16 14:18:01.960931\n    swift2 2.5.1\n    uchronia 2.6.2\n</pre> In\u00a0[2]: Copied! <pre>from typing import List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n</pre> from typing import List  import matplotlib.pyplot as plt import numpy as np import pandas as pd <p>Finally we import some visualisation facilities</p> In\u00a0[3]: Copied! <pre>import seaborn as sns\nimport xarray as xr\n</pre> import seaborn as sns import xarray as xr <p>Some dependencies of swift2, namely cinterop, offer generic functions for time series manipulations. While these could be imported via swift2 as well, let's be explicit for now:</p> In\u00a0[4]: Copied! <pre>from cinterop.timeseries import (\n    TIME_DIMNAME,\n    as_timestamp,\n    pd_series_to_xr_series,\n    slice_xr_time_series,\n    xr_ts_end,\n    xr_ts_start,\n)\nfrom swift2.doc_helper import get_free_params, sample_series\nfrom swift2.parameteriser import (\n    create_parameter_sampler,\n    create_parameteriser,\n    create_sce_termination_wila,\n    get_default_sce_parameters,\n)\nfrom swift2.simulation import create_subarea_simulation\n</pre> from cinterop.timeseries import (     TIME_DIMNAME,     as_timestamp,     pd_series_to_xr_series,     slice_xr_time_series,     xr_ts_end,     xr_ts_start, ) from swift2.doc_helper import get_free_params, sample_series from swift2.parameteriser import (     create_parameter_sampler,     create_parameteriser,     create_sce_termination_wila,     get_default_sce_parameters, ) from swift2.simulation import create_subarea_simulation In\u00a0[5]: Copied! <pre>from swift2.system import runoff_model_ids, runoff_model_var_ids\n</pre> from swift2.system import runoff_model_ids, runoff_model_var_ids <p>We import the main functions upfront from the package submodules. In practice this is something you may need to do only on an as needed basis of course. Jupyter notebooks can show dynanically submodules and functions listed, along with some documentation. A searchable technical documentation for the package is available from Python swift2 documentation.</p> In\u00a0[6]: Copied! <pre>from swift2.utils import mk_full_data_id, paste_2, vpaste\n</pre> from swift2.utils import mk_full_data_id, paste_2, vpaste In\u00a0[7]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[8]: Copied! <pre>create_subarea_simulation?\n</pre> create_subarea_simulation? In\u00a0[9]: Copied! <pre>ms = create_subarea_simulation(data_id='MMH', simul_start='1990-01-01', simul_end='2005-12-31', \n    model_id='GR4J', tstep='daily', varname_rain='P', varname_pet='E')\n</pre> ms = create_subarea_simulation(data_id='MMH', simul_start='1990-01-01', simul_end='2005-12-31',      model_id='GR4J', tstep='daily', varname_rain='P', varname_pet='E') In\u00a0[10]: Copied! <pre>ms\n</pre> ms Out[10]: <pre>Simulation wrapper for a CFFI pointer handle to a native pointer of type id \"MODEL_SIMULATION_PTR\"</pre> In\u00a0[11]: Copied! <pre>type(ms)\n</pre> type(ms) Out[11]: <pre>swift2.classes.Simulation</pre> <p>The python object <code>ms</code> may appear unusual to most users. This is basically a handle to the SWIFT simulation object written in C++. The model core is native, but wrapped by a \"pythonic\" <code>Simulation</code> object. The low-level interaction between python and the C API is handled by \"glue code\" and users will rarely if ever need to use the low-level API.</p> <p>The <code>Simulation</code> object has python methods to interact with it, for instance:</p> In\u00a0[12]: Copied! <pre>ms.describe?\n</pre> ms.describe? In\u00a0[13]: Copied! <pre>ms.describe()\n</pre> ms.describe() Out[13]: <pre>{'subareas': {'Subarea': 'Subarea'}, 'nodes': {}, 'links': {}}</pre> <p>Because we got a preconfigured, sample simulation, it is ready to execute, which means it already has some input data defined (a site with a codename 'MMH'). The <code>SWIFT</code> system uses the terms <code>playing from</code> and <code>recording to</code> time series, using an old style audio tape system as a metaphor. We can inspect the simulation for instance using <code>get_played_varnames</code> to check which state variable has an input time series:</p> In\u00a0[14]: Copied! <pre>ms.get_played_varnames()\n</pre> ms.get_played_varnames() Out[14]: <pre>['subarea.Subarea.E', 'subarea.Subarea.P']</pre> In\u00a0[15]: Copied! <pre>tts = ms.get_played()\ntts\n</pre> tts = ms.get_played() tts Out[15]: <pre>&lt;xarray.DataArray (variable_identifiers: 2, ensemble: 1, time: 5844)&gt; Size: 94kB\narray([[[5.5422, 5.5522, 5.5622, ..., 6.0744, 6.0735, 6.0725]],\n\n       [[0.    , 0.    , 0.    , ..., 2.1569, 0.    , 0.    ]]],\n      shape=(2, 1, 5844))\nCoordinates:\n  * ensemble              (ensemble) int64 8B 0\n  * time                  (time) datetime64[ns] 47kB 1990-01-01 ... 2005-12-31\n  * variable_identifiers  (variable_identifiers) object 16B 'subarea.Subarea....</pre>xarray.DataArray<ul><li>variable_identifiers: 2</li><li>ensemble: 1</li><li>time: 5844</li></ul><ul><li>5.542 5.552 5.562 5.572 5.582 5.592 ... 0.0659 0.5425 2.157 0.0 0.0<pre>array([[[5.5422, 5.5522, 5.5622, ..., 6.0744, 6.0735, 6.0725]],\n\n       [[0.    , 0.    , 0.    , ..., 2.1569, 0.    , 0.    ]]],\n      shape=(2, 1, 5844))</pre></li><li>Coordinates: (3)<ul><li>ensemble(ensemble)int640<pre>array([0])</pre></li><li>time(time)datetime64[ns]1990-01-01 ... 2005-12-31<pre>array(['1990-01-01T00:00:00.000000000', '1990-01-02T00:00:00.000000000',\n       '1990-01-03T00:00:00.000000000', ..., '2005-12-29T00:00:00.000000000',\n       '2005-12-30T00:00:00.000000000', '2005-12-31T00:00:00.000000000'],\n      shape=(5844,), dtype='datetime64[ns]')</pre></li><li>variable_identifiers(variable_identifiers)object'subarea.Subarea.E' 'subarea.Sub...<pre>array(['subarea.Subarea.E', 'subarea.Subarea.P'], dtype=object)</pre></li></ul></li><li>Indexes: (3)<ul><li>ensemblePandasIndex<pre>PandasIndex(Index([0], dtype='int64', name='ensemble'))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['1990-01-01', '1990-01-02', '1990-01-03', '1990-01-04',\n               '1990-01-05', '1990-01-06', '1990-01-07', '1990-01-08',\n               '1990-01-09', '1990-01-10',\n               ...\n               '2005-12-22', '2005-12-23', '2005-12-24', '2005-12-25',\n               '2005-12-26', '2005-12-27', '2005-12-28', '2005-12-29',\n               '2005-12-30', '2005-12-31'],\n              dtype='datetime64[ns]', name='time', length=5844, freq='D'))</pre></li><li>variable_identifiersPandasIndex<pre>PandasIndex(Index(['subarea.Subarea.E', 'subarea.Subarea.P'], dtype='object', name='variable_identifiers'))</pre></li></ul></li><li>Attributes: (0)</li></ul> <p>The C++ core has its own internal representation of time series. The Python package <code>swift2</code> uses generally <code>xarray</code> to represent time series, as it is particularly suited to handle ensemble of time series of dimensionality more than 2. The ensemble dimension is thus present by default in the returned array, even when there is only one realisation. This can be removed with the <code>squeeze</code> method of xarray.</p> In\u00a0[16]: Copied! <pre>tts = tts.squeeze(drop=True)\ng = tts.plot.line(add_legend=True, figsize=(16,8), col=\"variable_identifiers\", col_wrap=1, sharey=False)\ng;\n</pre> tts = tts.squeeze(drop=True) g = tts.plot.line(add_legend=True, figsize=(16,8), col=\"variable_identifiers\", col_wrap=1, sharey=False) g; <p>Many <code>swift2</code> python functions will however also accept pandas <code>DataFrame</code> or <code>Series</code> as input for time series when it makes sense to accept such time series representations.</p> In\u00a0[17]: Copied! <pre>ms.play_input?\n</pre> ms.play_input? <p>We can check with the <code>get_recorded_varnames</code> method that simulation object as not been \"told\" to record an output time series yet.</p> In\u00a0[18]: Copied! <pre>ms.get_recorded_varnames()\n</pre> ms.get_recorded_varnames() Out[18]: <pre>[]</pre> <p>SWIFT is designed to record model variables on demand in a highly flexible manner. First, we can query the system to find out known rainfall-runoff models, and the model variable names that we can record.</p> In\u00a0[19]: Copied! <pre>runoff_model_ids()\n</pre> runoff_model_ids() Out[19]: <pre>['NetRainfall',\n 'GR2M_MOD',\n 'GR4J',\n 'GR4J_SG',\n 'GR5H',\n 'GR6J',\n 'GR5J',\n 'PDM',\n 'AWBM',\n 'SACSMA',\n 'SACSMA_NSW',\n 'IHACRES',\n 'constant_outflow',\n 'external',\n 'WAPABA',\n 'GRKAL',\n 'SimHyd',\n 'HBV']</pre> <p>The GR4J model has the following states that can be \"listened to\" and \"recorded\" on demand over a simulation.</p> In\u00a0[20]: Copied! <pre>gr4j_model_vars = runoff_model_var_ids('GR4J')\nprint(gr4j_model_vars)\n</pre> gr4j_model_vars = runoff_model_var_ids('GR4J') print(gr4j_model_vars) <pre>['P', 'E', 'En', 'LAI', 'runoff', 'S', 'R', 'TWS', 'Eactual', 'Ps', 'Es', 'Pr', 'ech1', 'ech2', 'Perc', 'alpha', 'k', 'x1', 'x2', 'x3', 'x4', 'UHExponent', 'PercFactor']\n</pre> <p>These are the variable names for a single GR4J model instance; since SWIFT is for semi-distributed models, we need to use a hierarchical naming scheme to uniquely identify model variables (even when in this case we do have only one subarea). Using unique keys allow to inspect the model states in great details if needed.</p> In\u00a0[21]: Copied! <pre>ms.get_subarea_ids()\nms.get_state_value('subarea.Subarea.x4')\n</pre> ms.get_subarea_ids() ms.get_state_value('subarea.Subarea.x4') Out[21]: <pre>{'subarea.Subarea.x4': 0.5}</pre> <p>Let's record to time series all the storage and flux states of GR4J (no need to record model parameters which will be flat lines here). We can use the utility function <code>mk_full_data_id</code> for conciseness to vectorise the handling of multiple state identifiers.</p> In\u00a0[22]: Copied! <pre>to_record = ['runoff', 'S', 'R', 'Ps', 'Es', 'Pr', 'ech1', 'ech2', 'Perc']\nids = mk_full_data_id('subarea', 'Subarea', to_record)\n</pre> to_record = ['runoff', 'S', 'R', 'Ps', 'Es', 'Pr', 'ech1', 'ech2', 'Perc'] ids = mk_full_data_id('subarea', 'Subarea', to_record) In\u00a0[23]: Copied! <pre>ms.record_state(ids)\nms.get_recorded_varnames()\n</pre> ms.record_state(ids) ms.get_recorded_varnames() Out[23]: <pre>['subarea.Subarea.Es',\n 'subarea.Subarea.Perc',\n 'subarea.Subarea.Pr',\n 'subarea.Subarea.Ps',\n 'subarea.Subarea.R',\n 'subarea.Subarea.S',\n 'subarea.Subarea.ech1',\n 'subarea.Subarea.ech2',\n 'subarea.Subarea.runoff']</pre> In\u00a0[24]: Copied! <pre>ms.check_simulation()\n</pre> ms.check_simulation() Out[24]: <pre>{'errors': []}</pre> In\u00a0[25]: Copied! <pre>ms.exec_simulation()\n</pre> ms.exec_simulation() In\u00a0[26]: Copied! <pre>var_series = ms.get_recorded()\n</pre> var_series = ms.get_recorded() <p>We have a 3 dimensional data array, with 9 identifiers for state variables:</p> In\u00a0[27]: Copied! <pre>var_series.dims, var_series.shape\n</pre> var_series.dims, var_series.shape Out[27]: <pre>(('variable_identifiers', 'ensemble', 'time'), (9, 1, 5844))</pre> In\u00a0[28]: Copied! <pre>var_coords = var_series.coords['variable_identifiers'].values\nvar_coords\n</pre> var_coords = var_series.coords['variable_identifiers'].values var_coords Out[28]: <pre>array(['subarea.Subarea.Es', 'subarea.Subarea.Perc', 'subarea.Subarea.Pr',\n       'subarea.Subarea.Ps', 'subarea.Subarea.R', 'subarea.Subarea.S',\n       'subarea.Subarea.ech1', 'subarea.Subarea.ech2',\n       'subarea.Subarea.runoff'], dtype=object)</pre> <p>The variable identifiers are fully qualified, which is fine and certainly make a lot of sense for semi-distributed catchments. But to visualise these for a single subarea we shall override with short model names:</p> In\u00a0[29]: Copied! <pre>var_series.coords['variable_identifiers'] = to_record\n</pre> var_series.coords['variable_identifiers'] = to_record <p>Let's look at a shorter period of the output. We define a couple of functions to slice and plot the last three years of the time series, for clarity.</p> In\u00a0[30]: Copied! <pre>def last_three_years(tts:xr.DataArray):\n    start=tts.coords[TIME_DIMNAME].values[-(365*3)]\n    end=tts.coords[TIME_DIMNAME].values[-1]\n    return slice_xr_time_series(tts, start, end)\n\ndef plot_obs_vs_calc(obs, calc, ylab=\"runoff (mm)\"):\n    import uchronia.utils as uu\n    obs = last_three_years(obs)\n    calc = last_three_years(calc)\n    both = uu.xr_concat([obs,calc], ['observed','calculated'], 'type')\n    both.plot.line(add_legend=True, figsize=(9,4), hue=\"type\")\n    plt.ylabel(ylab)\n</pre> def last_three_years(tts:xr.DataArray):     start=tts.coords[TIME_DIMNAME].values[-(365*3)]     end=tts.coords[TIME_DIMNAME].values[-1]     return slice_xr_time_series(tts, start, end)  def plot_obs_vs_calc(obs, calc, ylab=\"runoff (mm)\"):     import uchronia.utils as uu     obs = last_three_years(obs)     calc = last_three_years(calc)     both = uu.xr_concat([obs,calc], ['observed','calculated'], 'type')     both.plot.line(add_legend=True, figsize=(9,4), hue=\"type\")     plt.ylabel(ylab) In\u00a0[31]: Copied! <pre>s = last_three_years(var_series)\n# , main = 'Default GR4J output on MMH data')\n</pre> s = last_three_years(var_series) # , main = 'Default GR4J output on MMH data') In\u00a0[32]: Copied! <pre>s = s.squeeze(drop=True)\n</pre> s = s.squeeze(drop=True) In\u00a0[33]: Copied! <pre>g = s.plot.line(add_legend=True, figsize=(16,16), col=\"variable_identifiers\", col_wrap=2, sharey=False)\n</pre> g = s.plot.line(add_legend=True, figsize=(16,16), col=\"variable_identifiers\", col_wrap=2, sharey=False) In\u00a0[34]: Copied! <pre>precip_id = 'subarea.Subarea.P'\nrunoff_id = 'subarea.Subarea.runoff'\nprecip = ms.get_played(precip_id)\nbaseline_runoff = ms.get_recorded(runoff_id)\n</pre> precip_id = 'subarea.Subarea.P' runoff_id = 'subarea.Subarea.runoff' precip = ms.get_played(precip_id) baseline_runoff = ms.get_recorded(runoff_id) <p>Because we are about to work on a scenario, rather than modifying <code>ms</code> we are going to keep it as a clean baseline, and create a full \"clone\" of the catchment model. This is an understated feature of <code>swift2</code>, but a cornerstone of proper scenario comparison (and help limit modelling mistakes)</p> In\u00a0[35]: Copied! <pre>ms_wetter = ms.clone()\n</pre> ms_wetter = ms.clone() In\u00a0[36]: Copied! <pre>precip_scaled = precip * 1.1\nprecip_scaled = precip_scaled.squeeze(drop=True)\nms_wetter.play_input(precip_scaled, precip_id)\nms_wetter.exec_simulation()\nrunoff_diff = ms_wetter.get_recorded(runoff_id) - baseline_runoff\n</pre> precip_scaled = precip * 1.1 precip_scaled = precip_scaled.squeeze(drop=True) ms_wetter.play_input(precip_scaled, precip_id) ms_wetter.exec_simulation() runoff_diff = ms_wetter.get_recorded(runoff_id) - baseline_runoff In\u00a0[37]: Copied! <pre>runoff_diff = runoff_diff.squeeze(drop=True)\n</pre> runoff_diff = runoff_diff.squeeze(drop=True) <p>The additional runoff depth we get with a rainfall scaled up by 10 percent is:</p> In\u00a0[38]: Copied! <pre>runoff_diff.plot(figsize=(9,4))\nplt.title('Change in runoff with precipitations scaled up by 10%')\nplt.ylabel('runoff depth change (mm/day)');\n</pre> runoff_diff.plot(figsize=(9,4)) plt.title('Change in runoff with precipitations scaled up by 10%') plt.ylabel('runoff depth change (mm/day)'); In\u00a0[39]: Copied! <pre>x4_id = 'subarea.Subarea.x4'\nx4 = ms.get_state_value(x4_id)\nx4\n</pre> x4_id = 'subarea.Subarea.x4' x4 = ms.get_state_value(x4_id) x4 Out[39]: <pre>{'subarea.Subarea.x4': 0.5}</pre> <p>The returned value for $x_4$ is in a dictionary, because <code>get_state_value</code> is vectorised and can retrieve several state values at the same time. <code>set_state_value</code> on the other hand accepts multiple types of inputs including scalars for convenience:</p> In\u00a0[40]: Copied! <pre>x4_inital = x4[x4_id]\n# Again, keep the baseline clean and work on a copy\nms_x4 = ms.clone()\n\nms_x4.set_state_value(x4_id, x4_inital*1.1)\nms_x4.exec_simulation()\nrunoff_diff = ms_x4.get_recorded(runoff_id) - baseline_runoff\n</pre> x4_inital = x4[x4_id] # Again, keep the baseline clean and work on a copy ms_x4 = ms.clone()  ms_x4.set_state_value(x4_id, x4_inital*1.1) ms_x4.exec_simulation() runoff_diff = ms_x4.get_recorded(runoff_id) - baseline_runoff <p>One effect of $x_4$ is on the lagging effect, so the difference in runoff should be overall near zero, but with local variations:</p> In\u00a0[41]: Copied! <pre>runoff_diff = runoff_diff.squeeze(drop=True)\nblah = last_three_years(runoff_diff).plot.line()\nplt.title('Change in runoff with x4 scaled up by 10%')\nplt.ylabel('runoff depth change (mm/day)');\n</pre> runoff_diff = runoff_diff.squeeze(drop=True) blah = last_three_years(runoff_diff).plot.line() plt.title('Change in runoff with x4 scaled up by 10%') plt.ylabel('runoff depth change (mm/day)'); In\u00a0[42]: Copied! <pre>obs_runoff = sample_series('MMH', 'flow') #actually, runoff depth\n</pre> obs_runoff = sample_series('MMH', 'flow') #actually, runoff depth <p>Negative data in the observed streamflow is a code for missing data. It is better to use <code>np.nan</code> in Python for this.</p> In\u00a0[43]: Copied! <pre>obs_runoff[obs_runoff &lt; -1] = np.nan\nobs_runoff = pd_series_to_xr_series(obs_runoff)\n</pre> obs_runoff[obs_runoff &lt; -1] = np.nan obs_runoff = pd_series_to_xr_series(obs_runoff) <p>Let's view the default modelled output from GR4J, overlayed with the observation</p> In\u00a0[44]: Copied! <pre>plot_obs_vs_calc(obs_runoff, baseline_runoff.squeeze(drop=True));\n</pre> plot_obs_vs_calc(obs_runoff, baseline_runoff.squeeze(drop=True)); In\u00a0[45]: Copied! <pre>s = xr_ts_start(obs_runoff)\n# Warmup:\nw = as_timestamp(s) + pd.DateOffset(years=2)\ne = xr_ts_end(obs_runoff)\nms.set_simulation_span(s, e)\n</pre> s = xr_ts_start(obs_runoff) # Warmup: w = as_timestamp(s) + pd.DateOffset(years=2) e = xr_ts_end(obs_runoff) ms.set_simulation_span(s, e) <p>We now have all the information needed to create a calibration objective using for instance the Nash-Sutcliffe Efficiency</p> In\u00a0[46]: Copied! <pre>objective = ms.create_objective(runoff_id, obs_runoff, 'NSE', w, e)\n</pre> objective = ms.create_objective(runoff_id, obs_runoff, 'NSE', w, e) <p>The variable <code>objective</code> now references an objective evaluator.</p> In\u00a0[47]: Copied! <pre>type(objective), objective\n</pre> type(objective), objective Out[47]: <pre>(swift2.classes.ObjectiveEvaluator,\n CFFI pointer handle to a native pointer of type id \"OBJECTIVE_EVALUATOR_WILA_PTR\")</pre> <p>An objective evaluator evaluates one or more goodness of fit (a.k.a. \"scores\") via the method <code>objective.get_score</code>. We need to provide a set of model parameters to evaluate the resulting scores. The utility function <code>get_free_params</code> provides a template for some models including GR4J, in the form of a pandas DataFrame</p> In\u00a0[48]: Copied! <pre>pspec_gr4j = get_free_params('GR4J')\npspec_gr4j\n</pre> pspec_gr4j = get_free_params('GR4J') pspec_gr4j Out[48]: Name Value Min Max 0 x1 650.488000 1.0 3000.0 1 x2 -0.280648 -27.0 27.0 2 x3 7.891230 1.0 660.0 3 x4 18.917200 1.0 240.0 <p>We can set some values and min/max bounds in this data frame. The min/max bounds are important for the upcoming calibration process.</p> In\u00a0[49]: Copied! <pre>pspec_gr4j.Value = [542.1981111,  -0.4127542,   7.7403390 ,  1.2388548]\npspec_gr4j.Min = [1,-30, 1,1]\npspec_gr4j.Max = [1000.0, 30, 1000, 240]\n</pre> pspec_gr4j.Value = [542.1981111,  -0.4127542,   7.7403390 ,  1.2388548] pspec_gr4j.Min = [1,-30, 1,1] pspec_gr4j.Max = [1000.0, 30, 1000, 240] In\u00a0[50]: Copied! <pre>pspec_gr4j\n</pre> pspec_gr4j Out[50]: Name Value Min Max 0 x1 542.198111 1 1000.0 1 x2 -0.412754 -30 30.0 2 x3 7.740339 1 1000.0 3 x4 1.238855 1 240.0 <p>Our model states have the prefix 'subarea.Subarea.', so we need to use this prefix in our data frame of parameters as well.</p> In\u00a0[51]: Copied! <pre>pspec_gr4j.Name = vpaste('subarea.Subarea.', pspec_gr4j.Name)\n</pre> pspec_gr4j.Name = vpaste('subarea.Subarea.', pspec_gr4j.Name) <p>We can now create a parameteriser. It can be converted back to a data frame to check its content.</p> <p>Note: we will be using the untransformed parameters for calibration for the sake of simplicity in this introductory material. In practice we should use some transformations to facilitate the calibration, and there are many features in swift2 to do so.</p> In\u00a0[52]: Copied! <pre>p = create_parameteriser('Generic', pspec_gr4j)\np.as_dataframe()\n</pre> p = create_parameteriser('Generic', pspec_gr4j) p.as_dataframe() Out[52]: Name Value Min Max 0 subarea.Subarea.x1 542.198111 1.0 1000.0 1 subarea.Subarea.x2 -0.412754 -30.0 30.0 2 subarea.Subarea.x3 7.740339 1.0 1000.0 3 subarea.Subarea.x4 1.238855 1.0 240.0 <p>Now let us check that we can indeed evaluate the goodness of fit for this parameteriser <code>p</code> using the <code>objective</code>:</p> In\u00a0[53]: Copied! <pre>score = objective.get_score(p)\nscore\n</pre> score = objective.get_score(p) score Out[53]: <pre>{'scores': {'NSE': -2.3381787784819057},\n 'sysconfig':                  Name       Value   Min     Max\n 0  subarea.Subarea.x1  542.198111   1.0  1000.0\n 1  subarea.Subarea.x2   -0.412754 -30.0    30.0\n 2  subarea.Subarea.x3    7.740339   1.0  1000.0\n 3  subarea.Subarea.x4    1.238855   1.0   240.0}</pre> <p>Our calibration objective calculator is structurally valid.</p> In\u00a0[54]: Copied! <pre>term = create_sce_termination_wila('relative standard deviation', ['0.002','0.0167'])\n</pre> term = create_sce_termination_wila('relative standard deviation', ['0.002','0.0167']) In\u00a0[55]: Copied! <pre>sce_params = get_default_sce_parameters()\nurs = create_parameter_sampler(0, p, 'urs')\noptimiser = objective.create_sce_optim_swift(term, sce_params, urs)\n</pre> sce_params = get_default_sce_parameters() urs = create_parameter_sampler(0, p, 'urs') optimiser = objective.create_sce_optim_swift(term, sce_params, urs) In\u00a0[56]: Copied! <pre>optimiser.set_calibration_logger('')\n</pre> optimiser.set_calibration_logger('') In\u00a0[57]: Copied! <pre>%%time\ncalib_results = optimiser.execute_optimisation()\n</pre> %%time calib_results = optimiser.execute_optimisation() <pre>CPU times: user 20.5 s, sys: 23.5 ms, total: 20.5 s\nWall time: 4.08 s\n</pre> <p>swift uses optimization tools that will parallelize model simulation runs if possible (i.e. if supported by the model). This may not be noticeable in this instance, but is important to scale up to larger catchment models.</p> In\u00a0[58]: Copied! <pre>opt_log = optimiser.extract_optimisation_log(fitness_name = \"NSE\")\n</pre> opt_log = optimiser.extract_optimisation_log(fitness_name = \"NSE\") In\u00a0[59]: Copied! <pre>opt_log.data.head()\n</pre> opt_log.data.head() Out[59]: Category CurrentShuffle Message NSE subarea.Subarea.x1 subarea.Subarea.x2 subarea.Subarea.x3 subarea.Subarea.x4 PointNumber 0 Initial Population Initial Population -1339.285380 947.690750 23.005202 62.217181 161.886443 1 1 Initial Population Initial Population -0.890844 174.551633 -7.280393 710.469274 96.390541 2 2 Initial Population Initial Population -0.327150 214.709001 -7.069954 124.638641 18.990489 3 3 Initial Population Initial Population -2.367463 724.720289 6.659042 930.609993 207.726829 4 4 Initial Population Initial Population -913.046415 874.130073 28.643820 126.360349 83.693269 5 In\u00a0[60]: Copied! <pre>opt_log.data.tail()\n</pre> opt_log.data.tail() Out[60]: Category CurrentShuffle Message NSE subarea.Subarea.x1 subarea.Subarea.x2 subarea.Subarea.x3 subarea.Subarea.x4 PointNumber 13967 Shuffling No 28 Shuffling No 28 0.768667 999.096491 -5.620413 91.829530 1.000574 13968 13968 Shuffling No 28 Shuffling No 28 0.768742 996.688456 -5.679336 93.670035 1.000339 13969 13969 Shuffling No 28 Shuffling No 28 0.768590 995.813747 -5.731252 95.427583 1.000443 13970 13970 Shuffling No 28 Shuffling No 28 0.768553 994.549300 -5.677011 96.570436 1.000202 13971 13971 Shuffling No 28 Best point in shuffle 0.768844 997.616573 -5.649821 92.890522 1.000003 13972 <p>Let's subset the data points to keep a subset, the points from the initial population and SCE geometric transformations (reflection, contraction, addition). We can use a regular expression pattern to do so. <code>MhData</code> is a glorified data frame, but its methods are handy to reduce tedium.</p> In\u00a0[61]: Copied! <pre>geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*') # same as default argument, but to be explicit\n</pre> geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*') # same as default argument, but to be explicit <p>Let us also rename the column names without the fully qualified prefix</p> In\u00a0[62]: Copied! <pre>p_var_ids = ['x1','x2','x3','x4']\nremap = {f'subarea.Subarea.{name}': name for name in p_var_ids}\ngeom_ops.rename_columns(remap)\n</pre> p_var_ids = ['x1','x2','x3','x4'] remap = {f'subarea.Subarea.{name}': name for name in p_var_ids} geom_ops.rename_columns(remap) In\u00a0[63]: Copied! <pre>from swift2.vis import OptimisationPlots\n\nv = OptimisationPlots(geom_ops)\n</pre> from swift2.vis import OptimisationPlots  v = OptimisationPlots(geom_ops) <p>We can see that at least one of the parameters, namely \"x1\", settled at its upper boundary of 1000:</p> In\u00a0[64]: Copied! <pre>g = v.parameter_evolution(p_var_ids[0], obj_lims=[0,1])\nplt.gcf().set_size_inches(10,8);\n</pre> g = v.parameter_evolution(p_var_ids[0], obj_lims=[0,1]) plt.gcf().set_size_inches(10,8); <p>Note that the parameter x4 also seems to have settled at its lower bound:</p> In\u00a0[65]: Copied! <pre>v.parameter_evolution(p_var_ids[3], obj_lims=[0,1])\nplt.gcf().set_size_inches(10,8);\n</pre> v.parameter_evolution(p_var_ids[3], obj_lims=[0,1]) plt.gcf().set_size_inches(10,8); <p>x4 influences the unit hydrograph, and the meaning of this parameter depends on the time step of the input series. It may be justified in this case to go below 1 for its lower bound. Also, the default maximum value 240 is typically sensible for use with hourly data, not daily, so we may want to reduce this maximum.</p> <p>So let's restart the calibration, with a larger upper bound for the x1 parameter, and adjusted x4 bounds as well:</p> In\u00a0[66]: Copied! <pre>pspec_gr4j.Max = [2500, 30, 1000, 10]\npspec_gr4j.Min = [1,-30, 1,0.2]\n</pre> pspec_gr4j.Max = [2500, 30, 1000, 10] pspec_gr4j.Min = [1,-30, 1,0.2] In\u00a0[67]: Copied! <pre>p = create_parameteriser('Generic', pspec_gr4j)\nurs = create_parameter_sampler(0, p, 'urs')\noptimiser = objective.create_sce_optim_swift(term, sce_params, urs)\ncalib_logger = optimiser.set_calibration_logger('')\ncalib_results = optimiser.execute_optimisation()\nopt_log = optimiser.extract_optimisation_log(fitness_name = \"NSE\")\n</pre> p = create_parameteriser('Generic', pspec_gr4j) urs = create_parameter_sampler(0, p, 'urs') optimiser = objective.create_sce_optim_swift(term, sce_params, urs) calib_logger = optimiser.set_calibration_logger('') calib_results = optimiser.execute_optimisation() opt_log = optimiser.extract_optimisation_log(fitness_name = \"NSE\") In\u00a0[68]: Copied! <pre>geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*') # same as default argument, but to be explicit\n</pre> geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*') # same as default argument, but to be explicit In\u00a0[69]: Copied! <pre>p_var_ids = ['x1','x2','x3','x4']\nremap = {f'subarea.Subarea.{name}': name for name in p_var_ids}\ngeom_ops.rename_columns(remap)\n</pre> p_var_ids = ['x1','x2','x3','x4'] remap = {f'subarea.Subarea.{name}': name for name in p_var_ids} geom_ops.rename_columns(remap) <p>Let's check that the parameter does not settle at the boundary anymore:</p> In\u00a0[70]: Copied! <pre>v = OptimisationPlots(geom_ops)\ng = v.parameter_evolution(p_var_ids[0], obj_lims=[0,1])\nplt.gcf().set_size_inches(10,8);\n</pre> v = OptimisationPlots(geom_ops) g = v.parameter_evolution(p_var_ids[0], obj_lims=[0,1]) plt.gcf().set_size_inches(10,8); In\u00a0[71]: Copied! <pre>v.parameter_evolution(p_var_ids[3], obj_lims=[0,1])\nplt.gcf().set_size_inches(10,8);\n</pre> v.parameter_evolution(p_var_ids[3], obj_lims=[0,1]) plt.gcf().set_size_inches(10,8); <p>Note: There are a few additional visualisation options in the R package mhplot that may be ported to python as needed.</p> <p>We can inspect further the behavior of the SCE optimiser by using facetted plots with the package seaborn.</p> In\u00a0[72]: Copied! <pre>df = geom_ops.data\n</pre> df = geom_ops.data In\u00a0[73]: Copied! <pre>grid = geom_ops.facet_plot(p_var_ids[0])\n</pre> grid = geom_ops.facet_plot(p_var_ids[0]) <p>Let's retrieve the parameter set with the best NSE, and see the resulting runoff time series. <code>calib_results</code> is a native C++ object, but its wrapper has functions to query it and extract the information wanted.</p> <p><code>calib_results</code> is the final population of parameter sets. To get the best score within it (i.e. the best fitness and associated parameters), we can use:</p> In\u00a0[74]: Copied! <pre>best_pset = calib_results.get_best_score('NSE')\n</pre> best_pset = calib_results.get_best_score('NSE') In\u00a0[75]: Copied! <pre>best_pset\n</pre> best_pset Out[75]: <pre>CFFI pointer handle to a native pointer of type id \"OBJECTIVE_SCORES_WILA_PTR\"\n\nScores:\n\n{'NSE': 0.7832225081975563}\n\nParameters:\n\n                 Name        Value   Min     Max\n0  subarea.Subarea.x1  1141.419555   1.0  2500.0\n1  subarea.Subarea.x2    -5.448833 -30.0    30.0\n2  subarea.Subarea.x3    97.579250   1.0  1000.0\n3  subarea.Subarea.x4     0.414422   0.2    10.0</pre> In\u00a0[76]: Copied! <pre>opt_log.data.tail()\n</pre> opt_log.data.tail() Out[76]: Category CurrentShuffle Message NSE subarea.Subarea.x1 subarea.Subarea.x2 subarea.Subarea.x3 subarea.Subarea.x4 PointNumber 8697 Shuffling No 17 Shuffling No 17 0.783221 1136.271566 -5.462186 97.798741 0.425679 8698 8698 Shuffling No 17 Shuffling No 17 0.783220 1140.838174 -5.423250 97.721428 0.397216 8699 8699 Shuffling No 17 Shuffling No 17 0.783218 1138.591759 -5.473618 98.148408 0.418075 8700 8700 Shuffling No 17 Shuffling No 17 0.783215 1151.965067 -5.400726 96.862435 0.463490 8701 8701 Shuffling No 17 Best point in shuffle 0.783223 1141.419555 -5.448833 97.579250 0.414422 8702 In\u00a0[77]: Copied! <pre>best_pset.apply_sys_config(ms)\nms.exec_simulation()\nplot_obs_vs_calc(obs_runoff, ms.get_recorded(runoff_id).squeeze(drop=True))\nplt.show()\n</pre> best_pset.apply_sys_config(ms) ms.exec_simulation() plot_obs_vs_calc(obs_runoff, ms.get_recorded(runoff_id).squeeze(drop=True)) plt.show() <p>Looking at the whole series over the simulation, indeed these last three years appear untypical in terms of match between observed and calculated</p> In\u00a0[78]: Copied! <pre>from swift2.vis import plot_two_series\n</pre> from swift2.vis import plot_two_series In\u00a0[79]: Copied! <pre>plot_two_series(obs_runoff, ms.get_recorded(runoff_id).squeeze(drop=True), names = ['observed','calculated'])\n</pre> plot_two_series(obs_runoff, ms.get_recorded(runoff_id).squeeze(drop=True), names = ['observed','calculated']) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/getting_started/#getting-started-with-the-swift-python-package","title":"Getting started with the swift python package\u00b6","text":""},{"location":"notebooks/getting_started/#about-this-document","title":"About this document\u00b6","text":"<p>This is a minimal but realistic simulation workflow for swift. It was ported from an original vignette in the R package <code>swift</code>. The python package <code>swift2</code> is, as of August 2023, at least at feature parity with the long established R package.</p> <p>This is the introduction 'notebook' to a python package for interacting with SWIFT. It shows one of the most basic usage, running a single model simulation. While basic, it is realistic and uses data from a study catchment.</p>"},{"location":"notebooks/getting_started/#prerequisites","title":"Prerequisites\u00b6","text":"<p>This notebook requires a working Python environment, e.g. a conda environment. See the Streamflow Forecasting landing page for information about installing the software.</p>"},{"location":"notebooks/getting_started/#imports","title":"Imports\u00b6","text":""},{"location":"notebooks/getting_started/#lumped-catchment-data-daily-data","title":"Lumped catchment data, daily data\u00b6","text":"<p>The package contains some sample data for a few Australian catchments. Note that these sample data are for documentation only and not to be used for real world applications.</p> <p>swift now has some functions to create a single subarea simulation for testing purposes, including the function <code>create_subarea_simulation</code>. While is it perfectly possible to manually build your own model simulation from scratch, for the sake of getting started quickly let's use pre-defined functions to get a model simulation ready to run. The parameters of the function should be fairly self-explanatory. But in general you can see function documentation with commands appended with the <code>?</code> string, e.g. <code>create_subarea_simulation?</code>. You can also browse the Python swift2 documentation.</p>"},{"location":"notebooks/getting_started/#time-series-data-representation","title":"Time series data representation\u00b6","text":"<p>Let us have a look at these input time series to the simulation:</p>"},{"location":"notebooks/getting_started/#model-execution","title":"Model execution\u00b6","text":"<p><code>ms</code> was configured to record model outputs, now we can execute the simulation, with its parameters set to whatever defaults it has. Note that <code>ms</code> also has a <code>check_simulation</code> method that can provide information about  obvious configuration issues when execution fails. Typically inconstent start and end dates between simulation and input time series. In this case, nothing is reported in this simple and preconfigured case.</p>"},{"location":"notebooks/getting_started/#model-outputs","title":"Model outputs\u00b6","text":""},{"location":"notebooks/getting_started/#visualising-model-states","title":"Visualising model states\u00b6","text":""},{"location":"notebooks/getting_started/#exploring-the-model-interactively","title":"Exploring the model interactively\u00b6","text":""},{"location":"notebooks/getting_started/#assessing-a-change-in-the-input-series","title":"Assessing a change in the input series\u00b6","text":"<p>As mentioned earlier, it is change to define the model simulation definition directly and interactively. The following shows how a to assign another input time series. We use a somewhat contrived example of a scaled up precipitation input series, to see what is the effect on the runoff.</p>"},{"location":"notebooks/getting_started/#assessing-the-impact-of-a-change-in-one-model-parameter","title":"Assessing the impact of a change in one model parameter\u00b6","text":""},{"location":"notebooks/getting_started/#calibration","title":"Calibration\u00b6","text":"<p>Let's now set up a calibration against the observed runoff depth for this data 'MMH', included as sample data in the package, and view it along the current default model runoff output.</p>"},{"location":"notebooks/getting_started/#defining-the-calibration","title":"Defining the calibration\u00b6","text":"<p>Before we go ahead in setting up this calibration, it is worth outlining key aspects of software architecture in <code>swift2</code> and its metaheuristics optimisation library, \"wila\" upfront.</p> <p>At a high level a calibration process conceptually needs:</p> <ul> <li>the specification of a feasible parameter space $X = x_1, x_2, ..., x_n$, typically with feasible intervals for each $x_i$</li> <li>an objective evaluation $Obj(X)$</li> <li>and an optimisation algorithm that uses $Obj$ and evaluates it on parameter values $X_p$ sampled from $X$</li> </ul> <p>Formulating a calibration in <code>swift2</code> follows this pattern. There is usually no need to explicitely handle the hydrological model, which is hidden behind $Obj$, and for some reasons this can be an unfamiliar viewpoint for many hydrologist.</p> <p>Readers interesting in modelling and optimisation framework design and implementation can read Talbi, El-Ghazali. Metaheuristics: from design to implementation. John Wiley &amp; Sons, 2009. for a comprehensive overview.</p> <p>Now let us see what these are in practice.</p> <p>Note: There are several time stamp representations in the Python ecosystem. A dependency package of the <code>swift2</code> package , cinterop, has a time series module with date-time and time series related utilities, such as <code>xr_ts_start</code>, <code>as_timestamp</code> to reduce the tedium of date-time handling. You may also already be using third-party utilities as well.</p>"},{"location":"notebooks/getting_started/#objective","title":"Objective\u00b6","text":"<p>Part of the information for the objective is over which time span we calculate the goodness of fit, usually different from the simulation length to leave period for a model warmup</p>"},{"location":"notebooks/getting_started/#feasible-parameter-space","title":"Feasible parameter space\u00b6","text":""},{"location":"notebooks/getting_started/#optimiser","title":"Optimiser\u00b6","text":"<p>To create an optimiser, we need to specify a termination criterion. There are several options available to control when an optimisation process will finish in a calibration. One of them uses the standard deviation of parameter values for population based algorithms such as the shuffled complex evolution algorithm (SCE). We can specify that the optimisation has converged once the standard deviation of each parameter (x1, x2, etc. for GR4J) is within</p>"},{"location":"notebooks/getting_started/#assessing-the-optimisation","title":"Assessing the optimisation\u00b6","text":"<p>There are facilities in the package to extract, exploit and visualise the optimisation log information.</p>"},{"location":"notebooks/getting_started/#visualising-the-optimisation-process","title":"Visualising the optimisation process\u00b6","text":""},{"location":"notebooks/getting_started/#time-series-visualisation","title":"Time series visualisation\u00b6","text":"<p>Let's apply this parameter to the original simulation, and execute it to get output runoff.</p> <p>Note, as an aside, that below for didactic purposes we see only the last 3 years of time series, while the NSE score is calculated over several more years. As it happens, the runoff prediction has a systematic negative bias over these three particular years.</p>"},{"location":"notebooks/log_likelihood/","title":"Sample code for log-likelihood calibration","text":"In\u00a0[1]: Copied! <pre>from swift2.doc_helper import pkg_versions_info\n\nprint(pkg_versions_info(\"This document was generated from a jupyter notebook\"))\n</pre> from swift2.doc_helper import pkg_versions_info  print(pkg_versions_info(\"This document was generated from a jupyter notebook\")) <pre>This document was generated from a jupyter notebook on 2025-05-16 14:18:16.115670\n    swift2 2.5.1\n    uchronia 2.6.2\n</pre> In\u00a0[2]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport xarray as xr\n</pre> import numpy as np import pandas as pd import xarray as xr In\u00a0[3]: Copied! <pre>from cinterop.timeseries import as_timestamp\nfrom swift2.doc_helper import get_free_params, sample_series, set_loglik_param_keys\nfrom swift2.parameteriser import (\n    concatenate_parameterisers,\n    create_parameter_sampler,\n    create_parameteriser,\n    create_sce_termination_wila,\n    extract_optimisation_log,\n    get_default_sce_parameters,\n    parameteriser_as_dataframe,\n    sort_by_score,\n)\nfrom swift2.simulation import create_subarea\nfrom swift2.utils import c, mk_full_data_id, paste0\nfrom swift2.vis import OptimisationPlots\n\ns = as_timestamp('1990-01-01')\ne = as_timestamp('2005-12-31')\n\nrain = sample_series('MMH', 'rain')[slice(s, e)]\nevap = sample_series('MMH', 'evap')[slice(s, e)]\nflow = sample_series('MMH', 'flow')[slice(s, e)]\n</pre> from cinterop.timeseries import as_timestamp from swift2.doc_helper import get_free_params, sample_series, set_loglik_param_keys from swift2.parameteriser import (     concatenate_parameterisers,     create_parameter_sampler,     create_parameteriser,     create_sce_termination_wila,     extract_optimisation_log,     get_default_sce_parameters,     parameteriser_as_dataframe,     sort_by_score, ) from swift2.simulation import create_subarea from swift2.utils import c, mk_full_data_id, paste0 from swift2.vis import OptimisationPlots  s = as_timestamp('1990-01-01') e = as_timestamp('2005-12-31')  rain = sample_series('MMH', 'rain')[slice(s, e)] evap = sample_series('MMH', 'evap')[slice(s, e)] flow = sample_series('MMH', 'flow')[slice(s, e)] In\u00a0[4]: Copied! <pre>rain.describe()\n</pre> rain.describe() Out[4]: <pre>count    5844.000000\nmean        3.545405\nstd         7.737554\nmin         0.000000\n25%         0.000000\n50%         0.283600\n75%         3.308775\nmax        97.645500\ndtype: float64</pre> In\u00a0[5]: Copied! <pre>flow.describe()\n</pre> flow.describe() Out[5]: <pre>count    5844.000000\nmean       -1.993059\nstd        16.361702\nmin       -99.999000\n25%         0.194400\n50%         0.438400\n75%         0.900200\nmax        17.221100\ndtype: float64</pre> <p>We need to adjust the observed flow, as the SWIFTv1 legacy missing value code is <code>-99</code>.</p> In\u00a0[6]: Copied! <pre>flow[flow &lt; 0] = np.nan\n</pre> flow[flow &lt; 0] = np.nan In\u00a0[7]: Copied! <pre>flow\n</pre> flow Out[7]: <pre>1990-01-01    0.2577\n1990-01-02    0.2459\n1990-01-03    0.2374\n1990-01-04    0.2218\n1990-01-05    0.2127\n               ...  \n2005-12-27    0.3477\n2005-12-28    0.3314\n2005-12-29    0.3333\n2005-12-30    0.3066\n2005-12-31    0.2896\nLength: 5844, dtype: float64</pre> In\u00a0[8]: Copied! <pre>ms = create_subarea('GR4J', 1.0)\nfrom cinterop.timeseries import xr_ts_end, xr_ts_start\n\ns = xr_ts_start(rain)\ne = xr_ts_end(rain)\nms.set_simulation_span(s, e)\nms.set_simulation_time_step('daily')\n</pre> ms = create_subarea('GR4J', 1.0) from cinterop.timeseries import xr_ts_end, xr_ts_start  s = xr_ts_start(rain) e = xr_ts_end(rain) ms.set_simulation_span(s, e) ms.set_simulation_time_step('daily') <p>Assign input time series</p> In\u00a0[9]: Copied! <pre>sa_name = ms.get_subarea_names()[0]\nms.play_subarea_input(rain, sa_name, \"P\")\nms.play_subarea_input(evap, sa_name, \"E\")\n</pre> sa_name = ms.get_subarea_names()[0] ms.play_subarea_input(rain, sa_name, \"P\") ms.play_subarea_input(evap, sa_name, \"E\") <p>Model variables identifiers are hierarchical, with separators '.' and '|' supported. The \"dot\" notation should now be preferred, as some R functions producing data frames may change the variable names and replace some characters with '.'.</p> In\u00a0[10]: Copied! <pre>sa_id = paste0(\"subarea.\", sa_name)\nroot_id = paste0(sa_id, \".\")\nprint(ms.get_variable_ids(sa_id))\n</pre> sa_id = paste0(\"subarea.\", sa_name) root_id = paste0(sa_id, \".\") print(ms.get_variable_ids(sa_id)) <pre>['subarea.Subarea.areaKm2', 'subarea.Subarea.P', 'subarea.Subarea.E', 'subarea.Subarea.En', 'subarea.Subarea.LAI', 'subarea.Subarea.runoff', 'subarea.Subarea.S', 'subarea.Subarea.R', 'subarea.Subarea.TWS', 'subarea.Subarea.Eactual', 'subarea.Subarea.Ps', 'subarea.Subarea.Es', 'subarea.Subarea.Pr', 'subarea.Subarea.ech1', 'subarea.Subarea.ech2', 'subarea.Subarea.Perc', 'subarea.Subarea.alpha', 'subarea.Subarea.k', 'subarea.Subarea.x1', 'subarea.Subarea.x2', 'subarea.Subarea.x3', 'subarea.Subarea.x4', 'subarea.Subarea.UHExponent', 'subarea.Subarea.PercFactor', 'subarea.Subarea.OutflowVolume', 'subarea.Subarea.OutflowRate']\n</pre> In\u00a0[11]: Copied! <pre>gr4_state_names = paste0(root_id, c('runoff', 'S', 'R', 'Perc'))\nfor name in gr4_state_names: \n    ms.record_state(name)\n</pre> gr4_state_names = paste0(root_id, c('runoff', 'S', 'R', 'Perc')) for name in gr4_state_names:      ms.record_state(name) <p>Let's check that one simulation runs fine, before we build a calibration definition.</p> In\u00a0[12]: Copied! <pre>ms.exec_simulation()\nsState = ms.get_recorded(gr4_state_names[2])\n</pre> ms.exec_simulation() sState = ms.get_recorded(gr4_state_names[2]) In\u00a0[13]: Copied! <pre>sState.plot(figsize=(10,4))\n</pre> sState.plot(figsize=(10,4)) Out[13]: <pre>[&lt;matplotlib.lines.Line2D at 0x7fa7000164d0&gt;]</pre> <p>Let's build the objective calculator that will guide the calibration process:</p> In\u00a0[14]: Copied! <pre>w = pd.Timestamp(\"1992-01-01\")\n</pre> w = pd.Timestamp(\"1992-01-01\") In\u00a0[15]: Copied! <pre>runoff_depth_varname = 'subarea.Subarea.runoff'\nmod_runoff = ms.get_recorded(runoff_depth_varname)\n# zoo::index(flow) = zoo::index(mod_runoff)\nobjective = ms.create_objective(runoff_depth_varname, flow, 'log-likelihood', w, e)\n</pre> runoff_depth_varname = 'subarea.Subarea.runoff' mod_runoff = ms.get_recorded(runoff_depth_varname) # zoo::index(flow) = zoo::index(mod_runoff) objective = ms.create_objective(runoff_depth_varname, flow, 'log-likelihood', w, e) In\u00a0[16]: Copied! <pre>mod_runoff.plot()\n</pre> mod_runoff.plot() Out[16]: <pre>[&lt;matplotlib.lines.Line2D at 0x7fa628937250&gt;]</pre> In\u00a0[17]: Copied! <pre>pspec_gr4j = get_free_params('GR4J')\npspec_gr4j.Value = c(542.1981111, -0.4127542, 7.7403390, 1.2388548)\npspec_gr4j.Min = c(1,-30, 1,1)\npspec_gr4j.Max = c(3000, 30, 1000, 240)\npspec_gr4j.Name = paste0(root_id, pspec_gr4j.Name)\n\n\nmaxobs = np.max(flow)\np = create_parameteriser(type='Generic', specs=pspec_gr4j)\nset_loglik_param_keys(a='a', b='b', m='m', s='s', ct=\"ct\", censopt='censopt')\ncensor_threshold = maxobs / 100 # TBC\ncensopt = 0.0\n\nloglik = create_parameteriser(type='no apply')\nloglik.add_to_hypercube( \n          pd.DataFrame({ \n          \"Name\": c('b','m','s','a','maxobs','ct', 'censopt'),\n          \"Min\": c(-30, 0, -10,    -20, maxobs, censor_threshold, censopt),\n          \"Max\":  c(5,   0, 10, 0, maxobs, censor_threshold, censopt),\n          \"Value\": c(-7,  0, 0,  -10, maxobs, censor_threshold, censopt),\n          }\n          ) )\np = concatenate_parameterisers(p, loglik)\np.as_dataframe()\n</pre> pspec_gr4j = get_free_params('GR4J') pspec_gr4j.Value = c(542.1981111, -0.4127542, 7.7403390, 1.2388548) pspec_gr4j.Min = c(1,-30, 1,1) pspec_gr4j.Max = c(3000, 30, 1000, 240) pspec_gr4j.Name = paste0(root_id, pspec_gr4j.Name)   maxobs = np.max(flow) p = create_parameteriser(type='Generic', specs=pspec_gr4j) set_loglik_param_keys(a='a', b='b', m='m', s='s', ct=\"ct\", censopt='censopt') censor_threshold = maxobs / 100 # TBC censopt = 0.0  loglik = create_parameteriser(type='no apply') loglik.add_to_hypercube(            pd.DataFrame({            \"Name\": c('b','m','s','a','maxobs','ct', 'censopt'),           \"Min\": c(-30, 0, -10,    -20, maxobs, censor_threshold, censopt),           \"Max\":  c(5,   0, 10, 0, maxobs, censor_threshold, censopt),           \"Value\": c(-7,  0, 0,  -10, maxobs, censor_threshold, censopt),           }           ) ) p = concatenate_parameterisers(p, loglik) p.as_dataframe() Out[17]: Name Value Min Max 0 subarea.Subarea.x1 542.198111 1.000000 3000.000000 1 subarea.Subarea.x2 -0.412754 -30.000000 30.000000 2 subarea.Subarea.x3 7.740339 1.000000 1000.000000 3 subarea.Subarea.x4 1.238855 1.000000 240.000000 4 b -7.000000 -30.000000 5.000000 5 m 0.000000 0.000000 0.000000 6 s 0.000000 -10.000000 10.000000 7 a -10.000000 -20.000000 0.000000 8 maxobs 17.221100 17.221100 17.221100 9 ct 0.172211 0.172211 0.172211 10 censopt 0.000000 0.000000 0.000000 <p>Check that the objective calculator works, at least with the default values in the feasible parameter space:</p> In\u00a0[18]: Copied! <pre>score = objective.get_score(p)\nprint(score)\n</pre> score = objective.get_score(p) print(score) <pre>{'scores': {'Log-likelihood': -1e+20}, 'sysconfig':                   Name       Value        Min          Max\n0   subarea.Subarea.x1  542.198111   1.000000  3000.000000\n1   subarea.Subarea.x2   -0.412754 -30.000000    30.000000\n2   subarea.Subarea.x3    7.740339   1.000000  1000.000000\n3   subarea.Subarea.x4    1.238855   1.000000   240.000000\n4                    b   -7.000000 -30.000000     5.000000\n5                    m    0.000000   0.000000     0.000000\n6                    s    0.000000 -10.000000    10.000000\n7                    a  -10.000000 -20.000000     0.000000\n8               maxobs   17.221100  17.221100    17.221100\n9                   ct    0.172211   0.172211     0.172211\n10             censopt    0.000000   0.000000     0.000000}\n</pre> In\u00a0[19]: Copied! <pre>mod_runoff = ms.get_recorded(runoff_depth_varname)\n</pre> mod_runoff = ms.get_recorded(runoff_depth_varname) In\u00a0[20]: Copied! <pre>from swift2.vis import plot_two_series\n</pre> from swift2.vis import plot_two_series In\u00a0[21]: Copied! <pre>plot_two_series(flow, mod_runoff, ylab=\"obs/mod runoff\", start_time = \"2000-01-01\", end_time = \"2002-12-31\", names=['observed','modelled'])\n</pre> plot_two_series(flow, mod_runoff, ylab=\"obs/mod runoff\", start_time = \"2000-01-01\", end_time = \"2002-12-31\", names=['observed','modelled']) In\u00a0[22]: Copied! <pre># term = getMaxRuntimeTermination(max_hours = 0.3/60)  # ~20 second appears enough with SWIFT binaries in Release mode\n# term = getMarginalTermination(tolerance = 1e-06, cutoff_no_improvement = 10, max_hours = 0.3/60) \nterm = create_sce_termination_wila('relative standard deviation', c('0.005',str(1/60)))\n\nsce_params = get_default_sce_parameters()\nurs = create_parameter_sampler(0, p, 'urs')\noptimiser = objective.create_sce_optim_swift(term, sce_params, urs)\ncalib_logger = optimiser.set_calibration_logger('')\n</pre> # term = getMaxRuntimeTermination(max_hours = 0.3/60)  # ~20 second appears enough with SWIFT binaries in Release mode # term = getMarginalTermination(tolerance = 1e-06, cutoff_no_improvement = 10, max_hours = 0.3/60)  term = create_sce_termination_wila('relative standard deviation', c('0.005',str(1/60)))  sce_params = get_default_sce_parameters() urs = create_parameter_sampler(0, p, 'urs') optimiser = objective.create_sce_optim_swift(term, sce_params, urs) calib_logger = optimiser.set_calibration_logger('') In\u00a0[23]: Copied! <pre>%%time \ncalib_results = optimiser.execute_optimisation()\n</pre> %%time  calib_results = optimiser.execute_optimisation() <pre>CPU times: user 5min 7s, sys: 55 ms, total: 5min 7s\nWall time: 1min\n</pre> In\u00a0[24]: Copied! <pre>opt_log = extract_optimisation_log(optimiser, fitness_name = 'Log-likelihood')\ngeom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*') \n</pre> opt_log = extract_optimisation_log(optimiser, fitness_name = 'Log-likelihood') geom_ops = opt_log.subset_by_message(pattern= 'Initial.*|Reflec.*|Contrac.*|Add.*')  In\u00a0[25]: Copied! <pre>import matplotlib.pyplot as plt\n</pre> import matplotlib.pyplot as plt In\u00a0[26]: Copied! <pre>ll_max = max(geom_ops._data['Log-likelihood'].values)\nll_min = np.median(geom_ops._data['Log-likelihood'].values)\n</pre> ll_max = max(geom_ops._data['Log-likelihood'].values) ll_min = np.median(geom_ops._data['Log-likelihood'].values) In\u00a0[27]: Copied! <pre>p_var_ids = p.as_dataframe().Name.values\nv = OptimisationPlots(geom_ops)\nfor pVar in p_var_ids:\n    g = v.parameter_evolution(pVar, obj_lims=[ll_min, ll_max])\n    plt.gcf().set_size_inches(10,8)\n</pre> p_var_ids = p.as_dataframe().Name.values v = OptimisationPlots(geom_ops) for pVar in p_var_ids:     g = v.parameter_evolution(pVar, obj_lims=[ll_min, ll_max])     plt.gcf().set_size_inches(10,8) <p>Finally, get a visual of the runoff time series with the best known parameter set (the penultimate entry in the data frame with the log of the calibration process).</p> In\u00a0[28]: Copied! <pre>sortedResults = sort_by_score(calib_results, 'Log-likelihood')\nsortedResults.as_dataframe().head().T\n</pre> sortedResults = sort_by_score(calib_results, 'Log-likelihood') sortedResults.as_dataframe().head().T Out[28]: 0 1 2 3 4 Log-likelihood 3343.112690 3343.084541 3342.887651 3342.720004 3342.680787 subarea.Subarea.x1 142.430051 142.100098 142.279668 142.892263 139.559299 subarea.Subarea.x2 -29.938630 -29.965924 -29.996436 -29.952763 -29.978160 subarea.Subarea.x3 769.340177 769.099672 770.384501 768.784223 771.748353 subarea.Subarea.x4 1.001498 1.000013 1.001017 1.001003 1.000485 b -1.217889 -1.082167 -1.142510 -1.125674 -1.143431 m 0.000000 0.000000 0.000000 0.000000 0.000000 s 0.557830 0.426453 0.472851 0.469844 0.490444 a -8.716393 -8.501980 -8.275356 -8.452939 -8.452515 maxobs 17.221100 17.221100 17.221100 17.221100 17.221100 ct 0.172211 0.172211 0.172211 0.172211 0.172211 censopt 0.000000 0.000000 0.000000 0.000000 0.000000 In\u00a0[29]: Copied! <pre>best_pset = calib_results.get_best_score('Log-likelihood').parameteriser\nbest_pset.apply_sys_config(ms)\nms.exec_simulation()\nmod_runoff = ms.get_recorded(runoff_depth_varname)\n# joki::plot_two_series(flow, mod_runoff, ylab=\"obs/mod runoff\", startTime = start(flow), endTime = end(flow))\n</pre> best_pset = calib_results.get_best_score('Log-likelihood').parameteriser best_pset.apply_sys_config(ms) ms.exec_simulation() mod_runoff = ms.get_recorded(runoff_depth_varname) # joki::plot_two_series(flow, mod_runoff, ylab=\"obs/mod runoff\", startTime = start(flow), endTime = end(flow)) In\u00a0[30]: Copied! <pre>mod_runoff\n</pre> mod_runoff Out[30]: <pre>&lt;xarray.DataArray (variable_identifiers: 1, ensemble: 1, time: 5844)&gt; Size: 47kB\narray([[[0.        , 0.        , 0.        , ..., 0.4186557 ,\n         0.41107733, 0.40372269]]], shape=(1, 1, 5844))\nCoordinates:\n  * ensemble              (ensemble) int64 8B 0\n  * time                  (time) datetime64[ns] 47kB 1990-01-01 ... 2005-12-31\n  * variable_identifiers  (variable_identifiers) object 8B 'subarea.Subarea.r...</pre>xarray.DataArray<ul><li>variable_identifiers: 1</li><li>ensemble: 1</li><li>time: 5844</li></ul><ul><li>0.0 0.0 0.0 0.0 0.0 0.0 ... 0.4428 0.4345 0.4265 0.4187 0.4111 0.4037<pre>array([[[0.        , 0.        , 0.        , ..., 0.4186557 ,\n         0.41107733, 0.40372269]]], shape=(1, 1, 5844))</pre></li><li>Coordinates: (3)<ul><li>ensemble(ensemble)int640<pre>array([0])</pre></li><li>time(time)datetime64[ns]1990-01-01 ... 2005-12-31<pre>array(['1990-01-01T00:00:00.000000000', '1990-01-02T00:00:00.000000000',\n       '1990-01-03T00:00:00.000000000', ..., '2005-12-29T00:00:00.000000000',\n       '2005-12-30T00:00:00.000000000', '2005-12-31T00:00:00.000000000'],\n      shape=(5844,), dtype='datetime64[ns]')</pre></li><li>variable_identifiers(variable_identifiers)object'subarea.Subarea.runoff'<pre>array(['subarea.Subarea.runoff'], dtype=object)</pre></li></ul></li><li>Indexes: (3)<ul><li>ensemblePandasIndex<pre>PandasIndex(Index([0], dtype='int64', name='ensemble'))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['1990-01-01', '1990-01-02', '1990-01-03', '1990-01-04',\n               '1990-01-05', '1990-01-06', '1990-01-07', '1990-01-08',\n               '1990-01-09', '1990-01-10',\n               ...\n               '2005-12-22', '2005-12-23', '2005-12-24', '2005-12-25',\n               '2005-12-26', '2005-12-27', '2005-12-28', '2005-12-29',\n               '2005-12-30', '2005-12-31'],\n              dtype='datetime64[ns]', name='time', length=5844, freq='D'))</pre></li><li>variable_identifiersPandasIndex<pre>PandasIndex(Index(['subarea.Subarea.runoff'], dtype='object', name='variable_identifiers'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[31]: Copied! <pre>mod_runoff.squeeze(drop=True).sel(time=slice(e - pd.offsets.DateOffset(years=1), e)).plot(figsize=(16,9))\n</pre> mod_runoff.squeeze(drop=True).sel(time=slice(e - pd.offsets.DateOffset(years=1), e)).plot(figsize=(16,9)) Out[31]: <pre>[&lt;matplotlib.lines.Line2D at 0x7fa6167f78d0&gt;]</pre> In\u00a0[32]: Copied! <pre>plot_two_series(flow, mod_runoff, ylab=\"obs/mod runoff\", start_time = \"2000-01-01\", end_time = \"2002-12-31\", names=['observed','modelled'])\n</pre> plot_two_series(flow, mod_runoff, ylab=\"obs/mod runoff\", start_time = \"2000-01-01\", end_time = \"2002-12-31\", names=['observed','modelled'])"},{"location":"notebooks/log_likelihood/#sample-code-for-log-likelihood-calibration","title":"Sample code for log-likelihood calibration\u00b6","text":""},{"location":"notebooks/log_likelihood/#about-this-document","title":"About this document\u00b6","text":""},{"location":"notebooks/log_likelihood/#setting-up-a-calibration-on-daily-data","title":"Setting up a calibration on daily data\u00b6","text":"<p>We will use some sample data from (MMH) included in the package</p>"},{"location":"notebooks/log_likelihood/#catchment-setup","title":"Catchment setup\u00b6","text":"<p>Let's create a single catchment setup, using daily data. We need to specify the simulation time step to be consistent with the daily input data.</p>"},{"location":"notebooks/log_likelihood/#parameterisation","title":"Parameterisation\u00b6","text":"<p>Define the feasible parameter space, using a generic parameter set for the model parameters. This is 'wrapped' by a log-likelihood parameter set with the extra parameters used in the log likelihood calculation, but which exposes all the parameters as 8 independent degrees of freedom to the optimiser.</p>"},{"location":"notebooks/log_likelihood/#calibration","title":"Calibration\u00b6","text":"<p>Build the optimiser definition, instrument with a logger.</p>"},{"location":"notebooks/log_likelihood/#parameter-plots","title":"Parameter plots\u00b6","text":""},{"location":"notebooks/meta_parameters/","title":"Calibrating tied meta parameters","text":"In\u00a0[1]: Copied! <pre>from swift2.doc_helper import pkg_versions_info\n\nprint(pkg_versions_info(\"This document was generated from a jupyter notebook\"))\n</pre> from swift2.doc_helper import pkg_versions_info  print(pkg_versions_info(\"This document was generated from a jupyter notebook\")) <pre>This document was generated from a jupyter notebook on 2025-05-16 14:19:23.724938\n    swift2 2.5.1\n    uchronia 2.6.2\n</pre> In\u00a0[2]: Copied! <pre>import os\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n</pre> import os  import matplotlib.pyplot as plt import numpy as np import pandas as pd In\u00a0[3]: Copied! <pre>from cinterop.timeseries import as_timestamp, xr_ts_end\nfrom swift2.doc_helper import (\n    configure_daily_gr4j,\n    configure_hourly_gr4j,\n    create_test_catchment_structure,\n    get_free_params,\n    gr4j_scaled_parameteriser,\n    sample_series,\n)\nfrom swift2.parameteriser import (\n    create_parameter_sampler,\n    create_sce_optim_swift,\n    get_default_sce_parameters,\n    get_marginal_termination,\n    set_calibration_logger,\n)\nfrom swift2.simulation import get_state_value, get_subarea_ids, swap_model\nfrom swift2.utils import as_xarray_series, mk_full_data_id, paste\nfrom swift2.vis import OptimisationPlots, plot_two_series\n</pre> from cinterop.timeseries import as_timestamp, xr_ts_end from swift2.doc_helper import (     configure_daily_gr4j,     configure_hourly_gr4j,     create_test_catchment_structure,     get_free_params,     gr4j_scaled_parameteriser,     sample_series, ) from swift2.parameteriser import (     create_parameter_sampler,     create_sce_optim_swift,     get_default_sce_parameters,     get_marginal_termination,     set_calibration_logger, ) from swift2.simulation import get_state_value, get_subarea_ids, swap_model from swift2.utils import as_xarray_series, mk_full_data_id, paste from swift2.vis import OptimisationPlots, plot_two_series In\u00a0[4]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[5]: Copied! <pre>loc_key = \"Ovens-Bright\"\ndaily_rain = sample_series(loc_key, \"rain\")\ndaily_pet = sample_series(loc_key, \"pet\")\ndaily_streamflow_mlday = sample_series(loc_key, \"streamflow\")\n</pre> loc_key = \"Ovens-Bright\" daily_rain = sample_series(loc_key, \"rain\") daily_pet = sample_series(loc_key, \"pet\") daily_streamflow_mlday = sample_series(loc_key, \"streamflow\") In\u00a0[6]: Copied! <pre>daily_streamflow_mlday.plot();\n</pre> daily_streamflow_mlday.plot(); In\u00a0[7]: Copied! <pre>catchment_area = 495\ndaily_runoff = daily_streamflow_mlday * 1000 * 1000 / (catchment_area * 1e6)\n</pre> catchment_area = 495 daily_runoff = daily_streamflow_mlday * 1000 * 1000 / (catchment_area * 1e6) In\u00a0[8]: Copied! <pre>daily_runoff.plot();\n</pre> daily_runoff.plot(); In\u00a0[9]: Copied! <pre>daily_cumecs = daily_streamflow_mlday * 1000 / 86400 # ML/day to m3/s\n</pre> daily_cumecs = daily_streamflow_mlday * 1000 / 86400 # ML/day to m3/s In\u00a0[10]: Copied! <pre>areas_portions = np.array([91, 95, 6, 128, 93]) # arbitrary weights.\nareas_portions = areas_portions / sum(areas_portions)\nareasKm2 = areas_portions * catchment_area\nsum(areasKm2)\n</pre> areas_portions = np.array([91, 95, 6, 128, 93]) # arbitrary weights. areas_portions = areas_portions / sum(areas_portions) areasKm2 = areas_portions * catchment_area sum(areasKm2) Out[10]: <pre>np.float64(495.0)</pre> In\u00a0[11]: Copied! <pre>summary, ms = create_test_catchment_structure(areas_km2=areasKm2)\n</pre> summary, ms = create_test_catchment_structure(areas_km2=areasKm2) In\u00a0[12]: Copied! <pre>summary\n</pre> summary Out[12]: <pre>{'node_ids': ['n1', 'n2', 'n3', 'n4', 'n5', 'n6'],\n 'node_names': ['n1_name',\n  'n2_name',\n  'n3_name',\n  'n4_name',\n  'n5_name',\n  'n6_name'],\n 'link_ids': ['lnk1', 'lnk2', 'lnk3', 'lnk4', 'lnk5'],\n 'link_names': ['lnk1_name',\n  'lnk2_name',\n  'lnk3_name',\n  'lnk4_name',\n  'lnk5_name'],\n 'from_node': ['n2', 'n5', 'n4', 'n3', 'n1'],\n 'to_node': ['n6', 'n2', 'n2', 'n4', 'n4'],\n 'areas_km2': array([109.06779661, 113.86198547,   7.19128329, 153.41404358,\n        111.46489104]),\n 'runoff_model': 'GR4J'}</pre> In\u00a0[13]: Copied! <pre>sum(areasKm2)\n</pre> sum(areasKm2) Out[13]: <pre>np.float64(495.0)</pre> In\u00a0[14]: Copied! <pre>ms = swap_model(ms, \"PureLag\", \"channel_routing\")\n</pre> ms = swap_model(ms, \"PureLag\", \"channel_routing\") <p><code>PureLag</code> has a <code>Tau</code> parameter that can be a positive floating point value. If we query the variable identifiers of one of the links now:</p> In\u00a0[15]: Copied! <pre>ms.get_variable_ids('link.lnk1')\n</pre> ms.get_variable_ids('link.lnk1') Out[15]: <pre>['link.lnk1.Length',\n 'link.lnk1.f',\n 'link.lnk1.ManningsN',\n 'link.lnk1.Slope',\n 'link.lnk1.LateralInflowRate',\n 'link.lnk1.LateralInflowVolume',\n 'link.lnk1.Tau',\n 'link.lnk1.PreviousUpstreamInflowRate',\n 'link.lnk1.PreviousLateralInflowRate',\n 'link.lnk1.PreviousOutflowRate',\n 'link.lnk1.PreviousStorage',\n 'link.lnk1.UpstreamInflowRate',\n 'link.lnk1.OutflowRate',\n 'link.lnk1.Storage',\n 'link.lnk1.InflowRate',\n 'link.lnk1.InflowVolume',\n 'link.lnk1.AdditionalInflowRate',\n 'link.lnk1.AbstractionDemandRate',\n 'link.lnk1.AbstractionSuppliedRate',\n 'link.lnk1.OutflowVolume']</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[16]: Copied! <pre>from swift2.parameteriser import create_parameteriser\np = pd.DataFrame.from_dict({\n    \"Name\": [\"Tau\"],\n    \"Value\": [0.25],\n    \"Min\": [0.25],\n    \"Max\": [0.25],\n})\npure_lag_six_hours = create_parameteriser('generic links', specs=p)\n</pre> from swift2.parameteriser import create_parameteriser p = pd.DataFrame.from_dict({     \"Name\": [\"Tau\"],     \"Value\": [0.25],     \"Min\": [0.25],     \"Max\": [0.25], }) pure_lag_six_hours = create_parameteriser('generic links', specs=p) In\u00a0[17]: Copied! <pre>ms.get_state_value('link.lnk1.Tau')\n</pre> ms.get_state_value('link.lnk1.Tau') Out[17]: <pre>{'link.lnk1.Tau': 0.0}</pre> In\u00a0[18]: Copied! <pre>pure_lag_six_hours.apply_sys_config(ms)\n</pre> pure_lag_six_hours.apply_sys_config(ms) In\u00a0[19]: Copied! <pre>ms.get_state_value('link.lnk1.Tau')\n</pre> ms.get_state_value('link.lnk1.Tau') Out[19]: <pre>{'link.lnk1.Tau': 0.25}</pre> <p>We will run over a few years and calibrate with a warmup of two years.</p> In\u00a0[20]: Copied! <pre>sa_ids = ms.get_subarea_ids()\nrainfall_ids = mk_full_data_id('subarea', sa_ids, \"P\")\nevap_ids = mk_full_data_id('subarea', sa_ids, \"E\")\n</pre> sa_ids = ms.get_subarea_ids() rainfall_ids = mk_full_data_id('subarea', sa_ids, \"P\") evap_ids = mk_full_data_id('subarea', sa_ids, \"E\") In\u00a0[21]: Copied! <pre>ms.get_state_value(rainfall_ids)\n</pre> ms.get_state_value(rainfall_ids) Out[21]: <pre>{'subarea.lnk1.P': 0.0,\n 'subarea.lnk2.P': 0.0,\n 'subarea.lnk3.P': 0.0,\n 'subarea.lnk4.P': 0.0,\n 'subarea.lnk5.P': 0.0}</pre> In\u00a0[22]: Copied! <pre>for rids in rainfall_ids:\n    ms.play_input(daily_rain, rids)\nfor evids in evap_ids:\n    ms.play_input(daily_pet, evids)\nms.set_simulation_time_step('daily')\n</pre> for rids in rainfall_ids:     ms.play_input(daily_rain, rids) for evids in evap_ids:     ms.play_input(daily_pet, evids) ms.set_simulation_time_step('daily') In\u00a0[23]: Copied! <pre>e = pd.Timestamp(\"2024-12-31\")\n\nw = e - pd.DateOffset(years=10)\ns = w - pd.DateOffset(years=2)\n\nprint(f\"Calibration run: simulation from {s} to {e}, with a warmup till {w}\")\n</pre> e = pd.Timestamp(\"2024-12-31\")  w = e - pd.DateOffset(years=10) s = w - pd.DateOffset(years=2)  print(f\"Calibration run: simulation from {s} to {e}, with a warmup till {w}\") <pre>Calibration run: simulation from 2012-12-31 00:00:00 to 2024-12-31 00:00:00, with a warmup till 2014-12-31 00:00:00\n</pre> <p>The package includes a function that flags possible inconsistencies prior to running a model (inconsistent time steps, etc.)</p> In\u00a0[24]: Copied! <pre>ms.check_simulation()\n</pre> ms.check_simulation() Out[24]: <pre>{'errors': ['subarea.lnk1.E: End 2025-02-25T00:00:00 &lt; test date not-a-date-time',\n  'subarea.lnk1.P: End 2025-02-25T00:00:00 &lt; test date not-a-date-time',\n  'subarea.lnk2.E: End 2025-02-25T00:00:00 &lt; test date not-a-date-time',\n  'subarea.lnk2.P: End 2025-02-25T00:00:00 &lt; test date not-a-date-time',\n  'subarea.lnk3.E: End 2025-02-25T00:00:00 &lt; test date not-a-date-time',\n  'subarea.lnk3.P: End 2025-02-25T00:00:00 &lt; test date not-a-date-time',\n  'subarea.lnk4.E: End 2025-02-25T00:00:00 &lt; test date not-a-date-time',\n  'subarea.lnk4.P: End 2025-02-25T00:00:00 &lt; test date not-a-date-time',\n  'subarea.lnk5.E: End 2025-02-25T00:00:00 &lt; test date not-a-date-time',\n  'subarea.lnk5.P: End 2025-02-25T00:00:00 &lt; test date not-a-date-time']}</pre> <p>We need to adjust a couple of parameters for proper operation on hourly data for the GR4 model structure.</p> <p>Wait what? The message is admitedly not the clearest, but in this case, we have not yet set a the simulation time span</p> In\u00a0[25]: Copied! <pre>ms.set_simulation_span(s, e)\n</pre> ms.set_simulation_span(s, e) <p>Now, the check can compare simulation span and time series spans, and finds no problem:</p> In\u00a0[26]: Copied! <pre>ms.check_simulation()\n</pre> ms.check_simulation() Out[26]: <pre>{'errors': []}</pre> In\u00a0[27]: Copied! <pre>configure_hourly_gr4j(ms)\nms.get_state_value(\"subarea.lnk1.UHExponent\")\n</pre> configure_hourly_gr4j(ms) ms.get_state_value(\"subarea.lnk1.UHExponent\") Out[27]: <pre>{'subarea.lnk1.UHExponent': 1.25}</pre> In\u00a0[28]: Copied! <pre>configure_daily_gr4j(ms)\nms.get_state_value(\"subarea.lnk1.UHExponent\")\n</pre> configure_daily_gr4j(ms) ms.get_state_value(\"subarea.lnk1.UHExponent\") Out[28]: <pre>{'subarea.lnk1.UHExponent': 2.5}</pre> In\u00a0[29]: Copied! <pre>ref_area = 250 # The area for which the scaling of x4 is invariant\ntime_span = 86400 # The time step of the simulation, one day is 86400 seconds\n# time_span = 3600 # if we had an hourly simulation, and hourly inputs \n</pre> ref_area = 250 # The area for which the scaling of x4 is invariant time_span = 86400 # The time step of the simulation, one day is 86400 seconds # time_span = 3600 # if we had an hourly simulation, and hourly inputs  <p>While it is possible to construct meta-parameterisers from scratch, it is tedious. The GR4J/H scaling strategy is well known and pre-implemented in <code>gr4j_scaled_parameteriser</code></p> In\u00a0[30]: Copied! <pre>p = gr4j_scaled_parameteriser(ref_area, time_span)\n</pre> p = gr4j_scaled_parameteriser(ref_area, time_span) In\u00a0[31]: Copied! <pre>print(p.as_dataframe())\n</pre> print(p.as_dataframe()) <pre>  Name  Value   Min     Max\n0   x2    1.0 -27.0    27.0\n1   x3   10.0   0.0  1000.0\n2   x4   14.0   1.0   240.0\n3   x1   44.6   1.0  1000.0\n</pre> In\u00a0[32]: Copied! <pre># set x4 bounds to be in \"days\", not hours\np_x4 = pd.DataFrame.from_dict({\n    \"Name\": [\"x4\"],\n    \"Value\": [1.0],\n    \"Min\": [0.25],\n    \"Max\": [10.0],\n})\n</pre> # set x4 bounds to be in \"days\", not hours p_x4 = pd.DataFrame.from_dict({     \"Name\": [\"x4\"],     \"Value\": [1.0],     \"Min\": [0.25],     \"Max\": [10.0], }) In\u00a0[33]: Copied! <pre>p.set_hypercube(p_x4)\np\n</pre> p.set_hypercube(p_x4) p Out[33]: <pre>  Name  Value    Min     Max\n0   x2    1.0 -27.00    27.0\n1   x3   10.0   0.00  1000.0\n2   x4    1.0   0.25    10.0\n3   x1   44.6   1.00  1000.0</pre> In\u00a0[34]: Copied! <pre>subarea_ids = paste(\"subarea\", get_subarea_ids(ms), sep=\".\")\nareas = get_state_value(ms, paste(subarea_ids, \"areaKm2\", sep=\".\"))\nareas\n</pre> subarea_ids = paste(\"subarea\", get_subarea_ids(ms), sep=\".\") areas = get_state_value(ms, paste(subarea_ids, \"areaKm2\", sep=\".\")) areas Out[34]: <pre>{'subarea.lnk1.areaKm2': 109.06779661017,\n 'subarea.lnk2.areaKm2': 113.861985472155,\n 'subarea.lnk3.areaKm2': 7.1912832929779995,\n 'subarea.lnk4.areaKm2': 153.41404358353498,\n 'subarea.lnk5.areaKm2': 111.464891041162}</pre> <p>Let us have a look at the values of the <code>x4</code> parameters in each subarea, before and after applying this meta-parameteriser <code>p</code></p> In\u00a0[35]: Copied! <pre>x4_param_ids = paste(subarea_ids, \"x4\", sep=\".\")\nget_state_value(ms, x4_param_ids)\n</pre> x4_param_ids = paste(subarea_ids, \"x4\", sep=\".\") get_state_value(ms, x4_param_ids) Out[35]: <pre>{'subarea.lnk1.x4': 0.5,\n 'subarea.lnk2.x4': 0.5,\n 'subarea.lnk3.x4': 0.5,\n 'subarea.lnk4.x4': 0.5,\n 'subarea.lnk5.x4': 0.5}</pre> In\u00a0[36]: Copied! <pre>p.apply_sys_config(ms)\nget_state_value(ms, x4_param_ids)\n</pre> p.apply_sys_config(ms) get_state_value(ms, x4_param_ids) Out[36]: <pre>{'subarea.lnk1.x4': 0.6605082788585469,\n 'subarea.lnk2.x4': 0.6748688330991586,\n 'subarea.lnk3.x4': 0.16960286899670063,\n 'subarea.lnk4.x4': 0.7833620965646346,\n 'subarea.lnk5.x4': 0.6677271629675162}</pre> <p>The values of the individual x4 parameters are scaled according to the area of subareas. The larger the catchment, the larger the routing delay, the larger <code>x4</code>. The reference area for which the scaling would be 1.0 is 250 km^2, so the closer the catchment area from 250 km^2, the closer to 1.0 the area based scaling.</p> <p>We can compose a parameter transformation, on top of the tied. It is typical to calibrate on log(x4) rather than x4</p> In\u00a0[37]: Copied! <pre>p = p.wrap_transform()\np.add_transform(\"log_x4\", \"x4\", \"log10\")\n</pre> p = p.wrap_transform() p.add_transform(\"log_x4\", \"x4\", \"log10\") In\u00a0[38]: Copied! <pre>p\n</pre> p Out[38]: <pre>     Name  Value       Min     Max\n0  log_x4    0.0  -0.60206     1.0\n1      x2    1.0 -27.00000    27.0\n2      x3   10.0   0.00000  1000.0\n3      x1   44.6   1.00000  1000.0</pre> In\u00a0[39]: Copied! <pre>outflowVarname = \"Catchment.StreamflowRate\"\nms.record_state(outflowVarname)\n</pre> outflowVarname = \"Catchment.StreamflowRate\" ms.record_state(outflowVarname) In\u00a0[40]: Copied! <pre>ms.exec_simulation()\ncalc = ms.get_recorded(outflowVarname)\n</pre> ms.exec_simulation() calc = ms.get_recorded(outflowVarname) In\u00a0[41]: Copied! <pre>flow = as_xarray_series(daily_cumecs)\n</pre> flow = as_xarray_series(daily_cumecs) In\u00a0[42]: Copied! <pre>vis_e = as_timestamp(xr_ts_end(flow))\nvis_s = vis_e - pd.DateOffset(years=3)\n\nplot_two_series(flow, calc, names=[\"Observed\", \"Calculated\"], start_time=vis_s, end_time=vis_e)\n</pre> vis_e = as_timestamp(xr_ts_end(flow)) vis_s = vis_e - pd.DateOffset(years=3)  plot_two_series(flow, calc, names=[\"Observed\", \"Calculated\"], start_time=vis_s, end_time=vis_e) In\u00a0[43]: Copied! <pre>objective = ms.create_objective(outflowVarname, flow, \"NSE\", w, e)\nscore = objective.get_score(p)\nprint(score)\n</pre> objective = ms.create_objective(outflowVarname, flow, \"NSE\", w, e) score = objective.get_score(p) print(score) <pre>{'scores': {'NSE': -5.5724317674396335}, 'sysconfig':      Name  Value       Min     Max\n0  log_x4    0.0  -0.60206     1.0\n1      x2    1.0 -27.00000    27.0\n2      x3   10.0   0.00000  1000.0\n3      x1   44.6   1.00000  1000.0}\n</pre> <p>We have our objectives defined, and the parameter space 'p' in which to search. Let's create an optimiser and we are ready to go. While the optimiser can be created in one line, we show how to choose one custom termination criterion and how to configure the optimiser to capture a detailed log of the process.</p> In\u00a0[44]: Copied! <pre>if \"SWIFT_FULL\" in os.environ.keys():\n    max_hours = 0.2\nelse:\n    max_hours = 0.02\n\nterm = get_marginal_termination(tolerance = 1e-05, cutoff_no_improvement = 30, max_hours = max_hours)\n# term = get_max_runtime_termination(max_hours=max_hours)\nsce_params = get_default_sce_parameters()\nurs = create_parameter_sampler(0, p, \"urs\")\noptimiser = create_sce_optim_swift(objective, term, sce_params, urs)\ncalib_logger = set_calibration_logger(optimiser, \"\")\n</pre> if \"SWIFT_FULL\" in os.environ.keys():     max_hours = 0.2 else:     max_hours = 0.02  term = get_marginal_termination(tolerance = 1e-05, cutoff_no_improvement = 30, max_hours = max_hours) # term = get_max_runtime_termination(max_hours=max_hours) sce_params = get_default_sce_parameters() urs = create_parameter_sampler(0, p, \"urs\") optimiser = create_sce_optim_swift(objective, term, sce_params, urs) calib_logger = set_calibration_logger(optimiser, \"\") <p>At this point you may want to specify the maximum number of cores that can be used by the optimiser, for instance if you wish to keep one core free to work in parallel on something else.</p> In\u00a0[45]: Copied! <pre>sce_params\n</pre> sce_params Out[45]: <pre>{'P': 6,\n 'Pmin': 6,\n 'M': 9,\n 'Q': 7,\n 'Alpha': 1,\n 'Beta': 9,\n 'NumShuffle': 40,\n 'TrapezoidalDensityParameter': 1.0,\n 'ReflectionRatio': -1.0,\n 'ContractionRatio': 0.5}</pre> <p>The number of complexes is 6; by default the optimiser will try to use 6 CPU cores in parallel, or n-1 where N is your number of cores and less than 6. It is possible to limit the level of parallelism if needed, for instance to make sure you have a few cores to work with if an optimiser will run for some time.</p> In\u00a0[46]: Copied! <pre>optimiser.set_maximum_threads_free_cores(2)\n</pre> optimiser.set_maximum_threads_free_cores(2) In\u00a0[47]: Copied! <pre>%%time\ncalib_results = optimiser.execute_optimisation()\n</pre> %%time calib_results = optimiser.execute_optimisation() <pre>CPU times: user 1min 24s, sys: 18.1 ms, total: 1min 24s\nWall time: 16.8 s\n</pre> <p>Processing the calibration log below. We subset the full log to keep only some types of optimiser messages, in this case we do not keep the \"shuffling\" stages of the SCE algorithm.</p> In\u00a0[48]: Copied! <pre>opt_log = optimiser.extract_optimisation_log(fitness_name=\"NSE\")\ngeom_ops = opt_log.subset_by_message(pattern=\"Initial.*|Reflec.*|Contrac.*|Add.*\")\n</pre> opt_log = optimiser.extract_optimisation_log(fitness_name=\"NSE\") geom_ops = opt_log.subset_by_message(pattern=\"Initial.*|Reflec.*|Contrac.*|Add.*\") <p>We can then visualize how the calibration evolved. There are several types of visualisations included in the mhplot package, and numerous customizations possible, but starting with the overall population evolution:</p> In\u00a0[49]: Copied! <pre>geom_ops._data[\"NSE\"].describe()\n</pre> geom_ops._data[\"NSE\"].describe() Out[49]: <pre>count    4338.000000\nmean        0.244160\nstd        17.961405\nmin      -911.455996\n25%         0.832471\n50%         0.834778\n75%         0.834778\nmax         0.834778\nName: NSE, dtype: float64</pre> In\u00a0[50]: Copied! <pre>p_var_ids = p.as_dataframe().Name.values\np_var_ids\n</pre> p_var_ids = p.as_dataframe().Name.values p_var_ids Out[50]: <pre>array(['log_x4', 'x2', 'x3', 'x1'], dtype=object)</pre> In\u00a0[51]: Copied! <pre>v = OptimisationPlots(geom_ops)\nfor pVarId in p_var_ids:\n    v.parameter_evolution(pVarId, obj_lims=[0, 1])\n    plt.gcf().set_size_inches(10, 8)\n</pre> v = OptimisationPlots(geom_ops) for pVarId in p_var_ids:     v.parameter_evolution(pVarId, obj_lims=[0, 1])     plt.gcf().set_size_inches(10, 8) In\u00a0[52]: Copied! <pre># sortedResults = sortByScore(calib_results, 'NSE')\n# best_pset = getScoreAtIndex(sortedResults, 1)\n# best_pset = GetSystemConfigurationWila_R(best_pset)\n</pre> # sortedResults = sortByScore(calib_results, 'NSE') # best_pset = getScoreAtIndex(sortedResults, 1) # best_pset = GetSystemConfigurationWila_R(best_pset) In\u00a0[53]: Copied! <pre>best_pset = calib_results.get_best_score(\"NSE\").parameteriser\n</pre> best_pset = calib_results.get_best_score(\"NSE\").parameteriser <p>swift can back-transform a parameters to obtain the untransformed parameter set(s):</p> In\u00a0[54]: Copied! <pre>best_pset\n</pre> best_pset Out[54]: <pre>     Name       Value       Min     Max\n0  log_x4    0.191326  -0.60206     1.0\n1      x2    2.389509 -27.00000    27.0\n2      x3   93.649563   0.00000  1000.0\n3      x1  633.394708   1.00000  1000.0</pre> In\u00a0[55]: Copied! <pre>untfPset = best_pset.backtransform()\nscore = objective.get_score(best_pset)\nscore\n</pre> untfPset = best_pset.backtransform() score = objective.get_score(best_pset) score Out[55]: <pre>{'scores': {'NSE': 0.8347778235911274},\n 'sysconfig':      Name       Value       Min     Max\n 0  log_x4    0.191326  -0.60206     1.0\n 1      x2    2.389509 -27.00000    27.0\n 2      x3   93.649563   0.00000  1000.0\n 3      x1  633.394708   1.00000  1000.0}</pre> In\u00a0[56]: Copied! <pre>score = objective.get_score(untfPset)\nscore\n</pre> score = objective.get_score(untfPset) score Out[56]: <pre>{'scores': {'NSE': 0.8347778235911274},\n 'sysconfig':   Name       Value    Min     Max\n 0   x2    2.389509 -27.00    27.0\n 1   x3   93.649563   0.00  1000.0\n 2   x4    1.553554   0.25    10.0\n 3   x1  633.394708   1.00  1000.0}</pre> <p>Finally, let's have a visual of the fitted streamflow data at Bright:</p> In\u00a0[57]: Copied! <pre>best_pset.apply_sys_config(ms)\nms.exec_simulation()\nmod_runoff = ms.get_recorded(outflowVarname)\n</pre> best_pset.apply_sys_config(ms) ms.exec_simulation() mod_runoff = ms.get_recorded(outflowVarname) In\u00a0[58]: Copied! <pre>plot_two_series(\n    flow, mod_runoff, start_time=vis_s, end_time=vis_e, names=[\"observed\", \"modelled\"]\n)\n</pre> plot_two_series(     flow, mod_runoff, start_time=vis_s, end_time=vis_e, names=[\"observed\", \"modelled\"] ) In\u00a0[59]: Copied! <pre># runoff = flow / sum(areasKm2)\n# runoff.plot()\n\n# plot_two_series(\n#     rainfall, runoff, start_time=vis_s, end_time=vis_e, names=[\"observed rain\", \"observed runoff\"]\n# )\n</pre> # runoff = flow / sum(areasKm2) # runoff.plot()  # plot_two_series( #     rainfall, runoff, start_time=vis_s, end_time=vis_e, names=[\"observed rain\", \"observed runoff\"] # ) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/meta_parameters/#calibrating-tied-meta-parameters","title":"Calibrating tied meta parameters\u00b6","text":""},{"location":"notebooks/meta_parameters/#about-this-document","title":"About this document\u00b6","text":"<p>This document illustrates how to set up a calibration where a global parameterization is set at the catchment level, with scaled values for each subareas. This method helps to keep the degrees of freedom of an optimisation to a minimum.</p>"},{"location":"notebooks/meta_parameters/#use-case-and-sample-data","title":"Use case and sample data\u00b6","text":"<p>This workflow uses for convenience hourly time series data gathered a decade ago. The data comes from the Ovens River catchment, however the provenance is unclear</p>"},{"location":"notebooks/meta_parameters/#imports","title":"Imports\u00b6","text":""},{"location":"notebooks/meta_parameters/#data","title":"Data\u00b6","text":"<p>The sample data for this tutorial are daily series for the Ovens Catchment in Victoria. Daily streamflow was sourced from https://data.water.vic.gov.au/ at Bright (VIC), and rainfall and morton PET were sourced from  https://www.longpaddock.qld.gov.au/silo/point-data/  at Eurobin (VIC). Note that Eurobin is a bit downstream from Bright and perhaps not the \"best\" point climate data, but this works for this present vignette.</p>"},{"location":"notebooks/meta_parameters/#creating-a-synthetic-but-realistic-model","title":"Creating a synthetic but realistic model\u00b6","text":"<p>We create a system with total area similar to the real use case, but we use an arbitrary test catchment structure (multiple subareas). This is suitable for this tutorial.</p>"},{"location":"notebooks/meta_parameters/#channel-routing","title":"channel routing\u00b6","text":"<p>This is besides the main point of this tutorial, but let's take a detour showing how to set up a uniform channel routing using a pure lag routing.</p>"},{"location":"notebooks/meta_parameters/#assign-simulation-inputs","title":"Assign simulation inputs\u00b6","text":""},{"location":"notebooks/meta_parameters/#define-a-calibration-time-span","title":"Define a calibration time span\u00b6","text":"<p>We define a calibration with objective calculation over 10 years, plus a 2-year warmup period</p>"},{"location":"notebooks/meta_parameters/#gr4j-gr4h-modes","title":"GR4J (GR4H) modes\u00b6","text":"<p>GR4J (j for \"journalier\" i.e. \"daily\") and GR4H (h for hourly) differ by the values of tso parameters. There are two helper functions to switch modes on all GR4J models in the system</p>"},{"location":"notebooks/meta_parameters/#feasible-parameter-space-and-parsimony","title":"Feasible parameter space and parsimony\u00b6","text":"<p>We have a catchment with 5 subareas, with GR4J. Leaving outside the links which we will not calibrate, this still means 20 parameters overall to calibrate. This can be problematic as there is likely an inflated parameter equifinality (many different combinations leading to sensibly similar performances), and the resulting parameters may not be robust or physically sensible.</p> <p>Instead, we can define a meta parameter set with only 4 degrees of freedom, with area scaling applied to x4 and time scaling applied to x2 and x3. The time scaling makes it invariant if the simulation time step changes from daily to hourly, but in this sample the most telling scaling is the one for the \"lag parameter\" <code>x4</code>. A single <code>x4</code> meta-parameter is reflected in each subarea with values than are scaled according to a function (square root) of the unit's area. Intuitively, it makes sense that the bigger the subarea, the longer the flow routing lag.</p>"},{"location":"notebooks/meta_parameters/#optimiser","title":"Optimiser\u00b6","text":"<p>Let'c create an NSE evaluator, and check what the default parameter set yields as a goodness of fit.</p>"},{"location":"notebooks/muskingum_multilink_calibration/","title":"Linear Muskingum channel routing model - constrained subcatchment calibration","text":"In\u00a0[1]: Copied! <pre>from swift2.doc_helper import pkg_versions_info\n\nprint(pkg_versions_info(\"This document was generated from a jupyter notebook\"))\n</pre> from swift2.doc_helper import pkg_versions_info  print(pkg_versions_info(\"This document was generated from a jupyter notebook\")) <pre>This document was generated from a jupyter notebook on 2025-05-16 14:19:45.850631\n    swift2 2.5.1\n    uchronia 2.6.2\n</pre> In\u00a0[2]: Copied! <pre>import datetime as dt\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n</pre> import datetime as dt  import matplotlib.pyplot as plt import numpy as np import pandas as pd In\u00a0[3]: Copied! <pre>import seaborn as sns\n</pre> import seaborn as sns In\u00a0[4]: Copied! <pre>import swift2\nimport swift2.wrap.swift_wrap_custom as swc\n</pre> import swift2 import swift2.wrap.swift_wrap_custom as swc In\u00a0[5]: Copied! <pre># Only temporary, under construction...\nimport swift2.wrap.swift_wrap_generated as swg\nimport xarray as xr\n</pre> # Only temporary, under construction... import swift2.wrap.swift_wrap_generated as swg import xarray as xr In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[6]: Copied! <pre>from cinterop.timeseries import (\n    TIME_DIMNAME,\n    pd_series_to_xr_series,\n    slice_xr_time_series,\n    xr_ts_end,\n    xr_ts_start,\n)\n</pre> from cinterop.timeseries import (     TIME_DIMNAME,     pd_series_to_xr_series,     slice_xr_time_series,     xr_ts_end,     xr_ts_start, ) In\u00a0[7]: Copied! <pre>from swift2.doc_helper import *\nfrom swift2.parameteriser import *\nfrom swift2.play_record import *\nfrom swift2.simulation import *\nfrom swift2.statistics import *\nfrom swift2.system import *\nfrom swift2.utils import *\n\n# from swift2.prototypes import extract_optimisation_log\nfrom uchronia.time_series import get_item\n</pre> from swift2.doc_helper import * from swift2.parameteriser import * from swift2.play_record import * from swift2.simulation import * from swift2.statistics import * from swift2.system import * from swift2.utils import *  # from swift2.prototypes import extract_optimisation_log from uchronia.time_series import get_item In\u00a0[8]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline <p>For this example we will use data derived from the South Esk catchment in Tasmania.</p> In\u00a0[9]: Copied! <pre>model_id = 'GR4J'\nsite_id = 'South_Esk'\nsimulation = sample_catchment_model(site_id=site_id, config_id='catchment')\nsimulation = swap_model(simulation, 'MuskingumNonLinear', 'channel_routing')\n\n# # revert back to derfautl values as expected from sample simulation..\n# sc = 1 # reach slope in m/m\n# n = 1  # default Manning's parameter value for the reach\n# f = 1  # \"Fudge factor\" to allow for a different range of Alpha values. \n# oneHour = 1\n# delt = oneHour\n\nse_climate = sample_series(site_id=site_id, var_name='climate')\nse_flows = sample_series(site_id=site_id, var_name='flow')\n\nplay_input(simulation, se_climate)\nset_simulation_span(simulation, xr_ts_start(se_climate), xr_ts_end(se_climate))\nset_simulation_time_step(simulation, 'hourly')\nconfigure_hourly_gr4j(simulation)\n</pre> model_id = 'GR4J' site_id = 'South_Esk' simulation = sample_catchment_model(site_id=site_id, config_id='catchment') simulation = swap_model(simulation, 'MuskingumNonLinear', 'channel_routing')  # # revert back to derfautl values as expected from sample simulation.. # sc = 1 # reach slope in m/m # n = 1  # default Manning's parameter value for the reach # f = 1  # \"Fudge factor\" to allow for a different range of Alpha values.  # oneHour = 1 # delt = oneHour  se_climate = sample_series(site_id=site_id, var_name='climate') se_flows = sample_series(site_id=site_id, var_name='flow')  play_input(simulation, se_climate) set_simulation_span(simulation, xr_ts_start(se_climate), xr_ts_end(se_climate)) set_simulation_time_step(simulation, 'hourly') configure_hourly_gr4j(simulation) <p>We can get a topologic view of the model setup (albeit crowded as this is a fairly large catchment).</p> <p>(Note: may not render yet through GitHub)</p> In\u00a0[10]: Copied! <pre># TODO:\n# from graphviz import Digraph\n# DiagrammeR(GetCatchmentDOTGraph_R(simulation))\n</pre> # TODO: # from graphviz import Digraph # DiagrammeR(GetCatchmentDOTGraph_R(simulation)) <p>We cookie cut to get a subcatchment near the headwaters.</p> In\u00a0[11]: Copied! <pre>from swift2.model_definitions import *\n\n# from graphviz import Digraph\n\nsubsim = subset_catchment(simulation, 'node.5')\nsubsim\n</pre> from swift2.model_definitions import *  # from graphviz import Digraph  subsim = subset_catchment(simulation, 'node.5') subsim Out[11]: <pre>Simulation wrapper for a CFFI pointer handle to a native pointer of type id \"MODEL_SIMULATION_PTR\"</pre> In\u00a0[12]: Copied! <pre>dot_graph = swg.GetCatchmentDOTGraph_py(subsim)\n</pre> dot_graph = swg.GetCatchmentDOTGraph_py(subsim) <p>We configure the routing scheme to be linear (parameter N set and fixed to 1)</p> In\u00a0[13]: Copied! <pre>link_ids = mk_full_data_id('link', get_link_ids(subsim))\nset_state_value(subsim, mk_full_data_id(link_ids, 'N'), rep(1.0, len(link_ids)))\n</pre> link_ids = mk_full_data_id('link', get_link_ids(subsim)) set_state_value(subsim, mk_full_data_id(link_ids, 'N'), rep(1.0, len(link_ids))) <p>Let's have a look at the link properties and other default routing parameters</p> In\u00a0[14]: Copied! <pre>lnkpnames = ['Length', 'f', 'ManningsN', 'Slope', 'N', 'X', 'Alpha']\nget_state_value(subsim,mk_full_data_id('link.1', lnkpnames))\n</pre> lnkpnames = ['Length', 'f', 'ManningsN', 'Slope', 'N', 'X', 'Alpha'] get_state_value(subsim,mk_full_data_id('link.1', lnkpnames)) Out[14]: <pre>{'link.1.Length': 6140.0,\n 'link.1.f': 1.0,\n 'link.1.ManningsN': 1.0,\n 'link.1.Slope': 1.0,\n 'link.1.N': 1.0,\n 'link.1.X': 0.1,\n 'link.1.Alpha': 1.0}</pre> <p>X is between 0 and 0.5, without stability constraints. Setting a default Alpha is... trickier.</p> In\u00a0[15]: Copied! <pre>set_state_value(subsim, mk_full_data_id(link_ids, 'X'), rep(1e-6, len(link_ids)))\nset_state_value(subsim, mk_full_data_id(link_ids, 'Alpha'), rep(0.0005, len(link_ids)))\n</pre> set_state_value(subsim, mk_full_data_id(link_ids, 'X'), rep(1e-6, len(link_ids))) set_state_value(subsim, mk_full_data_id(link_ids, 'Alpha'), rep(0.0005, len(link_ids))) <p>If we look at the subcatchment outflow in this configuration, it is a series of unfeasible values - at least one link was in an unfeasible zone for (Alpha, X)</p> In\u00a0[16]: Copied! <pre>from swift2.const import CATCHMENT_FLOWRATE_VARID\n\nvar_id = CATCHMENT_FLOWRATE_VARID\ncatOutflowId = 'subarea.1.OutflowRate'\n\nrecord_state(subsim,var_id)\nrecord_state(subsim,catOutflowId)\n\nexec_simulation(subsim)\nsomeFlow = get_recorded(subsim, var_id)\n</pre> from swift2.const import CATCHMENT_FLOWRATE_VARID  var_id = CATCHMENT_FLOWRATE_VARID catOutflowId = 'subarea.1.OutflowRate'  record_state(subsim,var_id) record_state(subsim,catOutflowId)  exec_simulation(subsim) someFlow = get_recorded(subsim, var_id) In\u00a0[17]: Copied! <pre>someFlow.head()\n</pre> someFlow.head() Out[17]: <pre>&lt;xarray.DataArray (variable_identifiers: 1, ensemble: 1, time: 5)&gt; Size: 40B\narray([[[0., 0., 0., 0., 0.]]])\nCoordinates:\n  * ensemble              (ensemble) int64 8B 0\n  * time                  (time) datetime64[ns] 40B 2010-11-01 ... 2010-11-01...\n  * variable_identifiers  (variable_identifiers) object 8B 'Catchment.Streamf...</pre>xarray.DataArray<ul><li>variable_identifiers: 1</li><li>ensemble: 1</li><li>time: 5</li></ul><ul><li>0.0 0.0 0.0 0.0 0.0<pre>array([[[0., 0., 0., 0., 0.]]])</pre></li><li>Coordinates: (3)<ul><li>ensemble(ensemble)int640<pre>array([0])</pre></li><li>time(time)datetime64[ns]2010-11-01 ... 2010-11-01T04:00:00<pre>array(['2010-11-01T00:00:00.000000000', '2010-11-01T01:00:00.000000000',\n       '2010-11-01T02:00:00.000000000', '2010-11-01T03:00:00.000000000',\n       '2010-11-01T04:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>variable_identifiers(variable_identifiers)object'Catchment.StreamflowRate'<pre>array(['Catchment.StreamflowRate'], dtype=object)</pre></li></ul></li><li>Indexes: (3)<ul><li>ensemblePandasIndex<pre>PandasIndex(Index([0], dtype='int64', name='ensemble'))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2010-11-01 00:00:00', '2010-11-01 01:00:00',\n               '2010-11-01 02:00:00', '2010-11-01 03:00:00',\n               '2010-11-01 04:00:00'],\n              dtype='datetime64[ns]', name='time', freq='h'))</pre></li><li>variable_identifiersPandasIndex<pre>PandasIndex(Index(['Catchment.StreamflowRate'], dtype='object', name='variable_identifiers'))</pre></li></ul></li><li>Attributes: (0)</li></ul> <p>We can double-check that the subarea does produce runoff yield; the links are where the model does not work yet.</p> In\u00a0[18]: Copied! <pre>get_state_value(subsim, get_variable_ids(subsim, 'node.5'))\n</pre> get_state_value(subsim, get_variable_ids(subsim, 'node.5')) Out[18]: <pre>{'node.5.InflowRate': 7.942047038196456e-05,\n 'node.5.InflowVolume': 0.28591369337507244,\n 'node.5.AdditionalInflowRate': 0.0,\n 'node.5.AbstractionDemandRate': 0.0,\n 'node.5.AbstractionSuppliedRate': 0.0,\n 'node.5.OutflowRate': 7.942047038196456e-05,\n 'node.5.OutflowVolume': 0.28591369337507244}</pre> In\u00a0[19]: Copied! <pre>get_recorded(subsim, catOutflowId).head()\n</pre> get_recorded(subsim, catOutflowId).head() Out[19]: <pre>&lt;xarray.DataArray (variable_identifiers: 1, ensemble: 1, time: 5)&gt; Size: 40B\narray([[[0., 0., 0., 0., 0.]]])\nCoordinates:\n  * ensemble              (ensemble) int64 8B 0\n  * time                  (time) datetime64[ns] 40B 2010-11-01 ... 2010-11-01...\n  * variable_identifiers  (variable_identifiers) object 8B 'subarea.1.Outflow...</pre>xarray.DataArray<ul><li>variable_identifiers: 1</li><li>ensemble: 1</li><li>time: 5</li></ul><ul><li>0.0 0.0 0.0 0.0 0.0<pre>array([[[0., 0., 0., 0., 0.]]])</pre></li><li>Coordinates: (3)<ul><li>ensemble(ensemble)int640<pre>array([0])</pre></li><li>time(time)datetime64[ns]2010-11-01 ... 2010-11-01T04:00:00<pre>array(['2010-11-01T00:00:00.000000000', '2010-11-01T01:00:00.000000000',\n       '2010-11-01T02:00:00.000000000', '2010-11-01T03:00:00.000000000',\n       '2010-11-01T04:00:00.000000000'], dtype='datetime64[ns]')</pre></li><li>variable_identifiers(variable_identifiers)object'subarea.1.OutflowRate'<pre>array(['subarea.1.OutflowRate'], dtype=object)</pre></li></ul></li><li>Indexes: (3)<ul><li>ensemblePandasIndex<pre>PandasIndex(Index([0], dtype='int64', name='ensemble'))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2010-11-01 00:00:00', '2010-11-01 01:00:00',\n               '2010-11-01 02:00:00', '2010-11-01 03:00:00',\n               '2010-11-01 04:00:00'],\n              dtype='datetime64[ns]', name='time', freq='h'))</pre></li><li>variable_identifiersPandasIndex<pre>PandasIndex(Index(['subarea.1.OutflowRate'], dtype='object', name='variable_identifiers'))</pre></li></ul></li><li>Attributes: (0)</li></ul> <p>So, given that each routing link parameters Alpha and X are subject to constraint that vary depending on 'Length', 'f', 'ManningsN', 'Slope', how do we get a pair (Alpha, X) that globaly respect these constraints? This is not complex science but complicated enough to get wrong.</p> <p>'swift' offers facilities to remove the error prone tedium. First, <code>feasibleMuskingumBounds</code> lists the extremas of the feasible (Alpha, X) parameter space.</p> In\u00a0[20]: Copied! <pre>akbounds = feasible_muskingum_bounds(subsim, 1)\nakbounds\n</pre> akbounds = feasible_muskingum_bounds(subsim, 1) akbounds Out[20]: <pre>{'min_alpha': np.float64(0.08143322475570032),\n 'max_x': np.float64(0.37382039573820397),\n 'alpha_for_max_x': np.float64(0.13004771187286124)}</pre> <p>The numbers above can play a crucial role when setting up an optimiser for this model; more on this soon.</p> In\u00a0[21]: Copied! <pre>oneHour = 1\n\npSpecMusk = pd.DataFrame(dict(Name = ['X', 'Alpha'],\n  Value = [akbounds['max_x'] / 2, akbounds['alpha_for_max_x']],\n  Min= [1.0E-06, akbounds['min_alpha']],   \n  Max = [akbounds['max_x'], 1e5]) \n)\n\n# Basic parameteriser\ndef pzm(simulation, pSpecs=pSpecMusk):\n    akbounds = feasible_muskingum_bounds(simulation, 1)\n    p_musk = create_parameteriser('generic links',pSpecs)\n    return p_musk\n\n# Wrapper parameteriser, with constraints added around.\ndef pzc(simulation, pSpecs=pSpecMusk):\n    p_musk = pzm(simulation, pSpecs)\n    p_musk_c = create_muskingum_param_constraints(p_musk, oneHour, \"Alpha\", \"X\", simulation)\n    return p_musk_c\n\n\npp = parameteriser_as_dataframe\n</pre>  oneHour = 1  pSpecMusk = pd.DataFrame(dict(Name = ['X', 'Alpha'],   Value = [akbounds['max_x'] / 2, akbounds['alpha_for_max_x']],   Min= [1.0E-06, akbounds['min_alpha']],      Max = [akbounds['max_x'], 1e5])  )  # Basic parameteriser def pzm(simulation, pSpecs=pSpecMusk):     akbounds = feasible_muskingum_bounds(simulation, 1)     p_musk = create_parameteriser('generic links',pSpecs)     return p_musk  # Wrapper parameteriser, with constraints added around. def pzc(simulation, pSpecs=pSpecMusk):     p_musk = pzm(simulation, pSpecs)     p_musk_c = create_muskingum_param_constraints(p_musk, oneHour, \"Alpha\", \"X\", simulation)     return p_musk_c   pp = parameteriser_as_dataframe In\u00a0[22]: Copied! <pre>pp(pzm(subsim))\n</pre> pp(pzm(subsim)) Out[22]: Name Value Min Max 0 X 0.186910 0.000001 0.37382 1 Alpha 0.130048 0.081433 100000.00000 In\u00a0[23]: Copied! <pre>p = pzc(subsim)\npp(p)\n</pre> p = pzc(subsim) pp(p) Out[23]: Name Value Min Max 0 X 0.186910 0.000001 0.373820 1 Alpha 0.130048 0.100153 0.260095 <p>Let's get a trace of the subcatchment outflow, as a synthetic data to calibrated against.</p> In\u00a0[24]: Copied! <pre>apply_sys_config(p, subsim)\nexec_simulation(subsim)\nsomeFlow = get_recorded(subsim, var_id)\n</pre> apply_sys_config(p, subsim) exec_simulation(subsim) someFlow = get_recorded(subsim, var_id) In\u00a0[25]: Copied! <pre>someFlow.to_series().describe()\n</pre> someFlow.to_series().describe() Out[25]: <pre>count    4.800000e+02\nmean     6.164971e-03\nstd      2.694368e-02\nmin      0.000000e+00\n25%      8.691205e-07\n50%      8.687524e-05\n75%      6.349944e-04\nmax      2.682614e-01\ndtype: float64</pre> <p>We do now get a valid outflow since (Alpha-K) respects feasibility constraints on all links.</p> In\u00a0[26]: Copied! <pre>someFlow.plot();\n</pre> someFlow.plot(); In\u00a0[27]: Copied! <pre>def c(*args):\n    return np.array([x for x in args])\n\npSpecMaxBounds = pd.DataFrame(dict(\n  Name =  c('X',     'Alpha'),\n  Value = c(1.0E-6, akbounds['alpha_for_max_x']), # IMPORTANT to use these values.\n  Min=    c(1.0E-6, akbounds['min_alpha']),   \n  Max =   c(akbounds['max_x'], 1e6), # Alpha_max can get very large. \n)\n                             )\npp(pzc(subsim, pSpecMaxBounds))\n</pre> def c(*args):     return np.array([x for x in args])  pSpecMaxBounds = pd.DataFrame(dict(   Name =  c('X',     'Alpha'),   Value = c(1.0E-6, akbounds['alpha_for_max_x']), # IMPORTANT to use these values.   Min=    c(1.0E-6, akbounds['min_alpha']),      Max =   c(akbounds['max_x'], 1e6), # Alpha_max can get very large.  )                              ) pp(pzc(subsim, pSpecMaxBounds)) Out[27]: Name Value Min Max 0 X 0.000001 0.000001 0.373820 1 Alpha 0.130048 0.081433 48614.487117 <p>If we were to use another (X, Alpha) point e.g. X=0.1869102, the feasible bounds for Alpha change drastically. If an optimiser samples this for an initial population of points (SCE), this is unnecessarily restrictive for Alpha. Many hydrological calibration schemes were designed without consideration on feasible space that are not hypercubes.</p> In\u00a0[28]: Copied! <pre>pp(pzc(subsim, pSpecMusk))\n</pre> pp(pzc(subsim, pSpecMusk)) Out[28]: Name Value Min Max 0 X 0.186910 0.000001 0.373820 1 Alpha 0.130048 0.100153 0.260095 <p>While calibrating in the (Alpha,X) space is possible, perhaps preferable in some cases, (1/Alpha,X) has a triangular shaped feasibility region that may be easier to handle for optimisers that work with geometric transformation in the parameter space (SCE). Swift can add this on top of the constrained calibration:</p> In\u00a0[29]: Copied! <pre># (X, 1/Alpha) parametrizer with dynamically constrained min/max bounds.\ndef pzer_inv(simulation, pSpecs=pSpecMusk):\n    p_musk_c = pzc(simulation, pSpecs)\n    p_musk_inv_a = wrap_transform(p_musk_c)\n    add_transform(p_musk_inv_a, 'inv_alpha', 'Alpha', '1/x')\n    return p_musk_inv_a\n\np = pzer_inv(subsim, pSpecMaxBounds)\npp(p)\n</pre> # (X, 1/Alpha) parametrizer with dynamically constrained min/max bounds. def pzer_inv(simulation, pSpecs=pSpecMusk):     p_musk_c = pzc(simulation, pSpecs)     p_musk_inv_a = wrap_transform(p_musk_c)     add_transform(p_musk_inv_a, 'inv_alpha', 'Alpha', '1/x')     return p_musk_inv_a  p = pzer_inv(subsim, pSpecMaxBounds) pp(p) Out[29]: Name Value Min Max 0 inv_alpha 7.689486 0.000021 12.279988 1 X 0.000001 0.000001 0.373820 <p>We check that backtransforming to (Alpha-X) works:</p> In\u00a0[30]: Copied! <pre>pp(backtransform(p))\n</pre> pp(backtransform(p)) Out[30]: Name Value Min Max 0 X 0.000001 0.000001 0.373820 1 Alpha 0.130048 0.081433 48614.487117 In\u00a0[31]: Copied! <pre>someFlow = someFlow.squeeze()\n</pre> someFlow = someFlow.squeeze() In\u00a0[32]: Copied! <pre>objectiveId = 'NSE'\nobjective = create_objective(subsim, var_id, someFlow, objectiveId, xr_ts_start(someFlow), xr_ts_end(someFlow))\n</pre> objectiveId = 'NSE' objective = create_objective(subsim, var_id, someFlow, objectiveId, xr_ts_start(someFlow), xr_ts_end(someFlow)) In\u00a0[33]: Copied! <pre>score = get_score(objective,p)  \nscore\n</pre> score = get_score(objective,p)   score Out[33]: <pre>{'scores': {'NSE': 0.9997748469565144},\n 'sysconfig':         Name     Value       Min        Max\n 0  inv_alpha  7.689486  0.000021  12.279988\n 1          X  0.000001  0.000001   0.373820}</pre> In\u00a0[34]: Copied! <pre>#termination = swift::CreateSceMaxRuntimeTerminationWila_R(1/60)\ntermination = create_sce_termination_wila('relative standard deviation', c('0.001','0.0167'))\nnpars = 2\nsce_params = sce_parameter(npars)\noptimiser = create_sce_optim_swift(objective,termination_criterion = termination, population_initialiser = p,sce_params = sce_params)\ncalib_logger = set_calibration_logger(optimiser,\"dummy\")\n</pre> #termination = swift::CreateSceMaxRuntimeTerminationWila_R(1/60) termination = create_sce_termination_wila('relative standard deviation', c('0.001','0.0167')) npars = 2 sce_params = sce_parameter(npars) optimiser = create_sce_optim_swift(objective,termination_criterion = termination, population_initialiser = p,sce_params = sce_params) calib_logger = set_calibration_logger(optimiser,\"dummy\") In\u00a0[35]: Copied! <pre>%%time\ncalib_results = execute_optimisation(optimiser)\n</pre> %%time calib_results = execute_optimisation(optimiser) <pre>CPU times: user 1 s, sys: 7.8 ms, total: 1.01 s\nWall time: 327 ms\n</pre> In\u00a0[36]: Copied! <pre>opt_log = optimiser.extract_optimisation_log(fitness_name = \"NSE\")\n</pre> opt_log = optimiser.extract_optimisation_log(fitness_name = \"NSE\") In\u00a0[37]: Copied! <pre>from swift2.vis import OptimisationPlots\n\nshuffleLogs = opt_log.subset_by_message(pattern = \"Initial.*|Shuffling.*\") \nshuffleLogs.data\n</pre> from swift2.vis import OptimisationPlots  shuffleLogs = opt_log.subset_by_message(pattern = \"Initial.*|Shuffling.*\")  shuffleLogs.data Out[37]: Category CurrentShuffle Message NSE X inv_alpha PointNumber 0 Initial Population Initial Population 0.999286 0.330241 11.636989 1 1 Initial Population Initial Population 0.979734 0.251643 0.752518 2 2 Initial Population Initial Population 0.993863 0.141551 2.133362 3 3 Initial Population Initial Population 0.999939 0.149201 8.721001 4 4 Initial Population Initial Population 0.995707 0.142863 2.626987 5 ... ... ... ... ... ... ... ... 1117 Shuffling No 6 Shuffling No 6 1.000000 0.186814 7.690154 1118 1118 Shuffling No 6 Shuffling No 6 1.000000 0.186973 7.686830 1119 1119 Shuffling No 6 Shuffling No 6 1.000000 0.186925 7.690300 1120 1120 Shuffling No 6 Shuffling No 6 1.000000 0.187077 7.691259 1121 1121 Shuffling No 6 Shuffling No 6 1.000000 0.186800 7.694139 1122 <p>140 rows \u00d7 7 columns</p> In\u00a0[38]: Copied! <pre>v = OptimisationPlots(shuffleLogs)\ng = v.shuffles('X', 'inv_alpha', obj_lims = [0.0,1.0])\nplt.gcf().set_size_inches(10,8)\n</pre> v = OptimisationPlots(shuffleLogs) g = v.shuffles('X', 'inv_alpha', obj_lims = [0.0,1.0]) plt.gcf().set_size_inches(10,8) In\u00a0[39]: Copied! <pre>sortedResults = sort_by_score(calib_results, 'NSE')\nscores_as_dataframe(sortedResults).head()\n</pre> sortedResults = sort_by_score(calib_results, 'NSE') scores_as_dataframe(sortedResults).head() Out[39]: NSE inv_alpha X 0 1.0 7.689032 0.186874 1 1.0 7.690300 0.186925 2 1.0 7.690382 0.186887 3 1.0 7.690224 0.186842 4 1.0 7.689243 0.186813 In\u00a0[40]: Copied! <pre>q = get_best_score(calib_results, 'NSE', False)\nq = swg.GetSystemConfigurationWila_py(q)\npp(q)\n</pre> q = get_best_score(calib_results, 'NSE', False) q = swg.GetSystemConfigurationWila_py(q) pp(q) Out[40]: Name Value Min Max 0 inv_alpha 7.689032 3.844007 9.985182 1 X 0.186874 0.000001 0.373798 In\u00a0[41]: Copied! <pre>pp(backtransform(q))\n</pre> pp(backtransform(q)) Out[41]: Name Value Min Max 0 X 0.186874 0.000001 0.373798 1 Alpha 0.130055 0.100148 0.260145 In\u00a0[42]: Copied! <pre>pSpecRestrictiveBounds = pSpecMaxBounds\n\npSpecRestrictiveBounds.loc[pSpecRestrictiveBounds.Name == 'Alpha', 'Value'] = 0.083\n</pre> pSpecRestrictiveBounds = pSpecMaxBounds  pSpecRestrictiveBounds.loc[pSpecRestrictiveBounds.Name == 'Alpha', 'Value'] = 0.083 In\u00a0[43]: Copied! <pre>pSpecRestrictiveBounds\n</pre> pSpecRestrictiveBounds Out[43]: Name Value Min Max 0 X 0.000001 0.000001 0.37382 1 Alpha 0.083000 0.081433 1000000.00000 In\u00a0[44]: Copied! <pre>p = pzer_inv(subsim, pSpecRestrictiveBounds)\npp(p)\n</pre> p = pzer_inv(subsim, pSpecRestrictiveBounds) pp(p) Out[44]: Name Value Min Max 0 inv_alpha 12.048193 0.000021 12.279988 1 X 0.000001 0.000001 0.018877 <p>X is now much more constrained in its feasible range, and initializing a population fails to cover large sections of the feasible triangle. If used in the optimiser (uniform random sampling)</p> In\u00a0[45]: Copied! <pre>termination = create_sce_termination_wila('relative standard deviation', c('0.001','0.0167'))\nsce_params = get_default_sce_parameters()\nnpars = 2\nsce_params = sce_parameter(npars)\noptimiser = create_sce_optim_swift(objective,termination_criterion = termination, population_initialiser = p,sce_params = sce_params)\ncalib_logger = set_calibration_logger(optimiser,\"dummy\")\ncalib_results = execute_optimisation(optimiser)\n</pre> termination = create_sce_termination_wila('relative standard deviation', c('0.001','0.0167')) sce_params = get_default_sce_parameters() npars = 2 sce_params = sce_parameter(npars) optimiser = create_sce_optim_swift(objective,termination_criterion = termination, population_initialiser = p,sce_params = sce_params) calib_logger = set_calibration_logger(optimiser,\"dummy\") calib_results = execute_optimisation(optimiser) In\u00a0[46]: Copied! <pre>opt_log = extract_optimisation_log(optimiser, fitness_name = \"NSE\")\n</pre> opt_log = extract_optimisation_log(optimiser, fitness_name = \"NSE\") In\u00a0[47]: Copied! <pre>shuffleLogs = opt_log.subset_by_message(pattern = \"Initial.*|Shuffling.*\") \n</pre> shuffleLogs = opt_log.subset_by_message(pattern = \"Initial.*|Shuffling.*\")  In\u00a0[48]: Copied! <pre>v = OptimisationPlots(shuffleLogs)\ng = v.shuffles('X', 'inv_alpha', obj_lims = [0.0,1.0])\nplt.gcf().set_size_inches(10,8)\n</pre> v = OptimisationPlots(shuffleLogs) g = v.shuffles('X', 'inv_alpha', obj_lims = [0.0,1.0]) plt.gcf().set_size_inches(10,8) In\u00a0[49]: Copied! <pre># shuffleLogs = mhplot::subsetByCategory(opt_log$data, pattern = \"Initial.*|Shuffling.*\") \n# mhplot::plotShuffles(shuffleLogs, 'X', 'inv_alpha', obj_lims = (0:1))\n</pre> # shuffleLogs = mhplot::subsetByCategory(opt_log$data, pattern = \"Initial.*|Shuffling.*\")  # mhplot::plotShuffles(shuffleLogs, 'X', 'inv_alpha', obj_lims = (0:1)) <p>SCE does manage to converge towards the optimum, but it takes a larger number of iterations. Anecdotally, we observed cases where the calibration does fail to go near the optimum, when interplaying with a convergence criterion configured for \"leniency\".</p>"},{"location":"notebooks/muskingum_multilink_calibration/#linear-muskingum-channel-routing-model-constrained-subcatchment-calibration","title":"Linear Muskingum channel routing model - constrained subcatchment calibration\u00b6","text":""},{"location":"notebooks/muskingum_multilink_calibration/#purpose","title":"Purpose\u00b6","text":"<p>This vignette focuses on explaining how to calibrate the linear version of Muskingum jointly across river reaches, respecting stability constraints across all these reaches. The second part of the document is an indepth explanation of the scheme that is also used as a reference for unit testing swift.</p>"},{"location":"notebooks/muskingum_multilink_calibration/#guidelines-for-global-calibration-of-muskingum-constrainted-parameters","title":"Guidelines for global calibration of Muskingum constrainted parameters\u00b6","text":""},{"location":"notebooks/muskingum_multilink_calibration/#baseline-model-structure","title":"Baseline model structure\u00b6","text":"<p>We load and configure the model simulation in the next section, without detailed explanation; please read other introductory vignettes if this is unclear.</p>"},{"location":"notebooks/muskingum_multilink_calibration/#setting-up-calibration","title":"Setting up calibration\u00b6","text":""},{"location":"notebooks/muskingum_multilink_calibration/#seeding-the-optimisation-point-population-with-restrictive-constraint-bounds","title":"Seeding the optimisation point population with restrictive constraint bounds\u00b6","text":"<p>This section is a counter-example. Do not do this.</p> <p>Say, instead of seeding with alpha set to alpha_for_x_max (0.37382040) we instead use a value close to its global minimum, 0.083:</p>"},{"location":"notebooks/muskingum_multilink_calibration/#detailed-explanation-and-unit-test-design","title":"Detailed explanation and unit test design\u00b6","text":"<p>See other document muskingum_multilink_calibration_explanation.ipynb</p>"},{"location":"notebooks/reservoir_geometry/","title":"Reservoir geometry","text":"In\u00a0[1]: Copied! <pre>from swift2.doc_helper import pkg_versions_info\n\nprint(pkg_versions_info(\"This document was generated from a jupyter notebook\"))\n</pre> from swift2.doc_helper import pkg_versions_info  print(pkg_versions_info(\"This document was generated from a jupyter notebook\")) <pre>This document was generated from a jupyter notebook on 2025-05-16 14:19:55.008032\n    swift2 2.5.1\n    uchronia 2.6.2\n</pre> In\u00a0[2]: remove_cell Copied! <pre>from cinterop.timeseries import xr_ts_end, xr_ts_start\nfrom swift2.doc_helper import (\n    configure_hourly_gr4j,\n    define_parameteriser_gr4j_muskingum,\n    sample_catchment_model,\n    sample_series,\n)\nfrom swift2.simulation import swap_model\nfrom swift2.utils import mk_full_data_id\nfrom swift2.vis import plot_two_series\n</pre> from cinterop.timeseries import xr_ts_end, xr_ts_start from swift2.doc_helper import (     configure_hourly_gr4j,     define_parameteriser_gr4j_muskingum,     sample_catchment_model,     sample_series, ) from swift2.simulation import swap_model from swift2.utils import mk_full_data_id from swift2.vis import plot_two_series In\u00a0[3]: remove_cell Copied! <pre># swiftr_dev()\n</pre> # swiftr_dev() In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[4]: Copied! <pre>catchmentStructure = sample_catchment_model(site_id = \"Adelaide\", config_id = \"catchment\")\n\nhydromodel = \"GR4J\"\nchannel_routing = 'MuskingumNonLinear'\nhydroModelRainfallId = 'P'\nhydroModelEvapId = 'E'\n\n# set models\ninsimulation = swap_model(catchmentStructure, model_id = hydromodel ,what = \"runoff\")\nsimulation = swap_model(insimulation, model_id = channel_routing ,what = \"channel_routing\")\n\nsaId = simulation.get_subarea_ids()\nassert len(saId) == 1\n\nprecipTs = sample_series(site_id = \"Adelaide\", var_name = \"rain\")\nevapTs = sample_series(site_id = \"Adelaide\", var_name = \"evap\")\nflowRateTs = sample_series(site_id = \"Adelaide\", var_name = \"flow\")\n</pre> catchmentStructure = sample_catchment_model(site_id = \"Adelaide\", config_id = \"catchment\")  hydromodel = \"GR4J\" channel_routing = 'MuskingumNonLinear' hydroModelRainfallId = 'P' hydroModelEvapId = 'E'  # set models insimulation = swap_model(catchmentStructure, model_id = hydromodel ,what = \"runoff\") simulation = swap_model(insimulation, model_id = channel_routing ,what = \"channel_routing\")  saId = simulation.get_subarea_ids() assert len(saId) == 1  precipTs = sample_series(site_id = \"Adelaide\", var_name = \"rain\") evapTs = sample_series(site_id = \"Adelaide\", var_name = \"evap\") flowRateTs = sample_series(site_id = \"Adelaide\", var_name = \"flow\") In\u00a0[5]: Copied! <pre>mk_full_data_id('subarea', saId, hydroModelRainfallId)\n</pre> mk_full_data_id('subarea', saId, hydroModelRainfallId) Out[5]: <pre>['subarea.1.P']</pre> In\u00a0[6]: Copied! <pre>simulation.play_input(precipTs, mk_full_data_id('subarea', saId, hydroModelRainfallId))\nsimulation.play_input(evapTs, mk_full_data_id('subarea', saId, hydroModelEvapId))\nconfigure_hourly_gr4j(simulation)\nsimulation.set_simulation_time_step('hourly')\n\n# Small time interval only, to reduce runtimes in this vignette\n\nfrom uchronia.time_series import mk_date\n\nsimstart = mk_date(2010,9,1)  \nsimend = mk_date(2012,6,30,23)  \nsimwarmup = simstart\nsimulation.set_simulation_span(simstart, simend)\n</pre> simulation.play_input(precipTs, mk_full_data_id('subarea', saId, hydroModelRainfallId)) simulation.play_input(evapTs, mk_full_data_id('subarea', saId, hydroModelEvapId)) configure_hourly_gr4j(simulation) simulation.set_simulation_time_step('hourly')  # Small time interval only, to reduce runtimes in this vignette  from uchronia.time_series import mk_date  simstart = mk_date(2010,9,1)   simend = mk_date(2012,6,30,23)   simwarmup = simstart simulation.set_simulation_span(simstart, simend) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[7]: Copied! <pre>def templateHydroParameterizer(simulation):\n    return define_parameteriser_gr4j_muskingum(ref_area=250.0,\n        time_span=3600,\n        simulation=simulation,\n        objfun=\"NSE\",\n        delta_t=1.0,\n        param_name_k='Alpha')\n\n\nnodeId = 'node.2'\nflowId = mk_full_data_id(nodeId, 'OutflowRate')\n\nsimulation.record_state(flowId)\n</pre> def templateHydroParameterizer(simulation):     return define_parameteriser_gr4j_muskingum(ref_area=250.0,         time_span=3600,         simulation=simulation,         objfun=\"NSE\",         delta_t=1.0,         param_name_k='Alpha')   nodeId = 'node.2' flowId = mk_full_data_id(nodeId, 'OutflowRate')  simulation.record_state(flowId) <p>We use pre-calibrated hydrologic parameters</p> In\u00a0[8]: Copied! <pre>p = templateHydroParameterizer(simulation)\np.set_min_parameter_value('R0', 0.0)\np.set_max_parameter_value('R0', 1.0)\np.set_min_parameter_value('S0', 0.0)\np.set_max_parameter_value('S0', 1.0)\np.set_parameter_value('log_x4', 1.017730e+00)\np.set_parameter_value('log_x1', 2.071974e+00\t)\np.set_parameter_value('log_x3', 1.797909e+00\t)\np.set_parameter_value('asinh_x2', -1.653842e+00)\t\np.set_parameter_value('R0', 2.201930e-11\t)\np.set_parameter_value('S0', 3.104968e-11\t)\np.set_parameter_value('X', 6.595537e-03\t) # Gotcha: needs to be set before alpha is changed.\np.set_parameter_value('Alpha', 6.670534e-01\t)\np\n</pre> p = templateHydroParameterizer(simulation) p.set_min_parameter_value('R0', 0.0) p.set_max_parameter_value('R0', 1.0) p.set_min_parameter_value('S0', 0.0) p.set_max_parameter_value('S0', 1.0) p.set_parameter_value('log_x4', 1.017730e+00) p.set_parameter_value('log_x1', 2.071974e+00\t) p.set_parameter_value('log_x3', 1.797909e+00\t) p.set_parameter_value('asinh_x2', -1.653842e+00)\t p.set_parameter_value('R0', 2.201930e-11\t) p.set_parameter_value('S0', 3.104968e-11\t) p.set_parameter_value('X', 6.595537e-03\t) # Gotcha: needs to be set before alpha is changed. p.set_parameter_value('Alpha', 6.670534e-01\t) p Out[8]: <pre>       Name         Value       Min       Max\n0    log_x4  1.017730e+00  0.000000  2.380211\n1    log_x1  2.071974e+00  0.000000  3.778151\n2    log_x3  1.797909e+00  0.000000  3.000000\n3  asinh_x2 -1.653842e+00 -3.989327  3.989327\n4        R0  2.201930e-11  0.000000  1.000000\n5        S0  3.104968e-11  0.000000  1.000000\n6         X  6.595537e-03  0.001000  0.016622\n7     Alpha  6.670534e-01  0.011162  1.681129</pre> <p>We get a visual on the output of the catchment simulation.</p> In\u00a0[9]: Copied! <pre>sViz = mk_date(2010,12,1)\neViz = mk_date(2011,4,30,23)\n\ndef subsetPlot(tts):\n    from cinterop.timeseries import ts_window\n    return ts_window(tts, from_date=sViz, to_date=eViz) \n\ndef plot_obs_vs_calc(obs, calc, ylab=\"flow (m3/s)\"):\n    obs = subsetPlot(obs)\n    calc = subsetPlot(calc)\n    return plot_two_series(obs, calc, ylab=ylab, start_time = xr_ts_start(calc), end_time = xr_ts_end(calc))\n\np.apply_sys_config(simulation)\nsimulation.exec_simulation()\ncatchmentOutflowNoReservoir = simulation.get_recorded(flowId)\nplot_obs_vs_calc(flowRateTs, catchmentOutflowNoReservoir)\n</pre> sViz = mk_date(2010,12,1) eViz = mk_date(2011,4,30,23)  def subsetPlot(tts):     from cinterop.timeseries import ts_window     return ts_window(tts, from_date=sViz, to_date=eViz)   def plot_obs_vs_calc(obs, calc, ylab=\"flow (m3/s)\"):     obs = subsetPlot(obs)     calc = subsetPlot(calc)     return plot_two_series(obs, calc, ylab=ylab, start_time = xr_ts_start(calc), end_time = xr_ts_end(calc))  p.apply_sys_config(simulation) simulation.exec_simulation() catchmentOutflowNoReservoir = simulation.get_recorded(flowId) plot_obs_vs_calc(flowRateTs, catchmentOutflowNoReservoir) In\u00a0[10]: Copied! <pre>simulation.get_node_ids(), simulation.get_node_names()\n</pre> simulation.get_node_ids(), simulation.get_node_names() Out[10]: <pre>(['2', '1'], ['Outlet', 'Node_1'])</pre> <p>We create a synthetic, simple LVA geometry for this vignette.</p> In\u00a0[11]: Copied! <pre>simulation.set_reservoir_model('LevelVolumeAreaReservoir', nodeId)\n</pre> simulation.set_reservoir_model('LevelVolumeAreaReservoir', nodeId) In\u00a0[12]: Copied! <pre>import numpy as np\n\n\ndef seq(start, stop, by):\n    import math\n    assert by &gt; 0\n    n = int(math.floor( (stop - start + 1) / by ))\n    return np.linspace(start=start, stop=(start+n*by-1), num=n)\n</pre> import numpy as np   def seq(start, stop, by):     import math     assert by &gt; 0     n = int(math.floor( (stop - start + 1) / by ))     return np.linspace(start=start, stop=(start+n*by-1), num=n) In\u00a0[13]: Copied! <pre>seq(1, 6, 1)\n</pre> seq(1, 6, 1) Out[13]: <pre>array([1., 2., 3., 4., 5., 6.])</pre> In\u00a0[14]: Copied! <pre>seq(1, 6-0.1, 1)\n</pre> seq(1, 6-0.1, 1) Out[14]: <pre>array([1., 2., 3., 4., 5.])</pre> In\u00a0[15]: Copied! <pre>import numpy as np\n\nlevels = seq(start=10.0, stop=30, by=0.1)\nvolumes = (levels - 10) ** 3.1 * 17000\narea = volumes * 0.0\n</pre> import numpy as np  levels = seq(start=10.0, stop=30, by=0.1) volumes = (levels - 10) ** 3.1 * 17000 area = volumes * 0.0 In\u00a0[16]: Copied! <pre>fsv_height = 27.0\n\nlevels &gt;= fsv_height\n</pre> fsv_height = 27.0  levels &gt;= fsv_height Out[16]: <pre>array([False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False, False, False, False, False, False,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True])</pre> In\u00a0[17]: Copied! <pre>fsv_index = np.where(levels &gt;= fsv_height)[0][0]\n</pre> fsv_index = np.where(levels &gt;= fsv_height)[0][0] In\u00a0[18]: Copied! <pre>fsv = volumes[fsv_index]\n\nsimulation.set_reservoir_geometry(nodeId, levels, volumes, area)\n</pre> fsv = volumes[fsv_index]  simulation.set_reservoir_geometry(nodeId, levels, volumes, area) <p>We also create synthetic level-discharge relationships. These define the minimum and maximum outflow rates for a reservoir, given its current level. This is a generic way to capture the behavior of many reservoirs; the minimum discharge curve is typically capture the uncontrolled overspill. The maximum discharge curve is for the outflow rate with all outlets and spillway gates open. Specialisations of this reservoir (for instance as inheriting C++ classes) can then refine the behavior with additional rules on the controlled releases.</p> <p>In this example for the sake of simplicity we set up identical minimal and maximal curves. Let's say the reservoir spills above 27 metres, and between 20 and 27 the outflow rate is linear.</p> In\u00a0[19]: Copied! <pre>min_d_levels = seq(start=20, stop=fsv_height-0.01, by=0.1)\nmax_outlet_rate = 20\ndischarge = np.linspace( 1, len(min_d_levels), num=len(min_d_levels)) / len(min_d_levels) * max_outlet_rate\nmin_d_levels_spill = seq(start=fsv_height, stop=30, by=0.1)\ndischarge_spill = (min_d_levels_spill - fsv_height) ** 3.5 * 40 + max_outlet_rate\n\n\n# from swift2.utils import c\n\nmin_d_levels = np.concatenate([min_d_levels, min_d_levels_spill])\ndischarge = np.concatenate([discharge, discharge_spill])\n</pre> min_d_levels = seq(start=20, stop=fsv_height-0.01, by=0.1) max_outlet_rate = 20 discharge = np.linspace( 1, len(min_d_levels), num=len(min_d_levels)) / len(min_d_levels) * max_outlet_rate min_d_levels_spill = seq(start=fsv_height, stop=30, by=0.1) discharge_spill = (min_d_levels_spill - fsv_height) ** 3.5 * 40 + max_outlet_rate   # from swift2.utils import c  min_d_levels = np.concatenate([min_d_levels, min_d_levels_spill]) discharge = np.concatenate([discharge, discharge_spill]) In\u00a0[20]: Copied! <pre>simulation.set_reservoir_min_discharge(nodeId, min_d_levels, discharge)\nsimulation.set_reservoir_max_discharge(nodeId, min_d_levels, discharge)\n</pre> simulation.set_reservoir_min_discharge(nodeId, min_d_levels, discharge) simulation.set_reservoir_max_discharge(nodeId, min_d_levels, discharge) <p>Let's see the resulting behavior of this storage</p> In\u00a0[21]: Copied! <pre>simulation.record_state(mk_full_data_id(nodeId, 'reservoir.Storage'))\nsimulation.record_state(mk_full_data_id(nodeId, 'reservoir.OutflowRate'))\nsimulation.record_state(mk_full_data_id(nodeId, 'reservoir.InflowRate'))\n\nsimulation.exec_simulation()\n\nst = simulation.get_recorded(mk_full_data_id(nodeId, 'reservoir.Storage'))\nst_gl = st / 1e6 # m3 to GL\nhline = st_gl.copy()\nhline[:] = fsv / 1e6\nimport matplotlib.pyplot as plt\n</pre> simulation.record_state(mk_full_data_id(nodeId, 'reservoir.Storage')) simulation.record_state(mk_full_data_id(nodeId, 'reservoir.OutflowRate')) simulation.record_state(mk_full_data_id(nodeId, 'reservoir.InflowRate'))  simulation.exec_simulation()  st = simulation.get_recorded(mk_full_data_id(nodeId, 'reservoir.Storage')) st_gl = st / 1e6 # m3 to GL hline = st_gl.copy() hline[:] = fsv / 1e6 import matplotlib.pyplot as plt In\u00a0[22]: Copied! <pre>from swift2.vis import plot_series\n</pre> from swift2.vis import plot_series In\u00a0[23]: Copied! <pre>plot_two_series(st_gl, hline, names=['storage','FSV'], ylab='gigalitres', title=f\"Reservoir levels at node {nodeId}\")\n</pre> plot_two_series(st_gl, hline, names=['storage','FSV'], ylab='gigalitres', title=f\"Reservoir levels at node {nodeId}\") In\u00a0[24]: Copied! <pre>catchmentOutflowWithReservoir = simulation.get_recorded(flowId)\n</pre> catchmentOutflowWithReservoir = simulation.get_recorded(flowId) In\u00a0[25]: Copied! <pre>plot_series(catchmentOutflowNoReservoir, title=\"Catchment outflow (m3/s)\", ylab=\"m3/s\")\n</pre> plot_series(catchmentOutflowNoReservoir, title=\"Catchment outflow (m3/s)\", ylab=\"m3/s\") In\u00a0[26]: Copied! <pre>plot_two_series(catchmentOutflowNoReservoir, catchmentOutflowWithReservoir, \n                names=[\"No reservoir\", \"With Reservoir\"], \n                ylab='m3/s', \n                title=f\"Outflow rate at {nodeId}\")\n</pre> plot_two_series(catchmentOutflowNoReservoir, catchmentOutflowWithReservoir,                  names=[\"No reservoir\", \"With Reservoir\"],                  ylab='m3/s',                  title=f\"Outflow rate at {nodeId}\") In\u00a0[27]: Copied! <pre>catchmentOutflowWithReservoir\n</pre> catchmentOutflowWithReservoir Out[27]: <pre>&lt;xarray.DataArray (variable_identifiers: 1, ensemble: 1, time: 16056)&gt; Size: 128kB\narray([[[0.        , 0.        , 0.        , ..., 4.09947517,\n         4.09481659, 4.0901634 ]]], shape=(1, 1, 16056))\nCoordinates:\n  * ensemble              (ensemble) int64 8B 0\n  * time                  (time) datetime64[ns] 128kB 2010-09-01 ... 2012-06-...\n  * variable_identifiers  (variable_identifiers) object 8B 'node.2.OutflowRate'</pre>xarray.DataArray<ul><li>variable_identifiers: 1</li><li>ensemble: 1</li><li>time: 16056</li></ul><ul><li>0.0 0.0 0.0 0.0 0.0 0.0 0.0 ... 4.113 4.109 4.104 4.099 4.095 4.09<pre>array([[[0.        , 0.        , 0.        , ..., 4.09947517,\n         4.09481659, 4.0901634 ]]], shape=(1, 1, 16056))</pre></li><li>Coordinates: (3)<ul><li>ensemble(ensemble)int640<pre>array([0])</pre></li><li>time(time)datetime64[ns]2010-09-01 ... 2012-06-30T23:00:00<pre>array(['2010-09-01T00:00:00.000000000', '2010-09-01T01:00:00.000000000',\n       '2010-09-01T02:00:00.000000000', ..., '2012-06-30T21:00:00.000000000',\n       '2012-06-30T22:00:00.000000000', '2012-06-30T23:00:00.000000000'],\n      shape=(16056,), dtype='datetime64[ns]')</pre></li><li>variable_identifiers(variable_identifiers)object'node.2.OutflowRate'<pre>array(['node.2.OutflowRate'], dtype=object)</pre></li></ul></li><li>Indexes: (3)<ul><li>ensemblePandasIndex<pre>PandasIndex(Index([0], dtype='int64', name='ensemble'))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2010-09-01 00:00:00', '2010-09-01 01:00:00',\n               '2010-09-01 02:00:00', '2010-09-01 03:00:00',\n               '2010-09-01 04:00:00', '2010-09-01 05:00:00',\n               '2010-09-01 06:00:00', '2010-09-01 07:00:00',\n               '2010-09-01 08:00:00', '2010-09-01 09:00:00',\n               ...\n               '2012-06-30 14:00:00', '2012-06-30 15:00:00',\n               '2012-06-30 16:00:00', '2012-06-30 17:00:00',\n               '2012-06-30 18:00:00', '2012-06-30 19:00:00',\n               '2012-06-30 20:00:00', '2012-06-30 21:00:00',\n               '2012-06-30 22:00:00', '2012-06-30 23:00:00'],\n              dtype='datetime64[ns]', name='time', length=16056, freq='h'))</pre></li><li>variable_identifiersPandasIndex<pre>PandasIndex(Index(['node.2.OutflowRate'], dtype='object', name='variable_identifiers'))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[28]: Copied! <pre># jsonFilePath = tempfile()\n# SaveModelSimulationToJson_R(simulation, jsonFilePath)\n\n# loaded_simulation = LoadModelSimulationFromJson_R(jsonFilePath)\n\n\n# loaded_simulation.play_input(precipTs, mk_full_data_id('subarea', saId, hydroModelRainfallId))\n# loaded_simulation.play_input(evapTs, mk_full_data_id('subarea', saId, hydroModelEvapId))\n# simulation.set_simulation_time_step('hourly')\n# simstart = mk_date(2010,9,1)  \n# simend = mk_date(2012,6,30,23)  \n# loaded_simulation.set_simulation_span(simstart, simend)\n\n# loaded_simulation.record_state(mk_full_data_id(nodeId, 'reservoir.Storage'))\n# loaded_simulation.exec_simulation()\n\n# st_loaded = loaded_simulation.get_recorded(mk_full_data_id(nodeId, 'reservoir.Storage'))\n# hline = st_loaded\n# hline[:] = fsv\n# plot(st_loaded, main='Reservoir volume m^3', ylab='m^3')\n# lines(hline, col = \"blue\")\n</pre> # jsonFilePath = tempfile() # SaveModelSimulationToJson_R(simulation, jsonFilePath)  # loaded_simulation = LoadModelSimulationFromJson_R(jsonFilePath)   # loaded_simulation.play_input(precipTs, mk_full_data_id('subarea', saId, hydroModelRainfallId)) # loaded_simulation.play_input(evapTs, mk_full_data_id('subarea', saId, hydroModelEvapId)) # simulation.set_simulation_time_step('hourly') # simstart = mk_date(2010,9,1)   # simend = mk_date(2012,6,30,23)   # loaded_simulation.set_simulation_span(simstart, simend)  # loaded_simulation.record_state(mk_full_data_id(nodeId, 'reservoir.Storage')) # loaded_simulation.exec_simulation()  # st_loaded = loaded_simulation.get_recorded(mk_full_data_id(nodeId, 'reservoir.Storage')) # hline = st_loaded # hline[:] = fsv # plot(st_loaded, main='Reservoir volume m^3', ylab='m^3') # lines(hline, col = \"blue\") In\u00a0[29]: Copied! <pre>simulation.exec_simulation()\n</pre> simulation.exec_simulation() In\u00a0[30]: Copied! <pre>simulation.get_recorded(mk_full_data_id(nodeId, 'reservoir.Storage'))\norate = simulation.get_recorded(mk_full_data_id(nodeId, 'reservoir.OutflowRate'))\nirate = simulation.get_recorded(mk_full_data_id(nodeId, 'reservoir.InflowRate'))\n</pre> simulation.get_recorded(mk_full_data_id(nodeId, 'reservoir.Storage')) orate = simulation.get_recorded(mk_full_data_id(nodeId, 'reservoir.OutflowRate')) irate = simulation.get_recorded(mk_full_data_id(nodeId, 'reservoir.InflowRate')) In\u00a0[31]: Copied! <pre>plot_two_series(irate, orate, \n                names=[\"irage\", \"orate\"], \n                ylab='m3/s', \n                title=f\"Inflow and Outflow rate at {nodeId}\")\n</pre> plot_two_series(irate, orate,                  names=[\"irage\", \"orate\"],                  ylab='m3/s',                  title=f\"Inflow and Outflow rate at {nodeId}\") In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/reservoir_geometry/#reservoir-geometry","title":"Reservoir geometry\u00b6","text":""},{"location":"notebooks/reservoir_geometry/#about-this-document","title":"About this document\u00b6","text":""},{"location":"notebooks/reservoir_geometry/#model-structure","title":"Model structure\u00b6","text":"<p>Setting up this model is not the primary purpose of this vignette, so you may skip this section.</p>"},{"location":"notebooks/reservoir_geometry/#set-up-the-reservoir-model","title":"Set up the reservoir model\u00b6","text":"<p>The catchment is simple, with node 2 being the outlet of the catchment so this is where we will add the reservoir</p>"}]}